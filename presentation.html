<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Presentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #000000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .presentation-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            position: relative;
            overflow: auto;
            /* Hide scrollbars while keeping scroll functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .presentation-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .pdf-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        #pdfCanvas {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            background-color: white;
            display: block;
            object-fit: contain;
        }

        .annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .annotation-layer path {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #ffffff;
        }

        .page-indicator {
            display: none; /* Hidden in presentation mode */
        }

        .page-transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.2s ease;
        }

        /* Quick Note Styles */
        .quick-note-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 100;
            pointer-events: none;
        }

        .quick-note-window {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
        }

        .quick-note-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .quick-note-canvas {
            width: 100% !important;
            height: 100% !important;
            background:
                linear-gradient(rgba(0, 0, 0, 0.06) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.06) 1px, transparent 1px),
                linear-gradient(rgba(13, 110, 253, 0.12) 1px, transparent 1px),
                linear-gradient(90deg, rgba(13, 110, 253, 0.12) 1px, transparent 1px),
                white;
            background-size: 20px 20px, 20px 20px, 100px 100px, 100px 100px, 100%;
            background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
        }

        .quick-note-annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .quick-note-annotation-layer path {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
    </style>
</head>
<body>
    <div class="presentation-container">
        <div class="loading" id="loading">Waiting for presentation...</div>
        <div class="pdf-wrapper" id="pdfWrapper" style="display: none;">
            <canvas id="pdfCanvas"></canvas>
            <svg id="annotationLayer" class="annotation-layer"></svg>
            <canvas id="activeStrokeCanvas" class="annotation-layer"></canvas>
            <div id="pageTransitionOverlay" class="page-transition-overlay"></div>
            <div class="page-indicator" id="pageIndicator">1 / 1</div>
        </div>
    </div>

    <!-- Quick Note Window -->
    <div id="quickNoteOverlay" class="quick-note-overlay" style="display: none;">
        <div class="quick-note-window">
            <div class="quick-note-content">
                <canvas id="quickNoteCanvas" class="quick-note-canvas"></canvas>
                <svg id="quickNoteAnnotationLayer" class="quick-note-annotation-layer"></svg>
            </div>
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="pdf.min.js"></script>
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';

        // Presentation state
        let pdfDoc = null;
        let currentPage = 1;
        let currentScale = 1.5;
        let annotations = {};
        let presentationConnection = null;

        // Track annotation SVG elements for incremental updates (prevent flicker)
        // Map of page number -> array of {annotation: object, svgPath: element}
        let annotationElements = {};

        const canvas = document.getElementById('pdfCanvas');
        const ctx = canvas.getContext('2d');
        const annotationLayer = document.getElementById('annotationLayer');
        const activeStrokeCanvas = document.getElementById('activeStrokeCanvas');
        const activeStrokeCtx = activeStrokeCanvas.getContext('2d');
        const pdfWrapper = document.getElementById('pdfWrapper');
        const pageTransitionOverlay = document.getElementById('pageTransitionOverlay');
        const loading = document.getElementById('loading');
        const pageIndicator = document.getElementById('pageIndicator');

        // Store laser strokes for redrawing
        let savedLaserStrokes = [];
        let savedLaserOpacity = 1.0;

        // Check if running from file:// protocol (local without server)
        function isRunningLocally() {
            return window.location.protocol === 'file:';
        }

        // Initialize BroadcastChannel receiver for local file:// fallback
        function initBroadcastChannelReceiver() {
            console.log('Initializing BroadcastChannel receiver for local mode');

            const broadcastChannel = new BroadcastChannel('pdf_presentation');

            broadcastChannel.onmessage = (event) => {
                console.log('Received message via BroadcastChannel:', event.data.type);
                handleMessage(event.data);
            };

            // Update loading message
            loading.textContent = 'Connected via local mode! Waiting for PDF data...';
            loading.style.display = 'block';

            console.log('BroadcastChannel receiver initialized and listening');

            // Send ready message to main window
            broadcastChannel.postMessage({ type: 'PRESENTATION_READY' });
            console.log('Sent PRESENTATION_READY message to main window');
        }

        // Initialize Presentation Receiver
        async function initPresentationReceiver() {
            console.log('Initializing presentation receiver...');
            console.log('navigator.presentation:', navigator.presentation);
            console.log('navigator.presentation.receiver:', navigator.presentation?.receiver);

            // FALLBACK: Use BroadcastChannel for local file:// usage
            if (isRunningLocally()) {
                console.log('Running locally (file://), using BroadcastChannel instead of Presentation API');
                initBroadcastChannelReceiver();
                return;
            }

            if (!navigator.presentation || !navigator.presentation.receiver) {
                console.warn('Presentation Receiver API not supported');
                // Fallback: This page was opened directly, not as a presentation
                loading.textContent = 'Not opened as presentation. Use the cast button in the main app.';
                return;
            }

            try {
                console.log('Getting connection list...');
                const connectionList = await navigator.presentation.receiver.connectionList;
                console.log('Connection list received:', connectionList);
                console.log('Existing connections:', connectionList.connections.length);

                connectionList.connections.forEach(connection => {
                    console.log('Setting up existing connection');
                    setupConnection(connection);
                });

                connectionList.addEventListener('connectionavailable', (event) => {
                    console.log('New connection available');
                    setupConnection(event.connection);
                });

                console.log('Receiver initialized successfully');
            } catch (err) {
                console.error('Failed to initialize presentation receiver:', err);
                loading.textContent = 'Error: ' + err.message;
            }
        }

        function setupConnection(connection) {
            presentationConnection = connection;
            console.log('Presentation connection established, state:', connection.state);
            console.log('Connection ID:', connection.id);

            // Reset state for new connection
            pdfDoc = null;
            currentPage = 1;
            annotations = {};

            // Update loading message
            loading.style.display = 'block';
            loading.textContent = 'Connected! Waiting for PDF data...';
            pdfWrapper.style.display = 'none';

            // Listen for messages from controller
            connection.addEventListener('message', (event) => {
                console.log('Message received, length:', event.data.length);
                try {
                    const data = JSON.parse(event.data);
                    console.log('Message type:', data.type);
                    handleMessage(data);
                } catch (err) {
                    console.error('Failed to parse message:', err, 'Data:', event.data.substring(0, 100));
                }
            });

            connection.addEventListener('close', () => {
                console.log('Presentation connection closed');
                resetPresentationState();
            });

            connection.addEventListener('terminate', () => {
                console.log('Presentation terminated');
                resetPresentationState();
                // Note: Don't close window, just reset to allow reconnection
            });

            console.log('Connection setup complete');
        }

        function resetPresentationState() {
            console.log('Resetting presentation state');

            // Clear presentation data
            pdfDoc = null;
            currentPage = 1;
            annotations = {};
            presentationConnection = null;

            // Clear annotation tracking
            annotationElements = {};

            // Reset UI
            loading.style.display = 'block';
            loading.textContent = 'Waiting for presentation...';
            pdfWrapper.style.display = 'none';

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Clear annotations
            while (annotationLayer.firstChild) {
                annotationLayer.removeChild(annotationLayer.firstChild);
            }

            console.log('Presentation state reset, ready for reconnection');
        }

        function handleMessage(data) {
            console.log('Handling message:', data.type);
            switch (data.type) {
                case 'LOAD_PDF':
                    console.log('Loading PDF, data size:', data.pdfData.length);
                    loadPDF(data.pdfData);
                    break;
                case 'PAGE_CHANGE':
                    console.log('Changing page to:', data.pageNum);
                    currentPage = data.pageNum;
                    renderPage(currentPage);
                    break;
                case 'SCALE_CHANGE':
                    console.log('Changing scale to:', data.scale);
                    currentScale = data.scale;
                    renderPage(currentPage);
                    break;
                case 'ANNOTATIONS_UPDATE':
                    console.log('Updating annotations');
                    annotations = data.annotations;
                    // For annotation updates, only update the SVG layer without re-rendering PDF
                    // This prevents transform issues from re-rendering
                    if (pdfDoc) {
                        loadPageAnnotations();
                    }
                    break;
                case 'ACTIVE_STROKE':
                    // Real-time drawing (pen, lasso)
                    console.log('ACTIVE_STROKE received, tool:', data.tool, 'points:', data.points?.length);
                    drawActiveStroke(data);
                    break;
                case 'LASER_STROKES':
                    // Receive all laser strokes from main screen
                    console.log('LASER_STROKES received, count:', data.strokes?.length, 'opacity:', data.opacity);
                    drawLaserStrokes(data.strokes, data.opacity);
                    break;
                case 'CLEAR_ACTIVE_STROKE':
                    // Clear temporary drawing canvas
                    clearActiveStroke();
                    break;
                case 'SELECTION_BOX':
                    // Draw selection box with normalized bounds
                    console.log('Drawing selection box:', data.bounds);
                    drawSelectionBox(data.bounds);
                    break;
                case 'CLEAR_SELECTION_BOX':
                    // Clear selection box
                    console.log('Clearing selection box');
                    clearActiveStroke();
                    break;
                case 'SCROLL_POSITION':
                    // Sync scroll position from main screen
                    applyScrollPosition(data.scrollX, data.scrollY);
                    break;
                case 'QUICK_NOTE_OPEN':
                    // Show Quick Note
                    console.log('Opening Quick Note in presentation');
                    openQuickNotePresentation();
                    break;
                case 'QUICK_NOTE_CLOSE':
                    // Hide Quick Note
                    console.log('Closing Quick Note in presentation');
                    closeQuickNotePresentation();
                    break;
                case 'QUICK_NOTE_ANNOTATIONS_UPDATE':
                    // Update Quick Note annotations
                    console.log('Updating Quick Note annotations in presentation');
                    updateQuickNoteAnnotations(data.annotations);
                    break;
                default:
                    console.warn('Unknown message type:', data.type);
            }
        }

        // Quick Note in Presentation Screen
        const quickNoteOverlay = document.getElementById('quickNoteOverlay');
        const quickNoteCanvas = document.getElementById('quickNoteCanvas');
        const quickNoteAnnotationLayer = document.getElementById('quickNoteAnnotationLayer');
        let quickNoteAnnotations = [];

        function openQuickNotePresentation() {
            quickNoteOverlay.style.display = 'flex';
            initQuickNoteCanvasPresentation();
        }

        function closeQuickNotePresentation() {
            quickNoteOverlay.style.display = 'none';
        }

        function initQuickNoteCanvasPresentation() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;

            quickNoteCanvas.style.width = width + 'px';
            quickNoteCanvas.style.height = height + 'px';
            quickNoteCanvas.width = width * dpr;
            quickNoteCanvas.height = height * dpr;

            quickNoteAnnotationLayer.setAttribute('width', width);
            quickNoteAnnotationLayer.setAttribute('height', height);

            console.log('Quick Note canvas initialized in presentation:', width, 'x', height);
        }

        function updateQuickNoteAnnotations(annotations) {
            quickNoteAnnotations = annotations || [];

            // Clear SVG
            while (quickNoteAnnotationLayer.firstChild) {
                quickNoteAnnotationLayer.removeChild(quickNoteAnnotationLayer.firstChild);
            }

            // Redraw all strokes
            quickNoteAnnotations.forEach(stroke => {
                // Skip laser strokes
                if (stroke.tool === 'laser') return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', quickNotePointsToPath(stroke.points));
                path.setAttribute('stroke', stroke.color);
                path.setAttribute('stroke-width', stroke.width);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', stroke.opacity || 1);
                quickNoteAnnotationLayer.appendChild(path);
            });
        }

        function quickNotePointsToPath(points) {
            if (points.length === 0) return '';
            if (points.length === 1) {
                return `M ${points[0].x} ${points[0].y} L ${points[0].x + 0.1} ${points[0].y + 0.1}`;
            }

            let path = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                path += ` L ${points[i].x} ${points[i].y}`;
            }
            return path;
        }

        function applyScrollPosition(normalizedX, normalizedY) {
            const container = document.querySelector('.presentation-container');
            if (!container) return;

            // Calculate actual scroll positions from normalized values
            const maxScrollLeft = container.scrollWidth - container.clientWidth;
            const maxScrollTop = container.scrollHeight - container.clientHeight;

            const scrollLeft = normalizedX * maxScrollLeft;
            const scrollTop = normalizedY * maxScrollTop;

            // Apply scroll position
            container.scrollLeft = scrollLeft;
            container.scrollTop = scrollTop;
        }

        // Draw all laser strokes received from main screen
        function drawLaserStrokes(strokes, opacity) {
            // Save laser strokes for redrawing when ACTIVE_STROKE comes in
            savedLaserStrokes = strokes || [];
            savedLaserOpacity = opacity || 1.0;

            if (!pdfDoc || !strokes || strokes.length === 0) {
                // Clear if no strokes
                clearActiveStroke();
                return;
            }

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            // Sync active stroke canvas size
            const bufferWidth = width * dpr;
            const bufferHeight = height * dpr;

            if (activeStrokeCanvas.width !== bufferWidth || activeStrokeCanvas.height !== bufferHeight) {
                activeStrokeCanvas.width = bufferWidth;
                activeStrokeCanvas.height = bufferHeight;
                activeStrokeCanvas.style.width = width + 'px';
                activeStrokeCanvas.style.height = height + 'px';
            }

            // Clear canvas
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);

            // Reset transform and apply DPR scaling
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.scale(dpr, dpr);

            // Draw all laser strokes
            strokes.forEach(stroke => {
                if (!stroke.points || stroke.points.length === 0) return;
                const screenPoints = stroke.points.map(p => ({
                    x: p.x * width,
                    y: p.y * height
                }));

                // First pass: Draw glow/shadow effect
                activeStrokeCtx.strokeStyle = `rgba(255, 0, 0, ${opacity})`;
                activeStrokeCtx.lineWidth = 4;
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.shadowBlur = 15;
                activeStrokeCtx.shadowColor = `rgba(255, 0, 0, ${opacity * 0.9})`;
                activeStrokeCtx.shadowOffsetX = 0;
                activeStrokeCtx.shadowOffsetY = 0;

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();

                // Second pass: Draw bright core line on top
                activeStrokeCtx.strokeStyle = `rgba(255, 200, 200, ${opacity})`;
                activeStrokeCtx.lineWidth = 0.8;
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();
            });
        }

        function drawActiveStroke(data) {
            if (!pdfDoc) return;

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            // Sync active stroke canvas size to match PDF canvas
            const bufferWidth = width * dpr;
            const bufferHeight = height * dpr;

            if (activeStrokeCanvas.width !== bufferWidth || activeStrokeCanvas.height !== bufferHeight) {
                activeStrokeCanvas.width = bufferWidth;
                activeStrokeCanvas.height = bufferHeight;
                activeStrokeCanvas.style.width = width + 'px';
                activeStrokeCanvas.style.height = height + 'px';
            }

            // Clear previous active stroke
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);

            // CRITICAL: Reset transform and apply DPR scaling
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.scale(dpr, dpr);

            // CRITICAL FIX: If drawing laser, redraw all saved laser strokes first
            if (data.tool === 'laser' && savedLaserStrokes.length > 0) {
                savedLaserStrokes.forEach(stroke => {
                    if (!stroke.points || stroke.points.length === 0) return;
                    const screenPoints = stroke.points.map(p => ({
                        x: p.x * width,
                        y: p.y * height
                    }));

                    // First pass: Draw glow/shadow effect
                    activeStrokeCtx.strokeStyle = `rgba(255, 0, 0, ${savedLaserOpacity})`;
                    activeStrokeCtx.lineWidth = 4;
                    activeStrokeCtx.lineCap = 'round';
                    activeStrokeCtx.lineJoin = 'round';
                    activeStrokeCtx.shadowBlur = 15;
                    activeStrokeCtx.shadowColor = `rgba(255, 0, 0, ${savedLaserOpacity * 0.9})`;
                    activeStrokeCtx.shadowOffsetX = 0;
                    activeStrokeCtx.shadowOffsetY = 0;

                    activeStrokeCtx.beginPath();
                    activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                    if (screenPoints.length === 1) {
                        activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                    } else if (screenPoints.length === 2) {
                        activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                    } else {
                        for (let i = 1; i < screenPoints.length - 1; i++) {
                            const curr = screenPoints[i];
                            const next = screenPoints[i + 1];
                            const endX = (curr.x + next.x) / 2;
                            const endY = (curr.y + next.y) / 2;
                            activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                        }
                        const last = screenPoints[screenPoints.length - 1];
                        const secondLast = screenPoints[screenPoints.length - 2];
                        activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                    }

                    activeStrokeCtx.stroke();

                    // Second pass: Draw bright core line on top
                    activeStrokeCtx.strokeStyle = `rgba(255, 200, 200, ${savedLaserOpacity})`;
                    activeStrokeCtx.lineWidth = 0.8;
                    activeStrokeCtx.shadowBlur = 0;
                    activeStrokeCtx.shadowColor = 'transparent';

                    activeStrokeCtx.beginPath();
                    activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                    if (screenPoints.length === 1) {
                        activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                    } else if (screenPoints.length === 2) {
                        activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                    } else {
                        for (let i = 1; i < screenPoints.length - 1; i++) {
                            const curr = screenPoints[i];
                            const next = screenPoints[i + 1];
                            const endX = (curr.x + next.x) / 2;
                            const endY = (curr.y + next.y) / 2;
                            activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                        }
                        const last = screenPoints[screenPoints.length - 1];
                        const secondLast = screenPoints[screenPoints.length - 2];
                        activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                    }

                    activeStrokeCtx.stroke();
                });
            }

            if (!data.points || data.points.length === 0) return;

            // Convert normalized points to CSS pixel coordinates
            const screenPoints = data.points.map(p => ({
                x: p.x * width,
                y: p.y * height
            }));

            // Draw based on tool type
            if (data.tool === 'lasso') {
                // Draw lasso selection path
                console.log('Drawing lasso with', screenPoints.length, 'points');
                activeStrokeCtx.strokeStyle = '#0099FF';
                activeStrokeCtx.lineWidth = 2;
                activeStrokeCtx.setLineDash([5, 5]);
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';
                activeStrokeCtx.globalAlpha = 1; // CRITICAL: Reset opacity to full

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);
                for (let i = 1; i < screenPoints.length; i++) {
                    activeStrokeCtx.lineTo(screenPoints[i].x, screenPoints[i].y);
                }
                activeStrokeCtx.stroke();
                activeStrokeCtx.setLineDash([]);
                console.log('Lasso drawn');
            } else if (data.tool === 'laser') {
                // Draw laser stroke with glow effect
                // First pass: Draw glow/shadow effect
                activeStrokeCtx.strokeStyle = data.color || '#FF0000';
                activeStrokeCtx.lineWidth = data.width || 4;
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.shadowBlur = 15;
                activeStrokeCtx.shadowColor = `rgba(255, 0, 0, ${(data.opacity || 1) * 0.9})`;
                activeStrokeCtx.shadowOffsetX = 0;
                activeStrokeCtx.shadowOffsetY = 0;

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();

                // Second pass: Draw bright core line on top
                activeStrokeCtx.strokeStyle = `rgba(255, 200, 200, ${data.opacity || 1})`;
                activeStrokeCtx.lineWidth = 0.8;
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();
            } else {
                // Draw pen stroke
                activeStrokeCtx.strokeStyle = data.color || '#000000';
                activeStrokeCtx.lineWidth = data.width || 2;
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.globalAlpha = data.opacity || 1;
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    // Single point - draw a dot
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    // Two points - draw a line
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    // Multiple points - draw smooth curve
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();
                activeStrokeCtx.globalAlpha = 1;
            }
        }

        function clearActiveStroke() {
            // Clear saved laser strokes to prevent old strokes from reappearing
            savedLaserStrokes = [];
            savedLaserOpacity = 1.0;

            // Save current transform
            activeStrokeCtx.save();
            // Reset to identity matrix to clear entire canvas
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);
            // Restore transform
            activeStrokeCtx.restore();
        }

        function drawSelectionBox(normalizedBounds) {
            if (!pdfDoc) return;

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            // Sync active stroke canvas size to match PDF canvas
            const bufferWidth = width * dpr;
            const bufferHeight = height * dpr;

            if (activeStrokeCanvas.width !== bufferWidth || activeStrokeCanvas.height !== bufferHeight) {
                activeStrokeCanvas.width = bufferWidth;
                activeStrokeCanvas.height = bufferHeight;
                activeStrokeCanvas.style.width = width + 'px';
                activeStrokeCanvas.style.height = height + 'px';
            }

            // Clear previous drawings
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);

            // CRITICAL: Reset transform and apply DPR scaling
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.scale(dpr, dpr);

            // Convert normalized bounds to screen coordinates
            const minX = normalizedBounds.minX * width;
            const minY = normalizedBounds.minY * height;
            const maxX = normalizedBounds.maxX * width;
            const maxY = normalizedBounds.maxY * height;

            console.log('Drawing selection box at:', minX, minY, maxX, maxY);

            // Draw blue dotted rectangle (selection box)
            activeStrokeCtx.save();
            activeStrokeCtx.strokeStyle = '#0099FF';
            activeStrokeCtx.lineWidth = 2;
            activeStrokeCtx.setLineDash([5, 5]);
            activeStrokeCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);
            activeStrokeCtx.setLineDash([]);
            activeStrokeCtx.restore();
        }

        // Initialize on load
        initPresentationReceiver();

        async function loadPDF(pdfData) {
            console.log('loadPDF called with data array length:', pdfData.length);
            try {
                loading.textContent = 'Loading PDF...';
                const typedArray = new Uint8Array(pdfData);
                console.log('Created Uint8Array, size:', typedArray.byteLength);

                console.log('Calling pdfjsLib.getDocument...');
                const loadingTask = pdfjsLib.getDocument(typedArray);
                pdfDoc = await loadingTask.promise;

                console.log('PDF loaded successfully, pages:', pdfDoc.numPages);

                loading.style.display = 'none';

                // CRITICAL: Fade in overlay BEFORE showing pdfWrapper to prevent white flash
                pageTransitionOverlay.style.opacity = '1';
                pdfWrapper.style.display = 'block';

                // Wait a moment for the canvas to be properly sized in the DOM
                await new Promise(resolve => setTimeout(resolve, 100));

                console.log('Rendering page:', currentPage);
                renderPage(currentPage);
            } catch (err) {
                console.error('Error loading PDF:', err);
                loading.textContent = 'Error loading PDF: ' + err.message;
                loading.style.display = 'block';
            }
        }

        let isRendering = false;
        let pageNumIsPending = null;

        function renderPage(num) {
            if (!pdfDoc) {
                console.log('Cannot render - no PDF document');
                return;
            }

            // Queue page if already rendering
            if (isRendering) {
                console.log('Already rendering, queuing page:', num);
                pageNumIsPending = num;
                return;
            }

            isRendering = true;
            console.log('Rendering page', num);

            // Fade in white overlay to cover the page
            pageTransitionOverlay.style.opacity = '1';

            // Small delay for fade-in to complete before rendering
            setTimeout(() => {
                pdfDoc.getPage(num).then(page => {
                console.log('Got page', num);

                // Get viewport at scale 1 first
                const baseViewport = page.getViewport({ scale: 1 });
                console.log('Base viewport size:', baseViewport.width, 'x', baseViewport.height);

                // Calculate scale to fill screen width while maintaining aspect ratio
                const containerWidth = window.innerWidth;
                const containerHeight = window.innerHeight - 60; // Leave space for indicator

                // Always fit to width for presentations
                const fitScale = containerWidth / baseViewport.width;

                console.log('Container:', containerWidth, 'x', containerHeight);
                console.log('Fit scale:', fitScale);

                // Get final viewport with calculated scale
                const finalViewport = page.getViewport({ scale: fitScale });
                console.log('Final viewport:', finalViewport.width, 'x', finalViewport.height);

                // Set canvas size for high DPI displays
                const dpr = window.devicePixelRatio || 1;

                // CRITICAL: Save current context state
                ctx.save();

                // Set canvas buffer size (accounting for DPR)
                canvas.width = finalViewport.width * dpr;
                canvas.height = finalViewport.height * dpr;

                // Set display size (CSS pixels)
                canvas.style.width = finalViewport.width + 'px';
                canvas.style.height = finalViewport.height + 'px';

                console.log('Canvas size:', canvas.width, 'x', canvas.height, 'DPR:', dpr);

                // CRITICAL: Always start with a clean slate
                // Reset to identity matrix (no transforms)
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                // Clear the entire canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Apply DPR scaling for crisp rendering
                ctx.scale(dpr, dpr);

                const renderCtx = {
                    canvasContext: ctx,
                    viewport: finalViewport
                };

                console.log('Starting render...');
                page.render(renderCtx).promise.then(() => {
                    console.log('Page rendered successfully');

                    // Restore context state after rendering
                    ctx.restore();

                    syncAnnotationLayer();
                    loadPageAnnotations();
                    updatePageIndicator();

                    // Fade out white overlay to reveal the new page
                    pageTransitionOverlay.style.opacity = '0';

                    isRendering = false;

                    // Render pending page if any
                    if (pageNumIsPending !== null) {
                        const pending = pageNumIsPending;
                        pageNumIsPending = null;
                        renderPage(pending);
                    }
                }).catch(err => {
                    console.error('Render error:', err);
                    isRendering = false;

                    // Render pending page if any
                    if (pageNumIsPending !== null) {
                        const pending = pageNumIsPending;
                        pageNumIsPending = null;
                        renderPage(pending);
                    }
                });
                }).catch(err => {
                    console.error('Failed to get page:', err);
                    isRendering = false;

                    // Render pending page if any
                    if (pageNumIsPending !== null) {
                        const pending = pageNumIsPending;
                        pageNumIsPending = null;
                        renderPage(pending);
                    }
                });
            }, 300); // Delay for fade-in to complete (match main viewer timing)
        }

        function syncAnnotationLayer() {
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            annotationLayer.setAttribute('width', width);
            annotationLayer.setAttribute('height', height);
            annotationLayer.setAttribute('viewBox', `0 0 ${width} ${height}`);
        }

        function loadPageAnnotations() {
            // INCREMENTAL UPDATE: Only modify changed annotations to prevent flicker
            const pageAnnotations = annotations[currentPage] || [];
            const prevElements = annotationElements[currentPage] || [];
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            // CRITICAL: First, remove all SVG elements that belong to other pages
            // This ensures page changes don't leave old strokes visible
            const currentPageElements = new Set(prevElements.map(el => el.svgPath));
            Array.from(annotationLayer.children).forEach(child => {
                if (!currentPageElements.has(child)) {
                    child.remove();
                }
            });

            // Track which elements to keep
            const newElements = [];
            const usedPrevIndices = new Set();

            // Process each annotation in the new state
            for (let i = 0; i < pageAnnotations.length; i++) {
                const annotation = pageAnnotations[i];

                // Try to find matching annotation in previous state
                let matchIndex = -1;
                for (let j = 0; j < prevElements.length; j++) {
                    if (usedPrevIndices.has(j)) continue;

                    const prev = prevElements[j].annotation;
                    // Check if annotations match (same points, color, width)
                    if (annotationsMatch(prev, annotation)) {
                        matchIndex = j;
                        break;
                    }
                }

                if (matchIndex >= 0) {
                    // Annotation exists and unchanged - reuse existing SVG element
                    usedPrevIndices.add(matchIndex);
                    newElements.push(prevElements[matchIndex]);
                } else {
                    // New or modified annotation - create new SVG path
                    const screenPoints = annotation.points.map(p => ({
                        x: p.x * width,
                        y: p.y * height
                    }));

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('stroke', annotation.color);
                    path.setAttribute('stroke-width', annotation.width);
                    path.setAttribute('d', pointsToPath(screenPoints));

                    // Insert at correct position
                    if (i < annotationLayer.children.length) {
                        annotationLayer.insertBefore(path, annotationLayer.children[i]);
                    } else {
                        annotationLayer.appendChild(path);
                    }

                    newElements.push({ annotation, svgPath: path });
                }
            }

            // Remove unused elements (deleted annotations)
            for (let i = 0; i < prevElements.length; i++) {
                if (!usedPrevIndices.has(i)) {
                    prevElements[i].svgPath.remove();
                }
            }

            // Ensure correct order of elements
            newElements.forEach((elem, index) => {
                const currentIndex = Array.from(annotationLayer.children).indexOf(elem.svgPath);
                if (currentIndex !== index) {
                    if (index < annotationLayer.children.length) {
                        annotationLayer.insertBefore(elem.svgPath, annotationLayer.children[index]);
                    } else {
                        annotationLayer.appendChild(elem.svgPath);
                    }
                }
            });

            // Update tracking
            annotationElements[currentPage] = newElements;
        }

        // Helper function to check if two annotations are identical
        function annotationsMatch(a, b) {
            if (!a || !b) return false;
            if (a.color !== b.color) return false;
            if (a.width !== b.width) return false;
            if (a.points.length !== b.points.length) return false;

            // Check all points match
            for (let i = 0; i < a.points.length; i++) {
                if (a.points[i].x !== b.points[i].x || a.points[i].y !== b.points[i].y) {
                    return false;
                }
            }

            return true;
        }

        function pointsToPath(points) {
            // Handle single point (dot) - draw a tiny line to make it visible
            if (points.length < 2) return `M ${points[0].x} ${points[0].y} L ${points[0].x + 0.1} ${points[0].y + 0.1}`;
            if (points.length === 2) return `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y}`;

            let path = `M ${points[0].x} ${points[0].y}`;

            for (let i = 1; i < points.length - 1; i++) {
                const curr = points[i];
                const next = points[i + 1];
                const endX = (curr.x + next.x) / 2;
                const endY = (curr.y + next.y) / 2;
                path += ` Q ${curr.x} ${curr.y} ${endX} ${endY}`;
            }

            const last = points[points.length - 1];
            const secondLast = points[points.length - 2];
            path += ` Q ${secondLast.x} ${secondLast.y} ${last.x} ${last.y}`;

            return path;
        }

        function updatePageIndicator() {
            if (pdfDoc) {
                pageIndicator.textContent = `${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                renderPage(currentPage);
            }
        });
    </script>
</body>
</html>
