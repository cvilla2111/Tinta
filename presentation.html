<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Presentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #000000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .presentation-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .pdf-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        #pdfCanvas {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            background-color: white;
            display: block;
            object-fit: contain;
        }

        .annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .annotation-layer path {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #ffffff;
        }

        .page-indicator {
            display: none; /* Hidden in presentation mode */
        }

        .page-transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.2s ease;
        }
    </style>
</head>
<body>
    <div class="presentation-container">
        <div class="loading" id="loading">Waiting for presentation...</div>
        <div class="pdf-wrapper" id="pdfWrapper" style="display: none;">
            <canvas id="pdfCanvas"></canvas>
            <svg id="annotationLayer" class="annotation-layer"></svg>
            <canvas id="activeStrokeCanvas" class="annotation-layer"></canvas>
            <div id="pageTransitionOverlay" class="page-transition-overlay"></div>
            <div class="page-indicator" id="pageIndicator">1 / 1</div>
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="pdf.min.js"></script>
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';

        // Presentation state
        let pdfDoc = null;
        let currentPage = 1;
        let currentScale = 1.5;
        let annotations = {};
        let presentationConnection = null;

        const canvas = document.getElementById('pdfCanvas');
        const ctx = canvas.getContext('2d');
        const annotationLayer = document.getElementById('annotationLayer');
        const activeStrokeCanvas = document.getElementById('activeStrokeCanvas');
        const activeStrokeCtx = activeStrokeCanvas.getContext('2d');
        const pdfWrapper = document.getElementById('pdfWrapper');
        const pageTransitionOverlay = document.getElementById('pageTransitionOverlay');
        const loading = document.getElementById('loading');
        const pageIndicator = document.getElementById('pageIndicator');

        // Store laser strokes for redrawing
        let savedLaserStrokes = [];
        let savedLaserOpacity = 1.0;

        // Initialize Presentation Receiver
        async function initPresentationReceiver() {
            console.log('Initializing presentation receiver...');
            console.log('navigator.presentation:', navigator.presentation);
            console.log('navigator.presentation.receiver:', navigator.presentation?.receiver);

            if (!navigator.presentation || !navigator.presentation.receiver) {
                console.warn('Presentation Receiver API not supported');
                // Fallback: This page was opened directly, not as a presentation
                loading.textContent = 'Not opened as presentation. Use the cast button in the main app.';
                return;
            }

            try {
                console.log('Getting connection list...');
                const connectionList = await navigator.presentation.receiver.connectionList;
                console.log('Connection list received:', connectionList);
                console.log('Existing connections:', connectionList.connections.length);

                connectionList.connections.forEach(connection => {
                    console.log('Setting up existing connection');
                    setupConnection(connection);
                });

                connectionList.addEventListener('connectionavailable', (event) => {
                    console.log('New connection available');
                    setupConnection(event.connection);
                });

                console.log('Receiver initialized successfully');
            } catch (err) {
                console.error('Failed to initialize presentation receiver:', err);
                loading.textContent = 'Error: ' + err.message;
            }
        }

        function setupConnection(connection) {
            presentationConnection = connection;
            console.log('Presentation connection established, state:', connection.state);
            console.log('Connection ID:', connection.id);

            // Reset state for new connection
            pdfDoc = null;
            currentPage = 1;
            annotations = {};

            // Update loading message
            loading.style.display = 'block';
            loading.textContent = 'Connected! Waiting for PDF data...';
            pdfWrapper.style.display = 'none';

            // Listen for messages from controller
            connection.addEventListener('message', (event) => {
                console.log('Message received, length:', event.data.length);
                try {
                    const data = JSON.parse(event.data);
                    console.log('Message type:', data.type);
                    handleMessage(data);
                } catch (err) {
                    console.error('Failed to parse message:', err, 'Data:', event.data.substring(0, 100));
                }
            });

            connection.addEventListener('close', () => {
                console.log('Presentation connection closed');
                resetPresentationState();
            });

            connection.addEventListener('terminate', () => {
                console.log('Presentation terminated');
                resetPresentationState();
                // Note: Don't close window, just reset to allow reconnection
            });

            console.log('Connection setup complete');
        }

        function resetPresentationState() {
            console.log('Resetting presentation state');

            // Clear presentation data
            pdfDoc = null;
            currentPage = 1;
            annotations = {};
            presentationConnection = null;

            // Reset UI
            loading.style.display = 'block';
            loading.textContent = 'Waiting for presentation...';
            pdfWrapper.style.display = 'none';

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Clear annotations
            while (annotationLayer.firstChild) {
                annotationLayer.removeChild(annotationLayer.firstChild);
            }

            console.log('Presentation state reset, ready for reconnection');
        }

        function handleMessage(data) {
            console.log('Handling message:', data.type);
            switch (data.type) {
                case 'LOAD_PDF':
                    console.log('Loading PDF, data size:', data.pdfData.length);
                    loadPDF(data.pdfData);
                    break;
                case 'PAGE_CHANGE':
                    console.log('Changing page to:', data.pageNum);
                    currentPage = data.pageNum;
                    renderPage(currentPage);
                    break;
                case 'SCALE_CHANGE':
                    console.log('Changing scale to:', data.scale);
                    currentScale = data.scale;
                    renderPage(currentPage);
                    break;
                case 'ANNOTATIONS_UPDATE':
                    console.log('Updating annotations');
                    annotations = data.annotations;
                    // For annotation updates, only update the SVG layer without re-rendering PDF
                    // This prevents transform issues from re-rendering
                    if (pdfDoc) {
                        loadPageAnnotations();
                    }
                    break;
                case 'ACTIVE_STROKE':
                    // Real-time drawing (pen, lasso)
                    console.log('ACTIVE_STROKE received, tool:', data.tool, 'points:', data.points?.length);
                    drawActiveStroke(data);
                    break;
                case 'LASER_STROKES':
                    // Receive all laser strokes from main screen
                    console.log('LASER_STROKES received, count:', data.strokes?.length, 'opacity:', data.opacity);
                    drawLaserStrokes(data.strokes, data.opacity);
                    break;
                case 'CLEAR_ACTIVE_STROKE':
                    // Clear temporary drawing canvas
                    clearActiveStroke();
                    break;
                case 'SELECTION_BOX':
                    // Draw selection box with normalized bounds
                    console.log('Drawing selection box:', data.bounds);
                    drawSelectionBox(data.bounds);
                    break;
                case 'CLEAR_SELECTION_BOX':
                    // Clear selection box
                    console.log('Clearing selection box');
                    clearActiveStroke();
                    break;
                default:
                    console.warn('Unknown message type:', data.type);
            }
        }

        // Draw all laser strokes received from main screen
        function drawLaserStrokes(strokes, opacity) {
            // Save laser strokes for redrawing when ACTIVE_STROKE comes in
            savedLaserStrokes = strokes || [];
            savedLaserOpacity = opacity || 1.0;

            if (!pdfDoc || !strokes || strokes.length === 0) {
                // Clear if no strokes
                clearActiveStroke();
                return;
            }

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            // Sync active stroke canvas size
            const bufferWidth = width * dpr;
            const bufferHeight = height * dpr;

            if (activeStrokeCanvas.width !== bufferWidth || activeStrokeCanvas.height !== bufferHeight) {
                activeStrokeCanvas.width = bufferWidth;
                activeStrokeCanvas.height = bufferHeight;
                activeStrokeCanvas.style.width = width + 'px';
                activeStrokeCanvas.style.height = height + 'px';
            }

            // Clear canvas
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);

            // Reset transform and apply DPR scaling
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.scale(dpr, dpr);

            // Draw all laser strokes
            strokes.forEach(stroke => {
                if (!stroke.points || stroke.points.length === 0) return;
                const screenPoints = stroke.points.map(p => ({
                    x: p.x * width,
                    y: p.y * height
                }));

                // First pass: Draw glow/shadow effect
                activeStrokeCtx.strokeStyle = `rgba(255, 0, 0, ${opacity})`;
                activeStrokeCtx.lineWidth = 4;
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.shadowBlur = 15;
                activeStrokeCtx.shadowColor = `rgba(255, 0, 0, ${opacity * 0.9})`;
                activeStrokeCtx.shadowOffsetX = 0;
                activeStrokeCtx.shadowOffsetY = 0;

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();

                // Second pass: Draw bright core line on top
                activeStrokeCtx.strokeStyle = `rgba(255, 200, 200, ${opacity})`;
                activeStrokeCtx.lineWidth = 0.8;
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();
            });
        }

        function drawActiveStroke(data) {
            if (!pdfDoc) return;

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            // Sync active stroke canvas size to match PDF canvas
            const bufferWidth = width * dpr;
            const bufferHeight = height * dpr;

            if (activeStrokeCanvas.width !== bufferWidth || activeStrokeCanvas.height !== bufferHeight) {
                activeStrokeCanvas.width = bufferWidth;
                activeStrokeCanvas.height = bufferHeight;
                activeStrokeCanvas.style.width = width + 'px';
                activeStrokeCanvas.style.height = height + 'px';
            }

            // Clear previous active stroke
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);

            // CRITICAL: Reset transform and apply DPR scaling
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.scale(dpr, dpr);

            // CRITICAL FIX: If drawing laser, redraw all saved laser strokes first
            if (data.tool === 'laser' && savedLaserStrokes.length > 0) {
                savedLaserStrokes.forEach(stroke => {
                    if (!stroke.points || stroke.points.length === 0) return;
                    const screenPoints = stroke.points.map(p => ({
                        x: p.x * width,
                        y: p.y * height
                    }));

                    // First pass: Draw glow/shadow effect
                    activeStrokeCtx.strokeStyle = `rgba(255, 0, 0, ${savedLaserOpacity})`;
                    activeStrokeCtx.lineWidth = 4;
                    activeStrokeCtx.lineCap = 'round';
                    activeStrokeCtx.lineJoin = 'round';
                    activeStrokeCtx.shadowBlur = 15;
                    activeStrokeCtx.shadowColor = `rgba(255, 0, 0, ${savedLaserOpacity * 0.9})`;
                    activeStrokeCtx.shadowOffsetX = 0;
                    activeStrokeCtx.shadowOffsetY = 0;

                    activeStrokeCtx.beginPath();
                    activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                    if (screenPoints.length === 1) {
                        activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                    } else if (screenPoints.length === 2) {
                        activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                    } else {
                        for (let i = 1; i < screenPoints.length - 1; i++) {
                            const curr = screenPoints[i];
                            const next = screenPoints[i + 1];
                            const endX = (curr.x + next.x) / 2;
                            const endY = (curr.y + next.y) / 2;
                            activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                        }
                        const last = screenPoints[screenPoints.length - 1];
                        const secondLast = screenPoints[screenPoints.length - 2];
                        activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                    }

                    activeStrokeCtx.stroke();

                    // Second pass: Draw bright core line on top
                    activeStrokeCtx.strokeStyle = `rgba(255, 200, 200, ${savedLaserOpacity})`;
                    activeStrokeCtx.lineWidth = 0.8;
                    activeStrokeCtx.shadowBlur = 0;
                    activeStrokeCtx.shadowColor = 'transparent';

                    activeStrokeCtx.beginPath();
                    activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                    if (screenPoints.length === 1) {
                        activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                    } else if (screenPoints.length === 2) {
                        activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                    } else {
                        for (let i = 1; i < screenPoints.length - 1; i++) {
                            const curr = screenPoints[i];
                            const next = screenPoints[i + 1];
                            const endX = (curr.x + next.x) / 2;
                            const endY = (curr.y + next.y) / 2;
                            activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                        }
                        const last = screenPoints[screenPoints.length - 1];
                        const secondLast = screenPoints[screenPoints.length - 2];
                        activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                    }

                    activeStrokeCtx.stroke();
                });
            }

            if (!data.points || data.points.length === 0) return;

            // Convert normalized points to CSS pixel coordinates
            const screenPoints = data.points.map(p => ({
                x: p.x * width,
                y: p.y * height
            }));

            // Draw based on tool type
            if (data.tool === 'lasso') {
                // Draw lasso selection path
                console.log('Drawing lasso with', screenPoints.length, 'points');
                activeStrokeCtx.strokeStyle = '#0099FF';
                activeStrokeCtx.lineWidth = 2;
                activeStrokeCtx.setLineDash([5, 5]);
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';
                activeStrokeCtx.globalAlpha = 1; // CRITICAL: Reset opacity to full

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);
                for (let i = 1; i < screenPoints.length; i++) {
                    activeStrokeCtx.lineTo(screenPoints[i].x, screenPoints[i].y);
                }
                activeStrokeCtx.stroke();
                activeStrokeCtx.setLineDash([]);
                console.log('Lasso drawn');
            } else if (data.tool === 'laser') {
                // Draw laser stroke with glow effect
                // First pass: Draw glow/shadow effect
                activeStrokeCtx.strokeStyle = data.color || '#FF0000';
                activeStrokeCtx.lineWidth = data.width || 4;
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.shadowBlur = 15;
                activeStrokeCtx.shadowColor = `rgba(255, 0, 0, ${(data.opacity || 1) * 0.9})`;
                activeStrokeCtx.shadowOffsetX = 0;
                activeStrokeCtx.shadowOffsetY = 0;

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();

                // Second pass: Draw bright core line on top
                activeStrokeCtx.strokeStyle = `rgba(255, 200, 200, ${data.opacity || 1})`;
                activeStrokeCtx.lineWidth = 0.8;
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();
            } else {
                // Draw pen stroke
                activeStrokeCtx.strokeStyle = data.color || '#000000';
                activeStrokeCtx.lineWidth = data.width || 2;
                activeStrokeCtx.lineCap = 'round';
                activeStrokeCtx.lineJoin = 'round';
                activeStrokeCtx.globalAlpha = data.opacity || 1;
                activeStrokeCtx.shadowBlur = 0;
                activeStrokeCtx.shadowColor = 'transparent';

                activeStrokeCtx.beginPath();
                activeStrokeCtx.moveTo(screenPoints[0].x, screenPoints[0].y);

                if (screenPoints.length === 1) {
                    // Single point - draw a dot
                    activeStrokeCtx.lineTo(screenPoints[0].x + 0.1, screenPoints[0].y + 0.1);
                } else if (screenPoints.length === 2) {
                    // Two points - draw a line
                    activeStrokeCtx.lineTo(screenPoints[1].x, screenPoints[1].y);
                } else {
                    // Multiple points - draw smooth curve
                    for (let i = 1; i < screenPoints.length - 1; i++) {
                        const curr = screenPoints[i];
                        const next = screenPoints[i + 1];
                        const endX = (curr.x + next.x) / 2;
                        const endY = (curr.y + next.y) / 2;
                        activeStrokeCtx.quadraticCurveTo(curr.x, curr.y, endX, endY);
                    }
                    const last = screenPoints[screenPoints.length - 1];
                    const secondLast = screenPoints[screenPoints.length - 2];
                    activeStrokeCtx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
                }

                activeStrokeCtx.stroke();
                activeStrokeCtx.globalAlpha = 1;
            }
        }

        function clearActiveStroke() {
            // Clear saved laser strokes to prevent old strokes from reappearing
            savedLaserStrokes = [];
            savedLaserOpacity = 1.0;

            // Save current transform
            activeStrokeCtx.save();
            // Reset to identity matrix to clear entire canvas
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);
            // Restore transform
            activeStrokeCtx.restore();
        }

        function drawSelectionBox(normalizedBounds) {
            if (!pdfDoc) return;

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            // Sync active stroke canvas size to match PDF canvas
            const bufferWidth = width * dpr;
            const bufferHeight = height * dpr;

            if (activeStrokeCanvas.width !== bufferWidth || activeStrokeCanvas.height !== bufferHeight) {
                activeStrokeCanvas.width = bufferWidth;
                activeStrokeCanvas.height = bufferHeight;
                activeStrokeCanvas.style.width = width + 'px';
                activeStrokeCanvas.style.height = height + 'px';
            }

            // Clear previous drawings
            activeStrokeCtx.clearRect(0, 0, activeStrokeCanvas.width, activeStrokeCanvas.height);

            // CRITICAL: Reset transform and apply DPR scaling
            activeStrokeCtx.setTransform(1, 0, 0, 1, 0, 0);
            activeStrokeCtx.scale(dpr, dpr);

            // Convert normalized bounds to screen coordinates
            const minX = normalizedBounds.minX * width;
            const minY = normalizedBounds.minY * height;
            const maxX = normalizedBounds.maxX * width;
            const maxY = normalizedBounds.maxY * height;

            console.log('Drawing selection box at:', minX, minY, maxX, maxY);

            // Draw blue dotted rectangle (selection box)
            activeStrokeCtx.save();
            activeStrokeCtx.strokeStyle = '#0099FF';
            activeStrokeCtx.lineWidth = 2;
            activeStrokeCtx.setLineDash([5, 5]);
            activeStrokeCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);
            activeStrokeCtx.setLineDash([]);
            activeStrokeCtx.restore();
        }

        // Initialize on load
        initPresentationReceiver();

        async function loadPDF(pdfData) {
            console.log('loadPDF called with data array length:', pdfData.length);
            try {
                loading.textContent = 'Loading PDF...';
                const typedArray = new Uint8Array(pdfData);
                console.log('Created Uint8Array, size:', typedArray.byteLength);

                console.log('Calling pdfjsLib.getDocument...');
                const loadingTask = pdfjsLib.getDocument(typedArray);
                pdfDoc = await loadingTask.promise;

                console.log('PDF loaded successfully, pages:', pdfDoc.numPages);

                loading.style.display = 'none';
                pdfWrapper.style.display = 'block';

                // Wait a moment for the canvas to be properly sized in the DOM
                await new Promise(resolve => setTimeout(resolve, 100));

                console.log('Rendering page:', currentPage);
                renderPage(currentPage);
            } catch (err) {
                console.error('Error loading PDF:', err);
                loading.textContent = 'Error loading PDF: ' + err.message;
                loading.style.display = 'block';
            }
        }

        let isRendering = false;
        let pageNumIsPending = null;

        function renderPage(num) {
            if (!pdfDoc) {
                console.log('Cannot render - no PDF document');
                return;
            }

            // Queue page if already rendering
            if (isRendering) {
                console.log('Already rendering, queuing page:', num);
                pageNumIsPending = num;
                return;
            }

            isRendering = true;
            console.log('Rendering page', num);

            // Fade in white overlay to cover the page
            pageTransitionOverlay.style.opacity = '1';

            // Small delay for fade-in to complete before rendering
            setTimeout(() => {
                pdfDoc.getPage(num).then(page => {
                console.log('Got page', num);

                // Get viewport at scale 1 first
                const baseViewport = page.getViewport({ scale: 1 });
                console.log('Base viewport size:', baseViewport.width, 'x', baseViewport.height);

                // Calculate scale to fill screen width while maintaining aspect ratio
                const containerWidth = window.innerWidth;
                const containerHeight = window.innerHeight - 60; // Leave space for indicator

                // Always fit to width for presentations
                const fitScale = containerWidth / baseViewport.width;

                console.log('Container:', containerWidth, 'x', containerHeight);
                console.log('Fit scale:', fitScale);

                // Get final viewport with calculated scale
                const finalViewport = page.getViewport({ scale: fitScale });
                console.log('Final viewport:', finalViewport.width, 'x', finalViewport.height);

                // Set canvas size for high DPI displays
                const dpr = window.devicePixelRatio || 1;

                // CRITICAL: Save current context state
                ctx.save();

                // Set canvas buffer size (accounting for DPR)
                canvas.width = finalViewport.width * dpr;
                canvas.height = finalViewport.height * dpr;

                // Set display size (CSS pixels)
                canvas.style.width = finalViewport.width + 'px';
                canvas.style.height = finalViewport.height + 'px';

                console.log('Canvas size:', canvas.width, 'x', canvas.height, 'DPR:', dpr);

                // CRITICAL: Always start with a clean slate
                // Reset to identity matrix (no transforms)
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                // Clear the entire canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Apply DPR scaling for crisp rendering
                ctx.scale(dpr, dpr);

                const renderCtx = {
                    canvasContext: ctx,
                    viewport: finalViewport
                };

                console.log('Starting render...');
                page.render(renderCtx).promise.then(() => {
                    console.log('Page rendered successfully');

                    // Restore context state after rendering
                    ctx.restore();

                    syncAnnotationLayer();
                    loadPageAnnotations();
                    updatePageIndicator();

                    // Fade out white overlay to reveal the new page
                    pageTransitionOverlay.style.opacity = '0';

                    isRendering = false;

                    // Render pending page if any
                    if (pageNumIsPending !== null) {
                        const pending = pageNumIsPending;
                        pageNumIsPending = null;
                        renderPage(pending);
                    }
                }).catch(err => {
                    console.error('Render error:', err);
                    isRendering = false;

                    // Render pending page if any
                    if (pageNumIsPending !== null) {
                        const pending = pageNumIsPending;
                        pageNumIsPending = null;
                        renderPage(pending);
                    }
                });
                }).catch(err => {
                    console.error('Failed to get page:', err);
                    isRendering = false;

                    // Render pending page if any
                    if (pageNumIsPending !== null) {
                        const pending = pageNumIsPending;
                        pageNumIsPending = null;
                        renderPage(pending);
                    }
                });
            }, 200); // Delay for fade-in to complete
        }

        function syncAnnotationLayer() {
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            annotationLayer.setAttribute('width', width);
            annotationLayer.setAttribute('height', height);
            annotationLayer.setAttribute('viewBox', `0 0 ${width} ${height}`);
        }

        function loadPageAnnotations() {
            // Clear current annotations
            while (annotationLayer.firstChild) {
                annotationLayer.removeChild(annotationLayer.firstChild);
            }

            const pageAnnotations = annotations[currentPage];
            if (pageAnnotations && pageAnnotations.length > 0) {
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;

                pageAnnotations.forEach(annotation => {
                    const screenPoints = annotation.points.map(p => ({
                        x: p.x * width,
                        y: p.y * height
                    }));

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('stroke', annotation.color);
                    path.setAttribute('stroke-width', annotation.width);
                    path.setAttribute('d', pointsToPath(screenPoints));
                    annotationLayer.appendChild(path);
                });
            }
        }

        function pointsToPath(points) {
            if (points.length < 2) return `M ${points[0].x} ${points[0].y}`;
            if (points.length === 2) return `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y}`;

            let path = `M ${points[0].x} ${points[0].y}`;

            for (let i = 1; i < points.length - 1; i++) {
                const curr = points[i];
                const next = points[i + 1];
                const endX = (curr.x + next.x) / 2;
                const endY = (curr.y + next.y) / 2;
                path += ` Q ${curr.x} ${curr.y} ${endX} ${endY}`;
            }

            const last = points[points.length - 1];
            const secondLast = points[points.length - 2];
            path += ` Q ${secondLast.x} ${secondLast.y} ${last.x} ${last.y}`;

            return path;
        }

        function updatePageIndicator() {
            if (pdfDoc) {
                pageIndicator.textContent = `${currentPage} / ${pdfDoc.numPages}`;
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                renderPage(currentPage);
            }
        });
    </script>
</body>
</html>
