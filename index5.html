<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChordPro Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
    <style>
        /* Set explicit base font size for output */
        #output {
            font-size: 16px;
        }
        .chord-line {
            position: relative;
            line-height: 2.5em;
            margin-bottom: 0.1em;
            display: block;
            text-align: center;
            font-size: 1em;
        }
        .line-edit-modal {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            min-height: 80px;
            opacity: 1;
            transform: translateY(0);
        }
        .line-edit-modal.hide {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
        }
        /* Keyframe animation for margin push */
        @keyframes pushDown {
            from {
                margin-top: 0px;
            }
            to {
                margin-top: 90px;
            }
        }
        @keyframes pushUp {
            from {
                margin-top: 90px;
            }
            to {
                margin-top: 0px;
            }
        }
        /* Add top margin to line when editing to push content up */
        .editable-line.editing {
            animation: pushDown 0.4s ease-in-out forwards;
        }
        .editable-line.closing {
            animation: pushUp 0.4s ease-in-out forwards;
        }
        /* Only show hover and cursor pointer when in edit mode */
        body.in-edit-mode .editable-line {
            cursor: pointer;
        }
        body.in-edit-mode .editable-line:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        body.dark.in-edit-mode .editable-line:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .chord-line-content {
            display: inline-block;
            position: relative;
            text-align: left;
        }
        .chord {
            position: absolute;
            font-weight: bold;
            color: #5D5CDE;
            font-size: 0.85em;
            top: -1.2em;
            white-space: nowrap;
        }
        .dark .chord {
            color: #8B7CF6;
        }
        .lyrics {
            font-family: monospace;
            font-size: 1em;
        }
        /* Make title smaller and add top spacing */
        #output .song-title {
            font-size: 1.125em; /* 18px */
        }
        /* Make artist name smaller */
        #output .song-artist {
            font-size: 0.875em; /* 14px */
        }
        /* Make song details (key, capo, tempo) smaller */
        #output .song-details {
            font-size: 0.6875em; /* 11px */
        }
        /* Hide scrollbar but keep scrolling functionality */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        html {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        html::-webkit-scrollbar {
            display: none;
        }
        body {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        body::-webkit-scrollbar {
            display: none;
        }
        @media print {
            .no-print { display: none !important; }
            body { background: white !important; }
        }
        /* Blinking animation for edit mode */
        @keyframes blink-red {
            0%, 100% {
                background-color: rgb(239 68 68);
                color: white;
            }
            50% {
                background-color: transparent;
                color: inherit;
            }
        }
        .edit-mode-active {
            animation: blink-red 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors">
    <!-- Hamburger Menu Button -->
    <div class="no-print fixed top-4 left-4 z-50">
        <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-1 shadow-lg border border-gray-200 dark:border-gray-700">
            <button id="menuToggle" class="flex items-center px-2 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
        </div>
    </div>

    <!-- Floating Text Size Controls -->
    <div class="no-print fixed top-4 right-4 z-50 flex flex-col gap-2 items-end">
        <!-- Text Scaling with Edit Button -->
        <div class="flex items-center gap-1 bg-gray-50 dark:bg-gray-800 rounded-lg p-1 shadow-lg border border-gray-200 dark:border-gray-700">
            <button id="decreaseText" class="flex items-center px-2 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm">
                <span class="font-bold">T</span><span class="ml-1">-</span>
            </button>
            <button id="editButton" class="px-3 py-1 text-sm bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors">
                Edit
            </button>
            <button id="increaseText" class="flex items-center px-2 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm">
                <span class="font-bold">T</span><span class="ml-1">+</span>
            </button>
        </div>

        <!-- Auto-scroll Controls -->
        <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-1 shadow-lg border border-gray-200 dark:border-gray-700">
            <div class="flex flex-col items-stretch gap-1">
                <button id="increaseSpeed" class="px-2 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm font-bold">
                    +
                </button>
                <button id="playButton" class="px-2 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm">
                    <span style="font-family: Arial, sans-serif;">▶</span>
                </button>
                <button id="decreaseSpeed" class="px-2 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm font-bold">
                    -
                </button>
            </div>
        </div>
    </div>

    <!-- Slide-out Menu -->
    <div id="sideMenu" class="no-print fixed top-0 left-0 h-full w-[90vw] bg-white dark:bg-gray-900 shadow-2xl transform -translate-x-full transition-transform duration-300 ease-in-out z-40 overflow-y-auto">
        <div class="p-6">
            <!-- Header -->
            <div class="mb-8">
                <div class="flex items-center justify-between mb-4">
                    <h1 class="text-2xl font-bold">ChordPro Viewer</h1>
                    <button id="closeMenu" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>



            <!-- Input Section -->
            <div class="mb-8">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold">ChordPro Input</h2>
                    <div class="flex gap-2">
                        <button id="loadSample" class="px-3 py-1 text-sm bg-primary text-white rounded hover:bg-primary/90 transition-colors">
                            Load Sample
                        </button>
                        <button id="clearInput" class="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
                            Clear
                        </button>
                    </div>
                </div>
                <textarea
                    id="chordproInput"
                    class="w-full h-[calc(100vh-280px)] p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base font-mono resize-none focus:ring-2 focus:ring-primary focus:border-transparent"
                    placeholder="Paste your ChordPro content here...

Example:
{title: Amazing Grace}
{artist: Traditional}
{key: G}

{start_of_verse}
A[G]mazing [G7]grace how [C]sweet the [G]sound
That [G]saved a [Em]wretch like [D]me
{end_of_verse}"
                ></textarea>
            </div>

            <!-- Help Icon -->
            <button id="helpButton" class="fixed bottom-4 right-4 bg-primary text-white rounded-full p-3 shadow-lg hover:bg-primary/90 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
            </button>

            <!-- Hidden Help Modal -->
            <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 opacity-0 pointer-events-none transition-opacity duration-300">
                <div class="flex items-center justify-center min-h-full p-4">
                    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
                        <div class="p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-xl font-semibold">ChordPro Format Guide</h3>
                                <button id="closeHelp" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                    </svg>
                                </button>
                            </div>
                            <div class="space-y-4 text-sm">
                                <div>
                                    <h4 class="font-medium mb-2">Basic Syntax:</h4>
                                    <ul class="space-y-1 text-gray-600 dark:text-gray-400">
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">[Am]word</code> - Chord above word</li>
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{title: Song Name}</code> - Song title</li>
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{artist: Artist}</code> - Artist name</li>
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{key: C}</code> - Song key</li>
                                    </ul>
                                </div>
                                <div>
                                    <h4 class="font-medium mb-2">Sections:</h4>
                                    <ul class="space-y-1 text-gray-600 dark:text-gray-400">
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{start_of_verse}</code> - Begin verse</li>
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{start_of_chorus}</code> - Begin chorus</li>
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{comment: Note}</code> - Add comment</li>
                                        <li><code class="bg-gray-200 dark:bg-gray-700 px-1 rounded">{capo: 3}</code> - Capo position</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Overlay -->
    <div id="menuOverlay" class="no-print fixed inset-0 bg-black bg-opacity-50 z-30 opacity-0 pointer-events-none transition-opacity duration-300"></div>

    <!-- Main Content Area - Full Screen -->
    <div class="min-h-screen bg-white dark:bg-gray-900 p-0 sm:p-6">
        <div id="output" class="max-w-none">
            <div class="text-gray-500 dark:text-gray-400 text-center py-20">
                Click the menu button (☰) in the top-left to enter ChordPro content
            </div>
        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        const input = document.getElementById('chordproInput');
        const output = document.getElementById('output');
        const loadSampleBtn = document.getElementById('loadSample');
        const clearInputBtn = document.getElementById('clearInput');

        // Text size management
        let currentFontSize = 100; // Percentage
        const minFontSize = 50;
        const maxFontSize = 200;
        const fontSizeStep = 10;

        // Edit mode management
        let isEditMode = false;
        let currentChordProContent = '';
        let isProcessingInput = false; // Flag to prevent recursive input processing

        // Auto-scroll management
        let isScrolling = false;
        let scrollSpeed = 0.1; // Speed multiplier (0.1 × 2 = 0.2 px/30ms)
        let scrollInterval = null;
        let scrollAccumulator = 0; // Accumulates fractional pixels
        const baseScrollSpeed = 2; // Base pixels per interval
        const scrollIntervalTime = 30; // Milliseconds between scroll steps

        // Sample ChordPro content
        const sampleContent = `{title: Amazing Grace}
{artist: Traditional}
{key: G}
{capo: 0}

{start_of_verse}
A[G]mazing [G7]grace how [C]sweet the [G]sound
That [G]saved a [Em]wretch like [D]me
I [G]once was [G7]lost but [C]now I'm [G]found
Was [G]blind but [D]now I [G]see
{end_of_verse}

{start_of_verse}
'Twas [G]grace that [G7]taught my [C]heart to [G]fear
And [G]grace my [Em]fears re[D]lieved
How [G]precious [G7]did that [C]grace ap[G]pear
The [G]hour I [D]first be[G]lieved
{end_of_verse}

{start_of_chorus}
A[G]mazing [C]grace how [G]sweet the sound
That [Em]saved a [D]wretch like [G]me
{end_of_chorus}

{start_of_verse}
Through [G]many [G7]dangers, [C]toils and [G]snares
I [G]have al[Em]ready [D]come
'Tis [G]grace hath [G7]brought me [C]safe thus [G]far
And [G]grace will [D]lead me [G]home
{end_of_verse}

{start_of_verse}
The [G]Lord has [G7]promised [C]good to [G]me
His [G]word my [Em]hope se[D]cures
He [G]will my [G7]shield and [C]portion [G]be
As [G]long as [D]life en[G]dures
{end_of_verse}

{start_of_chorus}
A[G]mazing [C]grace how [G]sweet the sound
That [Em]saved a [D]wretch like [G]me
{end_of_chorus}

{start_of_verse}
When [G]we've been [G7]there ten [C]thousand [G]years
Bright [G]shining [Em]as the [D]sun
We've [G]no less [G7]days to [C]sing God's [G]praise
Than [G]when we'd [D]first be[G]gun
{end_of_verse}

{start_of_verse}
Yes, [G]when this [G7]flesh and [C]heart shall [G]fail
And [G]mortal [Em]life shall [D]cease
I [G]shall pos[G7]sess with[C]in the [G]veil
A [G]life of [D]joy and [G]peace
{end_of_verse}

{start_of_chorus}
A[G]mazing [C]grace how [G]sweet the sound
That [Em]saved a [D]wretch like [G]me
{end_of_chorus}

{comment: Play slowly and with feeling}
{comment: Traditional hymn - Public Domain}`;

        // Parse ChordPro content
        function parseChordPro(content) {
            const lines = content.split('\n');
            const result = {
                metadata: {},
                sections: [],
                currentSection: null
            };

            for (let line of lines) {
                line = line.trim();
                if (!line) continue;

                // Parse directives
                if (line.startsWith('{') && line.endsWith('}')) {
                    const directive = line.slice(1, -1);
                    const colonIndex = directive.indexOf(':');

                    if (colonIndex > -1) {
                        const key = directive.substring(0, colonIndex).trim();
                        const value = directive.substring(colonIndex + 1).trim();

                        // Handle metadata
                        if (['title', 't', 'artist', 'key', 'capo', 'tempo'].includes(key)) {
                            result.metadata[key] = value;
                        }
                        // Handle section starts
                        else if (key.startsWith('start_of_') || ['sov', 'soc', 'sob'].includes(key)) {
                            const sectionType = key.replace('start_of_', '').replace('sov', 'verse').replace('soc', 'chorus').replace('sob', 'bridge');
                            result.currentSection = {
                                type: sectionType,
                                lines: []
                            };
                        }
                        // Handle comments
                        else if (key === 'comment' || key === 'c') {
                            if (result.currentSection) {
                                result.currentSection.lines.push({ type: 'comment', content: value });
                            } else {
                                result.sections.push({ type: 'comment', content: value });
                            }
                        }
                    }
                    // Handle section ends
                    else if (directive.startsWith('end_of_') || ['eov', 'eoc', 'eob'].includes(directive)) {
                        if (result.currentSection) {
                            result.sections.push(result.currentSection);
                            result.currentSection = null;
                        }
                    }
                }
                // Parse chord/lyric lines
                else {
                    const parsedLine = parseChordLine(line);
                    if (result.currentSection) {
                        result.currentSection.lines.push(parsedLine);
                    } else {
                        result.sections.push(parsedLine);
                    }
                }
            }

            // Add any remaining section
            if (result.currentSection) {
                result.sections.push(result.currentSection);
            }

            return result;
        }

        // Parse a line with chords and lyrics
        function parseChordLine(line) {
            const chords = [];
            const lyrics = [];
            let position = 0;
            let lyricPosition = 0;

            while (position < line.length) {
                const chordStart = line.indexOf('[', position);
                if (chordStart === -1) {
                    // No more chords, add remaining lyrics
                    lyrics.push(line.substring(position));
                    break;
                }

                // Add lyrics before chord
                if (chordStart > position) {
                    const lyricText = line.substring(position, chordStart);
                    lyrics.push(lyricText);
                    lyricPosition += lyricText.length;
                }

                // Find chord end
                const chordEnd = line.indexOf(']', chordStart);
                if (chordEnd === -1) {
                    // Malformed chord, treat as lyrics
                    lyrics.push(line.substring(chordStart));
                    break;
                }

                // Extract chord
                const chord = line.substring(chordStart + 1, chordEnd);
                chords.push({
                    chord: chord,
                    position: lyricPosition
                });

                position = chordEnd + 1;
            }

            return {
                type: 'chordline',
                chords: chords,
                lyrics: lyrics.join('')
            };
        }

        // Render parsed ChordPro to HTML
        function renderChordPro(parsed) {
            let html = '';
            let lineIndex = 0;

            // Render metadata (perfectly centered)
            if (Object.keys(parsed.metadata).length > 0) {
                html += '<div class="mt-16 mb-6 text-center border-b border-gray-300 dark:border-gray-600 pb-4">';

                if (parsed.metadata.title || parsed.metadata.t) {
                    const titleValue = parsed.metadata.title || parsed.metadata.t;
                    html += `<h1 class="song-title font-bold mb-2 editable-line rounded p-2 transition-colors" data-chordpro="{title: ${titleValue}}" data-metadata="title">${titleValue}</h1>`;
                }
                if (parsed.metadata.artist) {
                    html += `<p class="song-artist text-gray-600 dark:text-gray-400 mb-2 editable-line rounded p-2 transition-colors" data-chordpro="{artist: ${parsed.metadata.artist}}" data-metadata="artist">${parsed.metadata.artist}</p>`;
                }

                const details = [];
                if (parsed.metadata.key) {
                    html += `<p class="song-details text-gray-500 dark:text-gray-500 editable-line rounded p-2 transition-colors inline-block" data-chordpro="{key: ${parsed.metadata.key}}" data-metadata="key">Key: ${parsed.metadata.key}</p>`;
                }
                if (parsed.metadata.capo && parsed.metadata.capo !== '0') {
                    if (details.length > 0) html += '<span class="song-details text-gray-500 dark:text-gray-500"> • </span>';
                    html += `<p class="song-details text-gray-500 dark:text-gray-500 inline-block">Capo: ${parsed.metadata.capo}</p>`;
                }
                if (parsed.metadata.tempo) {
                    if (details.length > 0 || parsed.metadata.capo) html += '<span class="song-details text-gray-500 dark:text-gray-500"> • </span>';
                    html += `<p class="song-details text-gray-500 dark:text-gray-500 inline-block">Tempo: ${parsed.metadata.tempo}</p>`;
                }

                html += '</div>';
            }

            // Render sections
            for (const section of parsed.sections) {
                if (section.type === 'chordline') {
                    html += renderLine(section, lineIndex++);
                } else if (section.type === 'comment') {
                    html += `<div class="text-sm text-gray-500 dark:text-gray-400 italic mb-2 bg-gray-100 dark:bg-gray-800 p-2 rounded">${section.content}</div>`;
                } else if (section.lines && Array.isArray(section.lines)) {
                    // Section with multiple lines
                    const sectionClass = getSectionClass(section.type);
                    html += `<div class="mb-6 ${sectionClass}">`;
                    html += `<div class="text-sm font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider mb-2">${section.type}</div>`;
                    html += '<div class="pl-4 border-l-2 border-gray-300 dark:border-gray-600">';

                    for (const line of section.lines) {
                        if (line.type === 'comment') {
                            html += `<div class="text-sm text-gray-500 dark:text-gray-400 italic mb-2">${line.content}</div>`;
                        } else {
                            html += renderLine(line, lineIndex++);
                        }
                    }

                    html += '</div></div>';
                }
            }

            return html || '<div class="text-gray-500 dark:text-gray-400 text-center py-8">No content to display</div>';
        }

        // Render a single chord/lyric line
        function renderLine(line, lineIndex) {
            if (!line.lyrics && line.chords.length === 0) return '';

            // Reconstruct the ChordPro format for this line
            let chordProLine = '';
            let lastPos = 0;

            // Sort chords by position
            const sortedChords = [...line.chords].sort((a, b) => a.position - b.position);

            for (const chordInfo of sortedChords) {
                chordProLine += line.lyrics.substring(lastPos, chordInfo.position);
                chordProLine += `[${chordInfo.chord}]`;
                lastPos = chordInfo.position;
            }
            chordProLine += line.lyrics.substring(lastPos);

            let html = `<div class="chord-line lyrics mb-1 editable-line rounded p-2 transition-colors" data-chordpro="${chordProLine.replace(/"/g, '&quot;')}" data-line-index="${lineIndex}">`;
            html += '<div class="chord-line-content">';

            if (line.chords.length > 0) {
                // Create chord positions
                for (const chordInfo of line.chords) {
                    const leftPosition = chordInfo.position * 0.6; // Approximate character width
                    html += `<span class="chord" style="left: ${leftPosition}em">${chordInfo.chord}</span>`;
                }
            }

            html += `<span>${line.lyrics || ''}</span>`;
            html += '</div>';
            html += '</div>';

            return html;
        }

        // Get CSS class for section type
        function getSectionClass(type) {
            switch (type) {
                case 'chorus': return 'bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4';
                case 'verse': return 'bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4';
                case 'bridge': return 'bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4';
                default: return 'bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4';
            }
        }

        // Update output when input changes
        function updateOutput(skipAutoScale = false) {
            const content = input.value.trim();
            currentChordProContent = content;

            if (!content) {
                output.innerHTML = '<div class="text-gray-500 dark:text-gray-400 text-center py-8">Enter ChordPro content to see formatted output here</div>';
                return;
            }

            try {
                const parsed = parseChordPro(content);
                const rendered = renderChordPro(parsed);
                output.innerHTML = rendered;

                // Auto-scale to viewport (skip if just closing edit)
                if (!skipAutoScale) {
                    autoScaleToViewport();
                }
            } catch (error) {
                output.innerHTML = `<div class="text-red-500 text-center py-8">Error parsing ChordPro content: ${error.message}</div>`;
            }
        }

        // Auto-scale content to fit viewport
        function autoScaleToViewport() {
            // Start at a very small size to ensure no wrapping
            currentFontSize = 30;
            output.style.fontSize = '30%';

            // Wait for DOM to render before measuring
            setTimeout(() => {
                // Get viewport width - use almost all on mobile, less on desktop
                const viewportWidth = window.innerWidth;
                const isMobile = viewportWidth <= 768;
                // On mobile use essentially full width, on desktop leave margins
                const targetWidth = isMobile ? viewportWidth - 8 : viewportWidth * 0.90;

                // Find the widest actual content line
                let maxContentWidth = 0;

                // Measure all chord line containers (which center the content)
                const chordLines = output.querySelectorAll('.chord-line');

                // Temporarily prevent wrapping during measurement
                chordLines.forEach(line => {
                    const content = line.querySelector('.chord-line-content');
                    if (content) {
                        // Force no wrapping on the entire content to get true width
                        const originalWhiteSpace = content.style.whiteSpace;
                        content.style.whiteSpace = 'nowrap';

                        // Get the actual rendered width of the content
                        const lineWidth = content.getBoundingClientRect().width;
                        if (lineWidth > maxContentWidth) {
                            maxContentWidth = lineWidth;
                        }

                        // Restore original style
                        content.style.whiteSpace = originalWhiteSpace;
                    }
                });

                // Scale based on the widest content
                if (maxContentWidth > 0) {
                    // Calculate what percentage would make the content fit the target width
                    const scaleRatio = targetWidth / maxContentWidth;
                    currentFontSize = Math.floor(30 * scaleRatio);

                    // On mobile, be more aggressive - add 12% buffer to account for measurement inaccuracies
                    // On desktop, use smaller 5% buffer
                    const bufferMultiplier = isMobile ? 1.12 : 1.05;
                    currentFontSize = Math.floor(currentFontSize * bufferMultiplier);

                    // Cap at reasonable maximum and minimum
                    if (currentFontSize > 200) {
                        currentFontSize = 200;
                    } else if (currentFontSize < 60) {
                        currentFontSize = 60;
                    }
                } else {
                    // No content found, use default
                    currentFontSize = 100;
                }

                updateFontSize();
            }, 100);
        }

        // Event listeners
        input.addEventListener('input', () => {
            // Prevent recursive processing
            if (isProcessingInput) {
                return;
            }

            isProcessingInput = true;

            // Add blank metadata if missing
            addBlankMetadataIfMissing();
            updateOutput();

            isProcessingInput = false;
        });

        // Add blank title, artist, and key if they don't exist
        function addBlankMetadataIfMissing() {
            let content = input.value;

            // Check if metadata exists
            const hasTitle = /\{title:/i.test(content) || /\{t:/i.test(content);
            const hasArtist = /\{artist:/i.test(content);
            const hasKey = /\{key:/i.test(content);

            // If any metadata is missing and there's content, add placeholders at the top
            if (content.trim() && (!hasTitle || !hasArtist || !hasKey)) {
                const metadataLines = [];

                if (!hasTitle) {
                    metadataLines.push('{title: Title goes here}');
                }
                if (!hasArtist) {
                    metadataLines.push('{artist: Artist goes here}');
                }
                if (!hasKey) {
                    metadataLines.push('{key: Key goes here}');
                }

                // Add metadata with placeholders at the beginning
                input.value = metadataLines.join('\n') + '\n\n' + content;
            }
        }

        loadSampleBtn.addEventListener('click', () => {
            input.value = sampleContent;
            updateOutput();
        });

        clearInputBtn.addEventListener('click', () => {
            input.value = '';
            updateOutput();
        });

        // Text size functions
        function updateFontSize() {
            output.style.fontSize = `${currentFontSize}%`;

            // Update button states
            const decreaseTextBtn = document.getElementById('decreaseText');
            const increaseTextBtn = document.getElementById('increaseText');

            if (decreaseTextBtn) {
                decreaseTextBtn.disabled = currentFontSize <= minFontSize;
                if (decreaseTextBtn.disabled) {
                    decreaseTextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    decreaseTextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }

            if (increaseTextBtn) {
                increaseTextBtn.disabled = currentFontSize >= maxFontSize;
                if (increaseTextBtn.disabled) {
                    increaseTextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    increaseTextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        // Use event delegation for text size buttons (now on document for floating buttons)
        document.addEventListener('click', (e) => {
            if (e.target.id === 'decreaseText' || e.target.closest('#decreaseText')) {
                if (currentFontSize > minFontSize) {
                    currentFontSize -= fontSizeStep;
                    updateFontSize();
                }
            } else if (e.target.id === 'increaseText' || e.target.closest('#increaseText')) {
                if (currentFontSize < maxFontSize) {
                    currentFontSize += fontSizeStep;
                    updateFontSize();
                }
            }
        });

        // Menu functionality
        const menuToggle = document.getElementById('menuToggle');
        const editButton = document.getElementById('editButton');
        const closeMenu = document.getElementById('closeMenu');
        const sideMenu = document.getElementById('sideMenu');
        const menuOverlay = document.getElementById('menuOverlay');

        function openMenu() {
            sideMenu.classList.remove('-translate-x-full');
            menuOverlay.classList.remove('opacity-0', 'pointer-events-none');
            menuOverlay.classList.add('opacity-100');
            document.body.style.overflow = 'hidden';
            // Hide hamburger button and right controls (text scaling + edit button) when menu opens
            document.querySelector('#menuToggle').parentElement.classList.add('opacity-0', 'pointer-events-none');
            document.querySelectorAll('.no-print.fixed.top-4.right-4')[0].classList.add('opacity-0', 'pointer-events-none');
        }

        function closeMenuFunc() {
            sideMenu.classList.add('-translate-x-full');
            menuOverlay.classList.add('opacity-0', 'pointer-events-none');
            menuOverlay.classList.remove('opacity-100');
            document.body.style.overflow = '';
            // Show hamburger button and right controls only after menu animation completes (300ms)
            setTimeout(() => {
                document.querySelector('#menuToggle').parentElement.classList.remove('opacity-0', 'pointer-events-none');
                document.querySelectorAll('.no-print.fixed.top-4.right-4')[0].classList.remove('opacity-0', 'pointer-events-none');
            }, 300);
        }

        // Edit mode toggle
        function toggleEditMode() {
            const editBtn = document.getElementById('editButton');

            if (!isEditMode) {
                // Enter edit mode
                isEditMode = true;
                editBtn.textContent = 'Done';
                editBtn.classList.add('edit-mode-active');
                document.body.classList.add('in-edit-mode');
            } else {
                // Exit edit mode
                isEditMode = false;
                editBtn.textContent = 'Edit';
                editBtn.classList.remove('edit-mode-active');
                document.body.classList.remove('in-edit-mode');
            }
        }

        menuToggle.addEventListener('click', openMenu);
        editButton.addEventListener('click', toggleEditMode);
        closeMenu.addEventListener('click', closeMenuFunc);
        menuOverlay.addEventListener('click', closeMenuFunc);

        // Auto-scroll functions
        function startScroll() {
            if (!isScrolling) {
                isScrolling = true;
                scrollAccumulator = 0; // Reset accumulator
                document.getElementById('playButton').innerHTML = '<span style="font-family: Arial, sans-serif;">⏸</span>';
                scrollInterval = setInterval(() => {
                    // Accumulate fractional pixels
                    scrollAccumulator += baseScrollSpeed * scrollSpeed;

                    // Only scroll when we have at least 1 pixel
                    if (scrollAccumulator >= 1) {
                        const pixelsToScroll = Math.floor(scrollAccumulator);
                        window.scrollBy(0, pixelsToScroll);
                        scrollAccumulator -= pixelsToScroll; // Keep the remainder
                    }

                    // Stop if reached bottom
                    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
                        stopScroll();
                    }
                }, scrollIntervalTime);
            } else {
                stopScroll();
            }
        }

        function stopScroll() {
            isScrolling = false;
            scrollAccumulator = 0; // Reset accumulator
            document.getElementById('playButton').innerHTML = '<span style="font-family: Arial, sans-serif;">▶</span>';
            if (scrollInterval) {
                clearInterval(scrollInterval);
                scrollInterval = null;
            }
        }

        function updateScrollSpeed() {
            // Restart scroll with new speed if currently scrolling
            if (isScrolling) {
                stopScroll();
                startScroll();
            }
        }

        // Auto-scroll event listeners
        const playButton = document.getElementById('playButton');
        const increaseSpeed = document.getElementById('increaseSpeed');
        const decreaseSpeed = document.getElementById('decreaseSpeed');

        if (playButton) {
            playButton.addEventListener('click', startScroll);
        }

        if (increaseSpeed) {
            increaseSpeed.addEventListener('click', () => {
                scrollSpeed += 0.25; // Increase by 0.5 px/30ms
                updateScrollSpeed();
            });
        }

        if (decreaseSpeed) {
            decreaseSpeed.addEventListener('click', () => {
                if (scrollSpeed > 0.1) {
                    scrollSpeed -= 0.25; // Decrease by 0.5 px/30ms
                    updateScrollSpeed();
                }
            });
        }

        // Close menu on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeMenuFunc();
                closeHelpModal();
            }
        });

        // Help modal functionality
        const helpButton = document.getElementById('helpButton');
        const helpModal = document.getElementById('helpModal');
        const closeHelp = document.getElementById('closeHelp');

        function openHelpModal() {
            helpModal.classList.remove('opacity-0', 'pointer-events-none');
            helpModal.classList.add('opacity-100');
        }

        function closeHelpModal() {
            helpModal.classList.add('opacity-0', 'pointer-events-none');
            helpModal.classList.remove('opacity-100');
        }

        helpButton.addEventListener('click', openHelpModal);
        closeHelp.addEventListener('click', closeHelpModal);
        helpModal.addEventListener('click', (e) => {
            // Close if clicking the overlay background
            if (e.target === helpModal) {
                closeHelpModal();
            }
        });

        // Track active click-outside handler and if a line is currently open
        let activeClickHandler = null;
        let isLineOpen = false;

        // Make lines editable on click (only when in edit mode)
        document.addEventListener('click', (e) => {
            // Don't do anything if clicking inside the modal or an input field
            if (e.target.closest('#lineEditModal') || e.target.tagName === 'INPUT') {
                return;
            }

            let editableLine = e.target.closest('.editable-line');
            if (editableLine && isEditMode) {
                // If a line is already open, just close it without opening the new one
                if (isLineOpen) {
                    // Remove any existing click handler
                    if (activeClickHandler) {
                        document.removeEventListener('click', activeClickHandler);
                        activeClickHandler = null;
                    }

                    // Find the line with editing class and trigger close animation
                    const openLine = document.querySelector('.editable-line.editing');
                    if (openLine) {
                        openLine.classList.remove('editing');
                        openLine.classList.add('closing');
                        const openModal = document.getElementById('lineEditModal');
                        if (openModal) {
                            openModal.classList.add('hide');
                        }

                        // Re-render after animation completes (skip auto-scale to avoid glitch)
                        setTimeout(() => {
                            updateOutput(true); // true = skip auto-scale
                            isLineOpen = false;
                        }, 400);
                    }
                    return; // Don't open the clicked line
                }

                // Check if this line already has an input field
                if (editableLine.querySelector('input')) {
                    return;
                }

                const chordProText = editableLine.getAttribute('data-chordpro');
                const lineIndex = editableLine.getAttribute('data-line-index');
                const metadataType = editableLine.getAttribute('data-metadata');

                // Create modal for chord suggestions (only for chord lines, not metadata)
                let modal = null;
                if (!metadataType) {
                    // Extract all unique chords from the song
                    const allChords = new Set();
                    const chordRegex = /\[([^\]]+)\]/g;
                    let match;
                    while ((match = chordRegex.exec(currentChordProContent)) !== null) {
                        allChords.add(match[1]);
                    }
                    const uniqueChords = Array.from(allChords).sort();

                    modal = document.createElement('div');
                    modal.id = 'lineEditModal';
                    modal.className = 'line-edit-modal bg-white dark:bg-gray-800 border-2 border-primary rounded-lg shadow-2xl p-2 sm:p-4';
                    // Set explicit font-size to prevent overflow on aggressively scaled content
                    modal.style.fontSize = '14px';

                    // Modal content - show existing chords
                    let modalContent = '';
                    if (uniqueChords.length > 0) {
                        modalContent = `
                            <div class="text-gray-900 dark:text-gray-100">
                                <div class="text-xs font-semibold mb-2 text-gray-500 dark:text-gray-400">Chords in this song:</div>
                                <div class="flex flex-wrap gap-2">
                                    ${uniqueChords.map(chord => `
                                        <button class="chord-button px-3 py-1 bg-primary text-white rounded hover:bg-primary/80 transition-colors text-sm font-mono" data-chord="${chord}">
                                            ${chord}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    } else {
                        modalContent = `
                            <div class="text-gray-900 dark:text-gray-100 text-center text-sm text-gray-400">
                                No chords found in this song
                            </div>
                        `;
                    }
                    modal.innerHTML = modalContent;
                }

                // Create input field in the line itself
                const inputField = document.createElement('input');
                inputField.type = 'text';
                inputField.value = chordProText;
                inputField.className = 'w-full p-1 sm:p-2 border-2 border-primary rounded bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-mono text-center';
                // Set explicit font-size to prevent overflow on aggressively scaled content
                // Use smaller font on mobile to prevent overflow
                const isMobileView = window.innerWidth <= 768;
                inputField.style.fontSize = isMobileView ? '14px' : '16px';
                inputField.style.maxWidth = '100%';
                inputField.style.boxSizing = 'border-box';
                inputField.style.width = '100%';

                // Clear the line content but keep structure
                editableLine.innerHTML = '';

                // Set a fixed small font size on the editable line to prevent overflow
                // This overrides the parent's aggressive scaling
                editableLine.style.fontSize = isMobileView ? '14px' : '16px';
                editableLine.style.maxWidth = '100%';

                // Add modal first (if exists), then input
                if (modal) {
                    editableLine.appendChild(modal);
                }
                editableLine.appendChild(inputField);
                editableLine.classList.remove('cursor-pointer', 'hover:bg-gray-100', 'dark:hover:bg-gray-800');

                // Trigger animation after a delay
                setTimeout(() => {
                    editableLine.classList.add('editing');
                    // Modal appears instantly (no opening animation)
                    isLineOpen = true; // Mark that a line is now open
                }, 50);

                // Hide fixed UI elements when input is focused (for virtual keyboard)
                inputField.addEventListener('focus', () => {
                    document.querySelector('#menuToggle').parentElement.classList.add('opacity-0', 'pointer-events-none');
                    document.querySelectorAll('.no-print.fixed.top-4.right-4')[0].classList.add('opacity-0', 'pointer-events-none');
                });

                inputField.addEventListener('blur', () => {
                    document.querySelector('#menuToggle').parentElement.classList.remove('opacity-0', 'pointer-events-none');
                    document.querySelectorAll('.no-print.fixed.top-4.right-4')[0].classList.remove('opacity-0', 'pointer-events-none');
                });

                inputField.focus();

                // Handle chord button clicks (only if modal exists)
                if (modal) {
                    const chordButtons = modal.querySelectorAll('.chord-button');
                    chordButtons.forEach(button => {
                        button.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const chord = button.getAttribute('data-chord');
                            const cursorPos = inputField.selectionStart;
                            const textBefore = inputField.value.substring(0, cursorPos);
                            const textAfter = inputField.value.substring(cursorPos);

                            // Insert chord in ChordPro format at cursor position
                            inputField.value = textBefore + `[${chord}]` + textAfter;

                            // Move cursor after the inserted chord
                            const newCursorPos = cursorPos + chord.length + 2;
                            inputField.setSelectionRange(newCursorPos, newCursorPos);
                            inputField.focus();
                        });
                    });
                }

                // Save function
                const saveLine = () => {
                    const newValue = inputField.value;
                    // Update the ChordPro content
                    const lines = currentChordProContent.split('\n');

                    // Handle metadata editing
                    if (metadataType) {
                        // Find and replace the metadata line
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (line.startsWith(`{${metadataType}:`)) {
                                lines[i] = newValue;
                                break;
                            }
                        }
                    } else {
                        // Handle regular chord/lyric lines
                        let currentLineIndex = 0;
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            // Check if this is a lyric line (contains chords)
                            if (line.includes('[') && line.includes(']') && !line.startsWith('{')) {
                                if (currentLineIndex == lineIndex) {
                                    lines[i] = newValue;
                                    break;
                                }
                                currentLineIndex++;
                            }
                        }
                    }

                    // Update content
                    currentChordProContent = lines.join('\n');

                    // Prevent input event handler from running during programmatic update
                    isProcessingInput = true;
                    input.value = currentChordProContent;
                    isProcessingInput = false;

                    // Trigger closing animation
                    editableLine.classList.remove('editing');
                    editableLine.classList.add('closing');
                    if (modal) {
                        modal.classList.add('hide');
                    }

                    // Re-render after animation completes (skip auto-scale to avoid glitch)
                    setTimeout(() => {
                        updateOutput(true); // true = skip auto-scale
                        isLineOpen = false; // Mark that no line is open
                    }, 400);
                };

                // Save on Enter, cancel on Escape
                inputField.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveLine();
                    } else if (e.key === 'Escape') {
                        updateOutput(); // Cancel edit
                        if (modal && modal.parentNode) {
                            modal.remove();
                        }
                    }
                });

                // Handle clicks outside to close
                const handleClickOutside = (event) => {
                    // Don't close if clicking inside the modal or input field
                    if ((modal && modal.contains(event.target)) || inputField.contains(event.target)) {
                        return;
                    }

                    // Close if clicking outside
                    saveLine();
                    document.removeEventListener('click', handleClickOutside);
                    activeClickHandler = null;
                };

                // Store the handler so we can remove it later
                activeClickHandler = handleClickOutside;

                // Add listener after a short delay to prevent immediate closure
                setTimeout(() => {
                    document.addEventListener('click', handleClickOutside);
                }, 100);
            }
        });

        // Initial load
        updateOutput();
        updateFontSize();
    </script>
</body>
</html>

