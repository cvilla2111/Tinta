<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Smooth Ink — Compact Drawer, Stylus/Mouse Only</title>
<style>
  :root {
    --bg: #ffffff;
    --drawer-bg: #f7f9fc;
    --drawer-border: #d9e1ef;
    --text: #0b1220;
    --muted: #5a6a85;
    --accent: #3b82f6;
    --ok: #16a34a;
    --warn: #f59e0b;
  }
  * { box-sizing: border-box; }
  html, body {
    height: 100%; margin: 0; background: var(--bg); color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    overscroll-behavior: none;
  }
  .app { position: relative; width: 100%; height: 100%; overflow: hidden; }
  .surface { position: absolute; inset: 0; background: var(--bg); }
  canvas {
    position: absolute; inset: 0; width: 100%; height: 100%;
    display: block; background: #fff; cursor: crosshair;
    /* Disable finger drawing: allow pan/zoom with fingers, but we’ll filter in JS too */
    touch-action: pan-x pan-y;
  }

  /* Compact Drawer and scrim */
  .drawer-toggle {
    position: absolute; top: env(safe-area-inset-top, 8px); left: env(safe-area-inset-left, 8px);
    z-index: 50; border: 1px solid var(--drawer-border); background: rgba(255,255,255,0.9);
    backdrop-filter: blur(6px); color: var(--text); border-radius: 8px; padding: 8px 9px;
    font-size: .95rem; line-height: 1; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,0.06);
  }
  .scrim {
    position: absolute; inset: 0; background: rgba(0,0,0,0.25);
    opacity: 0; pointer-events: none; transition: opacity 180ms ease; z-index: 40;
  }
  .scrim.visible { opacity: 1; pointer-events: auto; }
  .drawer {
    position: absolute; top: 0; bottom: 0; left: 0; width: min(84vw, 320px); max-width: 92%;
    background: var(--drawer-bg); border-right: 1px solid var(--drawer-border);
    box-shadow: 0 8px 24px rgba(0,0,0,0.10);
    transform: translateX(-100%); transition: transform 200ms cubic-bezier(.2,.7,.2,1);
    z-index: 60; display: flex; flex-direction: column;
  }
  .drawer.open { transform: translateX(0); }
  .drawer-header {
    padding: calc(6px + env(safe-area-inset-top, 0px)) 8px 6px 8px;
    display: flex; gap: 6px; align-items: center; border-bottom: 1px solid var(--drawer-border);
  }
  .drawer-title { margin: 0; font-size: .85rem; font-weight: 700; letter-spacing: .2px; }
  .status {
    margin-left: auto; display: inline-flex; align-items: center; gap: 6px;
    background: #fff; border: 1px solid var(--drawer-border);
    padding: 3px 6px; border-radius: 7px; color: var(--muted); white-space: nowrap; font-size: .78rem;
  }
  .dot { width: 7px; height: 7px; border-radius: 50%; background: var(--warn); }
  .dot.ok { background: var(--ok); }
  .drawer-body { padding: 8px; overflow: auto; display: grid; gap: 8px; }
  .group {
    border: 1px solid var(--drawer-border); background: #fff; border-radius: 8px;
    padding: 8px; display: grid; gap: 6px;
  }
  .group h3 { margin: 0; font-size: .8rem; color: var(--muted); font-weight: 700; letter-spacing: .2px; }
  .row { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }

  .btn {
    appearance: none; background: #ffffff; border: 1px solid var(--drawer-border);
    color: var(--text); border-radius: 8px; padding: 6px 8px; font-size: .85rem; cursor: pointer;
  }
  .btn:hover { border-color: var(--accent); }
  .btn[aria-pressed="true"] { outline: 2px solid var(--accent); outline-offset: 0; }

  input[type="color"], input[type="range"], input[type="checkbox"], select { accent-color: var(--accent); }
  input[type="color"], input[type="range"], select {
    appearance: none; background: #ffffff; color: var(--text); border: 1px solid var(--drawer-border);
    border-radius: 8px; padding: 4px 6px; font-size: .85rem;
  }
  input[type="range"] { padding: 3px; width: 100%; }
  select { padding-right: 18px; }
  label { font-size: .85rem; color: var(--text); display: inline-flex; gap: 6px; align-items: center; }

  /* Compact toggle switch */
  .toggle { display: inline-flex; align-items: center; gap: 6px; user-select: none; }
  .switch {
    --w: 36px; --h: 20px; --pad: 2px;
    position: relative; width: var(--w); height: var(--h); border-radius: calc(var(--h)/2);
    background: #e5ebf6; border: 1px solid var(--drawer-border);
    transition: background 140ms ease, border-color 140ms ease; cursor: pointer; flex: 0 0 auto;
  }
  .switch::after {
    content: ""; position: absolute; top: var(--pad); left: var(--pad);
    width: calc(var(--h) - var(--pad) * 2); height: calc(var(--h) - var(--pad) * 2);
    background: #fff; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,.2);
    transition: transform 150ms ease;
  }
  .switch.on { background: #d7e7ff; border-color: #c4dafd; }
  .switch.on::after { transform: translateX(calc(36px - 20px)); }
  .switch.off::after { transform: translateX(0); }
  .switch.disabled { opacity: 0.5; cursor: not-allowed; }

  /* Edge swipe area */
  .edge-hit { position: absolute; top: 0; bottom: 0; left: 0; width: 14px; z-index: 30; touch-action: pan-y; }

  /* Floating Clear button */
  .clear-fab {
    position: absolute; top: env(safe-area-inset-top, 8px); right: env(safe-area-inset-right, 8px); z-index: 50;
    background: rgba(255,255,255,0.9); color: var(--text); border: 1px solid var(--drawer-border); border-radius: 8px;
    padding: 6px 9px; font-size: .9rem; line-height: 1; cursor: pointer; backdrop-filter: blur(6px);
    box-shadow: 0 2px 10px rgba(0,0,0,0.06);
  }
  .clear-fab:hover { border-color: var(--accent); }
</style>
</head>
<body>
  <div class="app">
    <div class="edge-hit" id="edgeHit"></div>

    <aside class="drawer" id="drawer" aria-hidden="true">
      <div class="drawer-header">
        <h2 class="drawer-title">Tools</h2>
        <div class="status"><span class="dot" id="statusDot"></span><span id="statusText">Checking…</span></div>
      </div>
      <div class="drawer-body">
        <div class="group">
          <h3>Render</h3>
          <div class="row">
            <label class="toggle" id="inkToggleWrap" title="Delegated Ink API">
              <div class="switch off" id="inkSwitch" role="switch" aria-checked="false" tabindex="0">
                <input type="checkbox" id="inkToggle" aria-hidden="true" />
              </div>
              <span style="font-size:.85rem" id="inkModeLabel">Canvas</span>
            </label>
            <span style="font-size:.78rem;color:var(--muted)" id="inkSupportNote">Detecting…</span>
          </div>
        </div>

        <div class="group">
          <h3>Tool</h3>
          <div class="row">
            <button id="toolPen" class="btn" aria-pressed="true" title="P">Pen</button>
            <button id="toolEraser" class="btn" aria-pressed="false" title="E">Erase</button>
            <label>Color <input id="color" type="color" value="#2b2b2b" /></label>
            <label style="flex:1">Width <input id="width" type="range" min="1" max="40" step="1" value="6" /></label>
            <label><input id="pressure" type="checkbox" checked /> Pressure</label>
          </div>
        </div>

        <div class="group">
          <h3>Smoothing</h3>
          <div class="row">
            <label><input type="checkbox" id="optResample" checked /> Resample</label>
            <label style="flex:1">Spacing <input type="range" id="resampleDist" min="0.5" max="8" step="0.5" value="1.5" /></label>
          </div>
          <div class="row">
            <label><input type="checkbox" id="optCurves" checked /> Curves</label>
            <span style="font-size:.78rem;color:var(--muted)">Midpoint quadratic</span>
          </div>
          <div class="row">
            <label><input type="checkbox" id="optRoundCaps" checked /> Round caps</label>
            <label><input type="checkbox" id="optMinWidth" checked /> Min width</label>
            <label style="flex:1">Min px <input type="range" id="minWidthPx" min="0.5" max="3" step="0.1" value="1.2" /></label>
          </div>
          <div class="row">
            <label><input type="checkbox" id="optPressureSmooth" checked /> Smooth pressure</label>
            <label style="flex:1">Strength <input type="range" id="pressureAlpha" min="0.05" max="0.8" step="0.05" value="0.2" /></label>
          </div>
        </div>

        <div class="group">
          <h3>Display</h3>
          <div class="row">
            <label><input type="checkbox" id="optHidpi" checked /> HiDPI</label>
            <label style="flex:1">Scale <input type="range" id="hidpiScale" min="1" max="3" step="0.25" value="2" /></label>
          </div>
        </div>

        <div class="group">
          <h3>History</h3>
          <div class="row">
            <button id="undo" class="btn" title="Ctrl+Z">Undo</button>
            <button id="redo" class="btn" title="Ctrl+Y">Redo</button>
            <button id="export" class="btn">Export PNG</button>
          </div>
        </div>

        <div class="group">
          <h3>Input</h3>
          <div class="row">
            <span class="note" style="font-size:.78rem;color:var(--muted)">Finger input disabled. Use pen or mouse.</span>
          </div>
        </div>
      </div>
    </aside>

    <div class="scrim" id="scrim" role="button" aria-label="Close drawer"></div>
    <button class="drawer-toggle" id="drawerToggle" aria-label="Open drawer" aria-expanded="false">☰</button>
    <button class="clear-fab" id="clearFab" type="button" title="Clear canvas">Clear</button>

    <div class="surface">
      <canvas id="canvas" aria-label="Drawing canvas"></canvas>
    </div>
  </div>

<script>
  // Elements
  const drawer = document.getElementById('drawer');
  const scrim = document.getElementById('scrim');
  const toggleBtn = document.getElementById('drawerToggle');
  const edgeHit = document.getElementById('edgeHit');

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const toolPen = document.getElementById('toolPen');
  const toolEraser = document.getElementById('toolEraser');
  const colorInput = document.getElementById('color');
  const widthInput = document.getElementById('width');
  const pressureToggle = document.getElementById('pressure');

  const undoBtn = document.getElementById('undo');
  const redoBtn = document.getElementById('redo');
  const exportBtn = document.getElementById('export');
  const clearFab = document.getElementById('clearFab');

  // Compact drawer interactions
  function openDrawer() {
    drawer.classList.add('open'); drawer.setAttribute('aria-hidden', 'false');
    scrim.classList.add('visible'); toggleBtn.setAttribute('aria-expanded', 'true');
  }
  function closeDrawer() {
    drawer.classList.remove('open'); drawer.setAttribute('aria-hidden', 'true');
    scrim.classList.remove('visible'); toggleBtn.setAttribute('aria-expanded', 'false');
  }
  toggleBtn.addEventListener('click', () => drawer.classList.contains('open') ? closeDrawer() : openDrawer());
  scrim.addEventListener('click', closeDrawer);
  let startX=null, swiping=false;
  edgeHit.addEventListener('touchstart', e => { if (drawer.classList.contains('open')) return; startX = e.touches[0].clientX; swiping = true; }, { passive: true });
  edgeHit.addEventListener('touchmove', e => { if (!swiping) return; const dx = e.touches[0].clientX - startX; if (dx > 28) { openDrawer(); swiping = false; } }, { passive: true });
  edgeHit.addEventListener('touchend', () => { swiping=false; startX=null; });

  // HiDPI sizing
  const optHidpi = document.getElementById('optHidpi');
  const hidpiScale = document.getElementById('hidpiScale');

  function targetDpr() {
    return optHidpi.checked ? Math.max(1, Number(hidpiScale.value)) : 1;
  }
  function resizeCanvas() {
    const dpr = targetDpr();
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    repaintAll();
  }
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', resizeCanvas);
  optHidpi.addEventListener('change', resizeCanvas);
  hidpiScale.addEventListener('input', resizeCanvas);

  // Ink API
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  const inkToggle = document.getElementById('inkToggle');
  const inkSwitch = document.getElementById('inkSwitch');
  const inkToggleWrap = document.getElementById('inkToggleWrap');
  const inkModeLabel = document.getElementById('inkModeLabel');
  const inkSupportNote = document.getElementById('inkSupportNote');
  let presenterPromise = null;
  let inkSupported = false;

  function setSwitchState(on, { disabled=false }={}) {
    inkToggle.checked = on;
    inkSwitch.classList.toggle('on', on);
    inkSwitch.classList.toggle('off', !on);
    inkSwitch.classList.toggle('disabled', disabled);
    inkSwitch.setAttribute('aria-checked', String(on));
    inkToggle.disabled = disabled;
    inkModeLabel.textContent = on ? 'Ink' : 'Canvas';
    updateStatus();
  }
  function updateStatus() {
    const usingInk = inkSupported && inkToggle.checked;
    statusDot.classList.toggle('ok', usingInk);
    statusText.textContent = usingInk ? 'Ink: ON' : (inkSupported ? 'Ink available — Canvas' : 'Ink not available');
  }
  function detectInk() {
    if ('ink' in navigator && navigator.ink && typeof navigator.ink.requestPresenter === 'function') {
      inkSupported = true; inkSupportNote.textContent = 'Ink API supported.'; setSwitchState(false);
    } else {
      inkSupported = false; inkSupportNote.textContent = 'Ink API not available.'; setSwitchState(false, { disabled: true }); presenterPromise = null;
    }
  }
  function toggleInk() {
    if (!inkSupported || inkToggle.disabled) return;
    const next = !inkToggle.checked;
    if (next) {
      try { presenterPromise = navigator.ink.requestPresenter({ presentationArea: canvas }); setSwitchState(true); }
      catch { presenterPromise = null; setSwitchState(false); }
    } else { presenterPromise = null; setSwitchState(false); }
  }
  inkToggleWrap.addEventListener('click', (e) => { e.preventDefault(); toggleInk(); });
  inkSwitch.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggleInk(); } });

  // Tools
  let tool = 'pen';
  function setTool(next) {
    tool = next;
    toolPen.setAttribute('aria-pressed', String(next === 'pen'));
    toolEraser.setAttribute('aria-pressed', String(next === 'eraser'));
  }
  toolPen.addEventListener('click', () => setTool('pen'));
  toolEraser.addEventListener('click', () => setTool('eraser'));

  // History and export
  const strokes = [];
  const redoStack = [];
  function pushStroke(s) { strokes.push(s); redoStack.length = 0; }
  function undo() { if (strokes.length) { redoStack.push(strokes.pop()); repaintAll(); } }
  function redo() { if (redoStack.length) { strokes.push(redoStack.pop()); repaintAll(); } }
  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);

  exportBtn.addEventListener('click', () => {
    const dpr = targetDpr();
    const rect = canvas.getBoundingClientRect();
    const out = document.createElement('canvas');
    out.width = Math.floor(rect.width * dpr);
    out.height = Math.floor(rect.height * dpr);
    const octx = out.getContext('2d');
    octx.setTransform(dpr, 0, 0, dpr, 0, 0);
    octx.fillStyle = '#ffffff'; octx.fillRect(0, 0, out.width, out.height);
    paintStrokes(octx);
    const url = out.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = 'drawing.png'; a.click();
  });

  function clearAll() {
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    ctx.save(); ctx.globalCompositeOperation='source-over'; ctx.fillStyle='#ffffff';
    ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height); ctx.restore();
    strokes.length = 0; redoStack.length = 0;
  }
  clearFab.addEventListener('click', clearAll);

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'p') setTool('pen');
    if (e.key.toLowerCase() === 'e') setTool('eraser');
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { undo(); e.preventDefault(); }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { redo(); e.preventDefault(); }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') { clearAll(); e.preventDefault(); }
  });

  // Smoothing controls
  const optResample = document.getElementById('optResample');
  const resampleDist = document.getElementById('resampleDist');
  const optCurves = document.getElementById('optCurves');
  const optRoundCaps = document.getElementById('optRoundCaps');
  const optMinWidth = document.getElementById('optMinWidth');
  const minWidthPx = document.getElementById('minWidthPx');
  const optPressureSmooth = document.getElementById('optPressureSmooth');
  const pressureAlpha = document.getElementById('pressureAlpha');

  [optResample, resampleDist, optCurves, optRoundCaps, optMinWidth, minWidthPx, optPressureSmooth, pressureAlpha]
    .forEach(el => {
      el.addEventListener('change', repaintAll);
      if (el.tagName === 'INPUT' && el.type === 'range') el.addEventListener('input', repaintAll);
    });

  // Drawing state
  let drawing = false;
  let currentStroke = null;
  let pressurePrev = null;

  function minStrokeWidth(base, p) {
    const withPressure = pressureToggle.checked ? base * (p || 0.5) : base;
    const minPxVal = optMinWidth.checked ? Number(minWidthPx.value) : 0.1;
    return Math.max(minPxVal, withPressure);
  }

  function styleFromEvent(evt) {
    let p = evt.pressure ?? 0.5;
    if (optPressureSmooth.checked) {
      const a = Number(pressureAlpha.value);
      pressurePrev = pressurePrev == null ? p : pressurePrev + a * (p - pressurePrev);
      p = pressurePrev;
    }
    const base = parseFloat(widthInput.value) || 6;
    const width = minStrokeWidth(base, p);
    return { color: colorInput.value, base, width, p, diameter: width };
  }

  function addPointToStroke(stroke, x, y, p) {
    stroke.points.push({ x, y, p });
  }

  function resampleSegment(a, b, spacing) {
    const pts = [];
    const dx = b.x - a.x, dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    if (dist <= spacing) return [b];
    const steps = Math.floor(dist / spacing);
    const inv = 1 / dist;
    for (let i = 1; i <= steps; i++) {
      const t = (i * spacing) * inv;
      pts.push({ x: a.x + dx * t, y: a.y + dy * t, p: a.p + (b.p - a.p) * t });
    }
    return pts;
  }

  function drawLiveSegment(a, b, stroke) {
    ctx.save();
    if (optRoundCaps.checked) { ctx.lineCap = 'round'; ctx.lineJoin = 'round'; }
    if (stroke.tool === 'eraser') {
      ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = '#000';
    } else {
      ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = stroke.color;
    }
    if (optCurves.checked) {
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      ctx.lineWidth = minStrokeWidth(stroke.baseWidth, b.p);
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.quadraticCurveTo(a.x, a.y, mx, my); ctx.stroke();
    } else {
      ctx.lineWidth = minStrokeWidth(stroke.baseWidth, b.p);
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
    }
    ctx.restore();
  }

  function paintStroke(ctx2, stroke) {
    const pts = stroke.points;
    if (!pts.length) return;
    ctx2.save();
    if (optRoundCaps.checked) { ctx2.lineCap = 'round'; ctx2.lineJoin = 'round'; }
    if (stroke.tool === 'eraser') {
      ctx2.globalCompositeOperation = 'destination-out'; ctx2.strokeStyle = '#000';
    } else {
      ctx2.globalCompositeOperation = 'source-over'; ctx2.strokeStyle = stroke.color;
    }
    if (pts.length === 1) {
      ctx2.lineWidth = minStrokeWidth(stroke.baseWidth, pts[0].p);
      ctx2.beginPath(); ctx2.moveTo(pts[0].x, pts[0].y); ctx2.lineTo(pts[0].x + 0.01, pts[0].y); ctx2.stroke();
      ctx2.restore(); return;
    }
    if (optCurves.checked) {
      ctx2.beginPath();
      ctx2.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        const p0 = pts[i - 1], p1 = pts[i];
        const mx = (p0.x + p1.x) / 2, my = (p0.y + p1.y) / 2;
        ctx2.lineWidth = minStrokeWidth(stroke.baseWidth, p1.p);
        ctx2.quadraticCurveTo(p0.x, p0.y, mx, my);
      }
      ctx2.stroke();
    } else {
      ctx2.beginPath();
      ctx2.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx2.lineWidth = minStrokeWidth(stroke.baseWidth, pts[i].p);
        ctx2.lineTo(pts[i].x, pts[i].y);
      }
      ctx2.stroke();
    }
    ctx2.restore();
  }

  function paintStrokes(targetCtx) {
    for (const s of strokes) paintStroke(targetCtx, s);
  }

  function repaintAll() {
    ctx.save(); ctx.globalCompositeOperation='source-over'; ctx.fillStyle='#ffffff';
    ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height); ctx.restore();
    paintStrokes(ctx);
  }

  // Pointer handling with finger disabled
  function isAllowedPointer(evt) {
    // Allow pen and mouse only
    const t = evt.pointerType;
    if (t === 'pen' || t === 'mouse') return true;
    // Finger/touch not allowed
    return false;
  }

  canvas.addEventListener('pointerdown', (evt) => {
    if (!isAllowedPointer(evt)) return; // ignore finger
    drawing = true;
    pressurePrev = null;
    canvas.setPointerCapture(evt.pointerId);

    const baseWidth = parseFloat(widthInput.value) || 6;
    currentStroke = { tool, color: colorInput.value, baseWidth, points: [] };

    const s = styleFromEvent(evt);
    addPointToStroke(currentStroke, evt.offsetX, evt.offsetY, s.p);

    // Seed tiny mark
    ctx.save();
    if (optRoundCaps.checked) { ctx.lineCap='round'; ctx.lineJoin='round'; }
    ctx.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
    ctx.strokeStyle = tool === 'eraser' ? '#000' : currentStroke.color;
    ctx.lineWidth = s.width;
    const p0 = currentStroke.points[0];
    ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p0.x + 0.01, p0.y); ctx.stroke();
    ctx.restore();
  });

  canvas.addEventListener('pointermove', (evt) => {
    if (!drawing || !isAllowedPointer(evt)) return;

    const events = (typeof evt.getCoalescedEvents === 'function') ? evt.getCoalescedEvents() : [evt];
    const spacing = optResample.checked ? Number(resampleDist.value) : 0;
    let last = currentStroke.points[currentStroke.points.length - 1];

    for (const e of events) {
      const rect = canvas.getBoundingClientRect();
      const x = e.offsetX ?? (e.clientX - rect.left);
      const y = e.offsetY ?? (e.clientY - rect.top);
      const s = styleFromEvent(e);
      const next = { x, y, p: s.p };

      if (optResample.checked && last) {
        const inserted = resampleSegment(last, next, spacing);
        for (const ip of inserted) {
          addPointToStroke(currentStroke, ip.x, ip.y, ip.p);
          drawLiveSegment(last, ip, currentStroke);
          last = ip;
        }
        addPointToStroke(currentStroke, next.x, next.y, next.p);
        drawLiveSegment(last, next, currentStroke);
        last = next;
      } else {
        addPointToStroke(currentStroke, next.x, next.y, next.p);
        drawLiveSegment(last, next, currentStroke);
        last = next;
      }

      // Delegated Ink
      if (inkSupported && inkToggle.checked && tool === 'pen' && presenterPromise) {
        presenterPromise.then(p => { try { p.updateInkTrailStartPoint(e, { color: s.color, diameter: s.diameter }); } catch {} });
      }
    }
  });

  function endStroke(evt) {
    if (!drawing) return;
    drawing = false;
    canvas.releasePointerCapture?.(evt.pointerId);
    if (currentStroke) { pushStroke(currentStroke); currentStroke = null; }
  }
  canvas.addEventListener('pointerup', endStroke);
  canvas.addEventListener('pointercancel', endStroke);
  canvas.addEventListener('lostpointercapture', (e) => { if (drawing) endStroke(e); });

  // Prevent default touch gestures on canvas if desired; here we allow page scroll/zoom but ignore drawing with finger.
  // If you want to block panning/zooming over the canvas, uncomment the following:
  // canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

  // Init
  function initBackground() {
    ctx.save(); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
  }
  function init() { detectInk(); resizeCanvas(); initBackground(); }
  window.addEventListener('load', init, { once: true });
</script>
</body>
</html>
