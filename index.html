<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotation App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#000000',
                        secondary: '#666666',
                        accent: '#999999'
                    }
                }
            }
        }
    </script>
    <style>
        /* Performance optimizations */
        * {
            box-sizing: border-box;
        }
        
        body {
            background: #ffffff;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #canvas {
            touch-action: none;
            cursor: crosshair;
        }
        
        .hamburger {
            transition: transform 0.2s ease;
        }
        
        .hamburger.open {
            transform: rotate(90deg);
        }
        
        .menu-panel {
            transform: translateX(-100%);
            transition: transform 0.2s ease;
            will-change: transform;
        }
        
        .menu-panel.open {
            transform: translateX(0);
        }
        
        .tool-btn {
            transition: background-color 0.1s ease;
        }
        
        .tool-btn:hover {
            background-color: #f5f5f5;
        }
        
        .tool-btn.active {
            background-color: #e5e5e5;
        }
    </style>
</head>
<body class="bg-white text-black font-mono">
    <!-- Header -->
    <div class="fixed top-0 left-0 right-0 bg-white border-b border-gray-300 z-20 h-12 flex items-center px-4">
        <button id="menuToggle" class="hamburger p-2 mr-3 hover:bg-gray-100 rounded">
            <div class="w-5 h-0.5 bg-black mb-1"></div>
            <div class="w-5 h-0.5 bg-black mb-1"></div>
            <div class="w-5 h-0.5 bg-black"></div>
        </button>
        <span class="text-sm font-medium">Annotation Tool</span>
        <div class="ml-auto flex items-center space-x-3">
            <span id="statusText" class="text-xs text-gray-600">Ready</span>
            <div id="inputDetails" class="flex items-center space-x-2">
                <div id="inputIndicator" class="w-2 h-2 bg-gray-400 rounded-full"></div>
                <div id="inputInfo" class="text-xs text-gray-600 font-mono min-w-0">
                    <div id="deviceType">-</div>
                    <div id="buttonState" class="text-gray-500">-</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="sideMenu" class="menu-panel fixed left-0 top-12 bottom-0 w-64 bg-white border-r border-gray-300 z-10 overflow-y-auto">
        <div class="p-4 space-y-4">
            <!-- Tools -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Tools</h3>
                <div class="space-y-1">
                    <button id="penTool" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200 active">
                        Pen
                    </button>
                    <button id="eraserTool" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200">
                        Eraser
                    </button>
                </div>
            </div>

            <!-- Stroke Width -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Stroke Width</h3>
                <input type="range" id="strokeWidth" min="1" max="20" value="2" 
                       class="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                <div class="text-xs text-gray-600 mt-1">
                    <span id="strokeWidthValue">2</span>px
                </div>
            </div>

            <!-- Actions -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Actions</h3>
                <div class="space-y-1">
                    <button id="clearBtn" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200">
                        Clear All
                    </button>
                    <button id="undoBtn" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200">
                        Undo
                    </button>
                </div>
            </div>

            <!-- Input Filter Status -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Input Filter</h3>
                <div class="text-xs text-gray-600 space-y-1">
                    <div>✓ Pen Enabled</div>
                    <div>✓ Mouse Enabled</div>
                    <div>✗ Touch Disabled</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div id="canvasContainer" class="fixed top-12 left-0 right-0 bottom-0 bg-white overflow-hidden">
        <canvas id="canvas" style="display: block;"></canvas>
    </div>

    <script>
        class AnnotationApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.menuToggle = document.getElementById('menuToggle');
                this.sideMenu = document.getElementById('sideMenu');
                this.statusText = document.getElementById('statusText');
                this.inputIndicator = document.getElementById('inputIndicator');
                
                this.isDrawing = false;
                this.currentStroke = null;
                this.currentTool = 'pen';
                this.strokeWidth = 2;
                this.strokes = [];
                this.undoStack = [];
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.updateCanvasSize();
                this.setupCanvas();
                window.addEventListener('resize', () => this.updateCanvasSize());
            }
            
            setupCanvas() {
                // Set up canvas for high-quality drawing
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Clear canvas
                this.clearCanvas(false); // Don't save to undo stack
            }
            
            setupEventListeners() {
                // Menu toggle
                this.menuToggle.addEventListener('click', () => this.toggleMenu());
                
                // Tool selection
                document.getElementById('penTool').addEventListener('click', () => this.setTool('pen'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                
                // Stroke width
                const strokeWidthSlider = document.getElementById('strokeWidth');
                strokeWidthSlider.addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    document.getElementById('strokeWidthValue').textContent = this.strokeWidth;
                });
                
                // Actions
                document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas(true));
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                
                // Canvas drawing events
                this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('pointercancel', (e) => this.handlePointerUp(e));
                
                // Add hover detection for pen
                this.canvas.addEventListener('pointerenter', (e) => this.handlePointerHover(e));
                this.canvas.addEventListener('pointerleave', (e) => this.resetInputIndicator());
                
                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            updateCanvasSize() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas size for high DPI displays
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Scale back down with CSS
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Scale the drawing context
                this.ctx.scale(dpr, dpr);
                
                // Store DPR for coordinate calculations
                this.devicePixelRatio = dpr;
                
                // Redraw existing strokes after resize
                this.redrawCanvas();
            }
            
            toggleMenu() {
                const isOpen = this.sideMenu.classList.toggle('open');
                this.menuToggle.classList.toggle('open', isOpen);
            }
            
            setTool(tool) {
                this.currentTool = tool;
                
                // Update UI
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                // Update cursor
                this.canvas.style.cursor = tool === 'pen' ? 'crosshair' : 'grab';
                
                this.updateStatus(`${tool.charAt(0).toUpperCase() + tool.slice(1)} selected`);
            }
            
            handlePointerDown(e) {
                // Filter input: only allow pen and mouse, block touch
                if (e.pointerType === 'touch') {
                    e.preventDefault();
                    this.updateStatus('Touch input disabled');
                    this.updateInputIndicator('touch', e);
                    setTimeout(() => {
                        this.resetInputIndicator();
                    }, 1000);
                    return;
                }
                
                // Update detailed input indicator
                this.updateInputIndicator(e.pointerType, e);
                
                e.preventDefault();
                this.canvas.setPointerCapture(e.pointerId);
                
                const point = this.getCanvasPoint(e);
                this.isDrawing = true;
                
                if (this.currentTool === 'pen') {
                    this.startStroke(point);
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(point);
                }
            }
            
            handlePointerMove(e) {
                // Update input indicator even when not drawing (for hover detection)
                if (e.pointerType === 'pen' && !this.isDrawing) {
                    this.updateInputIndicator(e.pointerType, e);
                }
                
                if (!this.isDrawing || e.pointerType === 'touch') return;
                
                e.preventDefault();
                const point = this.getCanvasPoint(e);
                
                if (this.currentTool === 'pen') {
                    this.addPointToStroke(point);
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(point);
                }
            }
            
            handlePointerHover(e) {
                if (e.pointerType === 'pen') {
                    this.updateInputIndicator(e.pointerType, e);
                }
            }
            
            handlePointerUp(e) {
                if (e.pointerType === 'touch') return;
                
                e.preventDefault();
                this.canvas.releasePointerCapture(e.pointerId);
                
                if (this.isDrawing && this.currentTool === 'pen') {
                    this.finishStroke();
                }
                
                this.isDrawing = false;
                this.resetInputIndicator();
                this.updateStatus('Ready');
            }
            
            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            startStroke(point) {
                // Save state for undo
                this.saveState();
                
                this.currentStroke = {
                    points: [point],
                    width: this.strokeWidth,
                    color: '#000000'
                };
                
                // Draw initial point
                this.ctx.strokeStyle = this.currentStroke.color;
                this.ctx.lineWidth = this.currentStroke.width;
                this.ctx.beginPath();
                this.ctx.moveTo(point.x, point.y);
            }
            
            addPointToStroke(point) {
                if (!this.currentStroke) return;
                
                this.currentStroke.points.push(point);
                
                // Apply quadratic midpoint interpolation for smooth curves
                if (this.currentStroke.points.length >= 3) {
                    this.drawQuadraticCurve();
                } else if (this.currentStroke.points.length === 2) {
                    // For the second point, draw a line
                    this.ctx.lineTo(point.x, point.y);
                    this.ctx.stroke();
                }
            }
            
            drawQuadraticCurve() {
                const points = this.currentStroke.points;
                const len = points.length;
                const p0 = points[len - 3]; // Previous point
                const p1 = points[len - 2]; // Current control point
                const p2 = points[len - 1]; // New point
                
                // Calculate midpoints for smooth interpolation
                const mid1 = this.getMidpoint(p0, p1);
                const mid2 = this.getMidpoint(p1, p2);
                
                // Draw quadratic curve
                this.ctx.quadraticCurveTo(p1.x, p1.y, mid2.x, mid2.y);
                this.ctx.stroke();
            }
            
            getMidpoint(p1, p2) {
                return {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
            }
            
            finishStroke() {
                if (!this.currentStroke) return;
                
                // Complete the stroke to the last point
                if (this.currentStroke.points.length >= 2) {
                    const lastPoint = this.currentStroke.points[this.currentStroke.points.length - 1];
                    this.ctx.lineTo(lastPoint.x, lastPoint.y);
                    this.ctx.stroke();
                }
                
                // Store completed stroke
                this.strokes.push({ ...this.currentStroke });
                this.currentStroke = null;
            }
            
            eraseAtPoint(point) {
                const eraseRadius = this.strokeWidth * 3;
                let needsRedraw = false;
                
                // Check for strokes to erase
                this.strokes = this.strokes.filter(stroke => {
                    if (this.isPointNearStroke(point, stroke, eraseRadius)) {
                        needsRedraw = true;
                        return false; // Remove this stroke
                    }
                    return true; // Keep this stroke
                });
                
                if (needsRedraw) {
                    this.redrawCanvas();
                }
            }
            
            isPointNearStroke(point, stroke, radius) {
                // Simple collision detection - check if point is near any stroke point
                for (let i = 0; i < stroke.points.length; i++) {
                    const strokePoint = stroke.points[i];
                    const distance = Math.sqrt(
                        Math.pow(point.x - strokePoint.x, 2) + 
                        Math.pow(point.y - strokePoint.y, 2)
                    );
                    if (distance < radius) {
                        return true;
                    }
                }
                return false;
            }
            
            redrawCanvas() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width / this.devicePixelRatio, this.canvas.height / this.devicePixelRatio);
                
                // Redraw all strokes
                this.strokes.forEach(stroke => {
                    this.drawStroke(stroke);
                });
            }
            
            drawStroke(stroke) {
                if (!stroke.points || stroke.points.length === 0) return;
                
                this.ctx.strokeStyle = stroke.color;
                this.ctx.lineWidth = stroke.width;
                this.ctx.beginPath();
                
                if (stroke.points.length === 1) {
                    // Single point
                    const p = stroke.points[0];
                    this.ctx.arc(p.x, p.y, stroke.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }
                
                // Start the path
                this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                
                if (stroke.points.length === 2) {
                    // Simple line
                    this.ctx.lineTo(stroke.points[1].x, stroke.points[1].y);
                } else {
                    // Quadratic curves for smooth lines
                    for (let i = 1; i < stroke.points.length - 1; i++) {
                        const current = stroke.points[i];
                        const next = stroke.points[i + 1];
                        const mid = this.getMidpoint(current, next);
                        this.ctx.quadraticCurveTo(current.x, current.y, mid.x, mid.y);
                    }
                    // Final point
                    const lastPoint = stroke.points[stroke.points.length - 1];
                    this.ctx.lineTo(lastPoint.x, lastPoint.y);
                }
                
                this.ctx.stroke();
            }
            
            clearCanvas(saveToUndo = true) {
                if (saveToUndo) {
                    this.saveState();
                }
                
                this.strokes = [];
                this.ctx.clearRect(0, 0, this.canvas.width / this.devicePixelRatio, this.canvas.height / this.devicePixelRatio);
                
                if (saveToUndo) {
                    this.updateStatus('Canvas cleared');
                }
            }
            
            saveState() {
                // Save current strokes state for undo
                const state = JSON.parse(JSON.stringify(this.strokes));
                this.undoStack.push(state);
                
                // Limit undo stack size for performance
                if (this.undoStack.length > 20) {
                    this.undoStack.shift();
                }
            }
            
            undo() {
                if (this.undoStack.length === 0) {
                    this.updateStatus('Nothing to undo');
                    return;
                }
                
                // Restore previous state
                this.strokes = this.undoStack.pop();
                this.redrawCanvas();
                this.updateStatus('Undone');
            }
            
            updateInputIndicator(pointerType, event) {
                const deviceType = document.getElementById('deviceType');
                const buttonState = document.getElementById('buttonState');
                const indicator = this.inputIndicator;
                
                if (pointerType === 'touch') {
                    indicator.className = 'w-2 h-2 bg-red-500 rounded-full';
                    deviceType.textContent = 'TOUCH';
                    buttonState.textContent = 'BLOCKED';
                    this.updateStatus('Touch input disabled');
                    return;
                }
                
                if (pointerType === 'pen') {
                    indicator.className = 'w-2 h-2 bg-blue-500 rounded-full';
                    deviceType.textContent = 'PEN';
                    
                    const buttons = this.getPenButtonState(event);
                    const pressure = Math.round((event.pressure || 0) * 100);
                    const tilt = event.tiltX !== undefined ? `T:${Math.round(event.tiltX)}°,${Math.round(event.tiltY)}°` : '';
                    
                    buttonState.textContent = `${buttons} P:${pressure}% ${tilt}`.trim();
                    this.updateStatus(`Pen: ${buttons} Pressure: ${pressure}%`);
                    
                } else if (pointerType === 'mouse') {
                    indicator.className = 'w-2 h-2 bg-green-500 rounded-full';
                    deviceType.textContent = 'MOUSE';
                    
                    const buttons = this.getMouseButtonState(event);
                    buttonState.textContent = buttons;
                    this.updateStatus(`Mouse: ${buttons}`);
                } else {
                    indicator.className = 'w-2 h-2 bg-orange-500 rounded-full';
                    deviceType.textContent = pointerType.toUpperCase();
                    buttonState.textContent = 'Unknown';
                    this.updateStatus(`${pointerType} input detected`);
                }
            }
            
            getPenButtonState(event) {
                const buttons = event.buttons || 0;
                const pressure = event.pressure || 0;
                const parts = [];
                
                if (buttons & 32 || buttons & 4 || (buttons === 0 && pressure > 0 && event.pointerType === 'pen' && this.isEraserEnd(event))) {
                    parts.push('ERASER-TIP');
                } else if (buttons & 1) {
                    parts.push('TIP');
                }
                
                if (buttons & 2) parts.push('BARREL');
                if ((buttons & 4) && !(buttons & 32)) parts.push('AUX');
                if (buttons & 8) parts.push('BTN4');
                if (buttons & 16) parts.push('BTN5');
                
                if (event.tangentialPressure !== undefined && Math.abs(event.tangentialPressure) > 0.01) {
                    parts.push(`ROT:${Math.round(event.tangentialPressure * 360)}°`);
                }
                
                if (parts.length === 0) {
                    return pressure > 0 ? 'CONTACT' : 'HOVER';
                }
                
                return parts.join('+');
            }
            
            isEraserEnd(event) {
                if (event.twist !== undefined && Math.abs(event.twist) > 90) {
                    return true;
                }
                
                if (event.tiltX !== undefined && event.tiltY !== undefined) {
                    const tiltMagnitude = Math.sqrt(event.tiltX * event.tiltX + event.tiltY * event.tiltY);
                    if (tiltMagnitude > 60) {
                        return true;
                    }
                }
                
                return false;
            }
            
            getMouseButtonState(event) {
                const buttons = event.buttons || 0;
                const parts = [];
                
                if (buttons & 1) parts.push('L');
                if (buttons & 2) parts.push('R');
                if (buttons & 4) parts.push('M');
                if (buttons & 8) parts.push('X1');
                if (buttons & 16) parts.push('X2');
                
                return parts.length > 0 ? parts.join('+') : 'HOVER';
            }
            
            resetInputIndicator() {
                this.inputIndicator.className = 'w-2 h-2 bg-gray-400 rounded-full';
                document.getElementById('deviceType').textContent = '-';
                document.getElementById('buttonState').textContent = '-';
            }
            
            updateStatus(message) {
                this.statusText.textContent = message;
            }
        }
        
        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new AnnotationApp();
        });
    </script>
</body>
</html>
