<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotator PWA</title>
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Minimalist PDF annotation app with stylus support">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlBERiBBbm5vdGF0b3IiLAogICJzaG9ydF9uYW1lIjogIlBERkFubm90YXRvciIsCiAgInN0YXJ0X3VybCI6ICIvIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjZmZmZmZmIiwKICAidGhlbWVfY29sb3IiOiAiIzAwMDAwMCIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgMjQgMjQnJTNFJTNDcGF0aCBkPSdNMTQgMkg2YTIgMiAwIDAgMC0yIDJ2MTZhMiAyIDAgMCAwIDIgMmgxMmEyIDIgMCAwIDAgMi0yVjh6Jy8lM0UlM0Nwb2x5bGluZSBwb2ludHM9JzE0LDIgMTQsOCAyMCw4JyUzRSUzQy9zdmclM0U%3D"LAogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXQp9">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <style>
        * {
            touch-action: manipulation;
        }
        
        .canvas-container {
            touch-action: none;
        }
        
        canvas {
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="min-h-screen bg-white">
    <div id="app" class="min-h-screen bg-white flex flex-col">
        <!-- Header -->
        <header class="border-b border-gray-200 p-4">
            <div class="flex items-center justify-between max-w-6xl mx-auto">
                <h1 class="text-xl font-semibold">PDF Annotator</h1>
                
                <div class="flex items-center gap-4">
                    <!-- File Upload -->
                    <button id="loadPdfBtn" class="flex items-center gap-2 px-4 py-2 border border-gray-300 hover:bg-gray-50 transition-colors">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7,10 12,15 17,10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        Load PDF
                    </button>
                    
                    <!-- Tools -->
                    <div id="tools" class="flex items-center gap-4" style="display: none;">
                        <button id="drawBtn" class="p-2 border bg-black text-white transition-colors">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                                <path d="M2 2l7.586 7.586"/>
                            </svg>
                        </button>
                        
                        <button id="eraseBtn" class="p-2 border border-gray-300 hover:bg-gray-50 transition-colors">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 20H7l-7-7 7-7h13v14z"/>
                                <path d="M13 13l7-7"/>
                            </svg>
                        </button>
                        
                        <button id="zoomOutBtn" class="p-2 border border-gray-300 hover:bg-gray-50 transition-colors">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="M21 21l-4.35-4.35"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                        </button>
                        
                        <button id="zoomInBtn" class="p-2 border border-gray-300 hover:bg-gray-50 transition-colors">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="M21 21l-4.35-4.35"/>
                                <line x1="11" y1="8" x2="11" y2="14"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                        </button>
                        
                        <button id="clearBtn" class="px-3 py-2 border border-gray-300 hover:bg-gray-50 transition-colors text-sm">
                            Clear
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 flex flex-col items-center p-4">
            <input id="fileInput" type="file" accept=".pdf" style="display: none;">
            
            <!-- Welcome Screen -->
            <div id="welcomeScreen" class="flex-1 flex items-center justify-center">
                <div class="text-center">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-4 text-gray-400">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    <p class="text-gray-600 mb-4">Load a PDF to start annotating</p>
                    <button id="welcomeLoadBtn" class="px-6 py-3 bg-black text-white hover:bg-gray-800 transition-colors">
                        Choose PDF File
                    </button>
                </div>
            </div>
            
            <!-- PDF Viewer -->
            <div id="pdfViewer" class="flex flex-col items-center gap-4 w-full max-w-4xl" style="display: none;">
                <!-- Canvas Container -->
                <div class="border border-gray-300 shadow-lg overflow-auto max-w-full max-h-screen canvas-container">
                    <canvas id="pdfCanvas" class="display-block no-select"></canvas>
                </div>
                
                <!-- Page Controls -->
                <div class="flex items-center gap-4">
                    <button id="prevBtn" class="px-4 py-2 border border-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        Previous
                    </button>
                    
                    <span id="pageInfo" class="text-sm font-medium">
                        Page 1 of 1
                    </span>
                    
                    <button id="nextBtn" class="px-4 py-2 border border-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        Next
                    </button>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Application state
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let zoom = 1;
        let isDrawing = false;
        let isErasing = false;
        let lastPoint = null;
        let annotations = {};

        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('pdfCanvas');
        const ctx = canvas.getContext('2d');
        const welcomeScreen = document.getElementById('welcomeScreen');
        const pdfViewer = document.getElementById('pdfViewer');
        const tools = document.getElementById('tools');
        const pageInfo = document.getElementById('pageInfo');

        // Button elements
        const loadPdfBtn = document.getElementById('loadPdfBtn');
        const welcomeLoadBtn = document.getElementById('welcomeLoadBtn');
        const drawBtn = document.getElementById('drawBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const clearBtn = document.getElementById('clearBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        // File loading
        async function loadPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                
                // Show PDF viewer, hide welcome screen
                welcomeScreen.style.display = 'none';
                pdfViewer.style.display = 'flex';
                tools.style.display = 'flex';
                
                await renderPage(currentPage);
                updatePageInfo();
            } catch (error) {
                console.error('Error loading PDF:', error);
                alert('Error loading PDF file');
            }
        }

        // Render PDF page
        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: zoom });
            
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Render PDF page
            await page.render({
                canvasContext: ctx,
                viewport: viewport
            }).promise;
            
            // Restore annotations for this page
            if (annotations[pageNum]) {
                annotations[pageNum].forEach(stroke => {
                    drawStroke(stroke);
                });
            }
        }

        // Draw stroke on canvas
        function drawStroke(stroke) {
            if (stroke.type === 'erase') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = stroke.width;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = stroke.width;
            }
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            if (stroke.points.length > 1) {
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                ctx.stroke();
            }
        }

        // Get pointer position relative to canvas
        function getPointerPosition(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        // Update page info display
        function updatePageInfo() {
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            prevBtn.disabled = currentPage <= 1;
            nextBtn.disabled = currentPage >= totalPages;
        }

        // Page navigation
        async function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                await renderPage(currentPage);
                updatePageInfo();
            }
        }

        // Zoom functionality
        async function handleZoom(delta) {
            const newZoom = Math.max(0.5, Math.min(3, zoom + delta));
            zoom = newZoom;
            await renderPage(currentPage);
        }

        // Clear page annotations
        async function clearPage() {
            annotations[currentPage] = [];
            await renderPage(currentPage);
        }

        // Toggle tools
        function setDrawMode(drawing) {
            isErasing = !drawing;
            if (drawing) {
                drawBtn.className = 'p-2 border bg-black text-white transition-colors';
                eraseBtn.className = 'p-2 border border-gray-300 hover:bg-gray-50 transition-colors';
            } else {
                drawBtn.className = 'p-2 border border-gray-300 hover:bg-gray-50 transition-colors';
                eraseBtn.className = 'p-2 border bg-black text-white transition-colors';
            }
        }

        // Canvas event handlers
        canvas.addEventListener('pointerdown', (e) => {
            // Only allow stylus/pen input, block finger touch
            if (e.pointerType === 'touch') {
                e.preventDefault();
                return;
            }
            
            if (e.pointerType !== 'pen') return;
            
            canvas.setPointerCapture(e.pointerId);
            isDrawing = true;
            
            const point = getPointerPosition(e);
            lastPoint = point;
            
            // Start new stroke
            const newStroke = {
                type: isErasing ? 'erase' : 'draw',
                points: [point],
                width: isErasing ? 20 : Math.max(1, e.pressure * 5)
            };
            
            if (!annotations[currentPage]) {
                annotations[currentPage] = [];
            }
            annotations[currentPage].push(newStroke);
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!isDrawing || e.pointerType === 'touch') return;
            
            const point = getPointerPosition(e);
            
            // Configure drawing context
            if (isErasing) {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 20;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = Math.max(1, e.pressure * 5);
            }
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw line segment
            if (lastPoint) {
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            }
            
            lastPoint = point;
            
            // Update current stroke
            if (annotations[currentPage] && annotations[currentPage].length > 0) {
                const currentStroke = annotations[currentPage][annotations[currentPage].length - 1];
                currentStroke.points.push(point);
                if (!isErasing) {
                    currentStroke.width = Math.max(1, e.pressure * 5);
                }
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (e.pointerType === 'touch') return;
            
            isDrawing = false;
            lastPoint = null;
            canvas.releasePointerCapture(e.pointerId);
        });

        // Prevent context menu and other touch interactions
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        canvas.addEventListener('touchstart', (e) => e.preventDefault());
        canvas.addEventListener('touchmove', (e) => e.preventDefault());
        canvas.addEventListener('touchend', (e) => e.preventDefault());

        // File input handling
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                loadPDF(e.target.files[0]);
            }
        });

        // Button event listeners
        loadPdfBtn.addEventListener('click', () => fileInput.click());
        welcomeLoadBtn.addEventListener('click', () => fileInput.click());
        drawBtn.addEventListener('click', () => setDrawMode(true));
        eraseBtn.addEventListener('click', () => setDrawMode(false));
        zoomInBtn.addEventListener('click', () => handleZoom(0.2));
        zoomOutBtn.addEventListener('click', () => handleZoom(-0.2));
        clearBtn.addEventListener('click', clearPage);
        prevBtn.addEventListener('click', () => changePage(-1));
        nextBtn.addEventListener('click', () => changePage(1));

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgZXZlbnQgPT4gewogIGV2ZW50LndhaXRVbnRpbChzZWxmLnNraXBXYWl0aW5nKCkpOwp9KTsKCnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCBldmVudCA9PiB7CiAgLy8gU2ltcGxlIHBhc3MtdGhyb3VnaAogIGV2ZW50LnJlc3BvbmRXaXRoKGZldGNoKGV2ZW50LnJlcXVlc3QpKTsKfSk7')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('Service Worker registration failed'));
        }

        // Initialize drawing mode
        setDrawMode(true);
    </script>
</body>
</html>
