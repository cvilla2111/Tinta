<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Ink API Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: white;
        }
        
        #canvas {
            display: block;
            background: white;
            cursor: crosshair;
        }
        
        #error {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="error">Ink API not supported in this browser</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const errorDiv = document.getElementById('error');
        
        let presenter = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let prevX = 0;
        let prevY = 0;
        
        // Canvas setup with high-DPI support
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            // Set actual canvas size in memory (scaled for high-DPI)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Set display size (CSS pixels)
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Scale the drawing context to match device pixel ratio
            ctx.scale(dpr, dpr);
            
            // Improve rendering quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        
        // Initial setup
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Initialize Ink API
        async function initInkAPI() {
            if (!navigator.ink) {
                errorDiv.style.display = 'block';
                return;
            }
            
            try {
                presenter = await navigator.ink.requestPresenter({ presentationArea: canvas });
                console.log('Ink API ready');
            } catch (err) {
                console.error('Ink API failed:', err);
                errorDiv.textContent = 'Ink API failed to initialize';
                errorDiv.style.display = 'block';
            }
        }
        initInkAPI();
        
        // Drawing functions
        function startDrawing(x, y) {
            isDrawing = true;
            lastX = x;
            lastY = y;
            prevX = x;
            prevY = y;
            
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Start the path for quadratic curves
            ctx.beginPath();
            ctx.moveTo(x, y);
        }
        
        function draw(x, y) {
            if (!isDrawing) return;
            
            // Calculate quadratic curve control point (midpoint of previous segment)
            const cpX = (prevX + lastX) / 2;
            const cpY = (prevY + lastY) / 2;
            
            // Calculate end point (midpoint between last and current)
            const endX = (lastX + x) / 2;
            const endY = (lastY + y) / 2;
            
            // Draw smooth quadratic curve
            ctx.quadraticCurveTo(lastX, lastY, endX, endY);
            ctx.stroke();
            
            // Update positions for next curve
            prevX = lastX;
            prevY = lastY;
            lastX = x;
            lastY = y;
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        // Pointer Events (stylus/pen with Ink API)
        canvas.addEventListener('pointerdown', (evt) => {
            evt.preventDefault();
            if (evt.pointerType === 'touch') return;
            
            startDrawing(evt.offsetX, evt.offsetY);
            
            if (presenter) {
                try {
                    presenter.updateInkTrailStartPoint(evt, {
                        color: 'black',
                        diameter: 2
                    });
                } catch (err) {
                    console.error('Ink API update failed:', err);
                }
            }
        });
        
        canvas.addEventListener('pointermove', (evt) => {
            evt.preventDefault();
            if (evt.pointerType === 'touch') return;
            
            draw(evt.offsetX, evt.offsetY);
            
            if (presenter && isDrawing) {
                try {
                    presenter.updateInkTrailStartPoint(evt, {
                        color: 'black',
                        diameter: 2
                    });
                } catch (err) {
                    console.error('Ink API update failed:', err);
                }
            }
        });
        
        canvas.addEventListener('pointerup', (evt) => {
            evt.preventDefault();
            if (evt.pointerType === 'touch') return;
            stopDrawing();
        });
        
        canvas.addEventListener('pointerleave', (evt) => {
            evt.preventDefault();
            if (evt.pointerType === 'touch') return;
            stopDrawing();
        });
        
        // Mouse Events (fallback)
        canvas.addEventListener('mousedown', (evt) => {
            evt.preventDefault();
            startDrawing(evt.offsetX, evt.offsetY);
        });
        
        canvas.addEventListener('mousemove', (evt) => {
            evt.preventDefault();
            draw(evt.offsetX, evt.offsetY);
        });
        
        canvas.addEventListener('mouseup', (evt) => {
            evt.preventDefault();
            stopDrawing();
        });
        
        canvas.addEventListener('mouseleave', (evt) => {
            evt.preventDefault();
            stopDrawing();
        });
        
        // Disable touch events
        ['touchstart', 'touchmove', 'touchend'].forEach(event => {
            canvas.addEventListener(event, (evt) => evt.preventDefault());
        });
        
        // Clear canvas
        canvas.addEventListener('dblclick', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });
    </script>
</body>
</html>
