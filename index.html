<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;"><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Drawing App - Stylus Only</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script>
    <style>
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 10;
            touch-action: none; /* Prevent default touch behaviors */
        }
        .pdf-page-container {
            position: relative;
            margin: 0 auto;
        }
        .tool-active {
            background-color: #E5E7EB !important;
            color: #374151 !important;
        }
        .dark .tool-active {
            background-color: #4B5563 !important;
            color: #F3F4F6 !important;
        }
        .selected-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-size {
            background-color: #4B5563 !important;
        }
        .selected-eraser-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-eraser-size {
            background-color: #4B5563 !important;
        }
        
        /* Page transition effects */
        .page-transition {
            transition: opacity 0.3s ease-in-out;
        }
        .page-fade-out {
            opacity: 0;
        }
        .page-fade-in {
            opacity: 1;
        }

        /* Page thumbnail modal */
        .page-thumbnail-modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        .page-thumbnail-modal.open {
            transform: translateX(0);
        }
        .page-thumbnail {
            transition: all 0.2s ease;
        }
        .page-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        .page-thumbnail.current {
            border-color: #5D5CDE !important;
            box-shadow: 0 0 0 2px #5D5CDE;
        }

        /* Enhanced eraser indicator with speed-based sizing - no transition for instant response */
        #eraserIndicator {
            /* Removed transitions for instant response at high speeds */
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script><script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body class="bg-white dark:bg-gray-900 min-h-screen">
    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
                <h1 class="text-2xl font-bold text-gray-900 dark:text-white">PDF Drawing App</h1>
                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">Stylus-only drawing | 2-finger swipe navigation | MPP stylus with pressure &amp; speed-responsive eraser</p>
            </div>
            
            <!-- File Upload and Theme Toggle -->
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                <!-- Theme Toggle -->
                <div class="flex items-center gap-2">
                    <i data-lucide="sun" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="themeToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-gray-600"></div>
                    </label>
                    <i data-lucide="moon" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                </div>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 hidden sm:block"></div>
                
                <input type="file" id="pdfUpload" accept=".pdf" class="hidden">
                <button onclick="document.getElementById('pdfUpload').click()" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-base">
                    Upload PDF
                </button>
                <button id="downloadBtn" onclick="downloadPDF()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-base" disabled="">
                    Download
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div id="mainContent" class="max-w-7xl mx-auto">
        <!-- Initial Upload Area -->
        <div id="uploadArea" class="p-4">
            <div class="text-center">
                <div class="bg-gray-50 dark:bg-gray-800 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-12">
                    <div class="text-gray-400 dark:text-gray-500">
                        <svg class="mx-auto h-12 w-12 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        <p class="text-lg font-medium">No PDF loaded</p>
                        <p class="text-sm mt-2">Upload a PDF file to start drawing with stylus</p>
                        <div class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <p class="text-sm text-blue-700 dark:text-blue-300">
                                <strong>Note:</strong> Stylus-only drawing | Supports MPP stylus with pressure sensitivity and speed-responsive eraser. Cast button will open presentation on secondary monitor.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Viewer Area (Full Screen) -->
        <div id="pdfViewer" class="hidden fixed inset-0 bg-white">
            <!-- Settings Modal -->
            <div id="settingsModal" class="fixed bottom-20 left-4 z-40 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-4 hidden">
                <!-- Pen Settings -->
                <div id="penSettings" class="hidden">
                    <!-- Brush Size Dots and Pressure Switch in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setBrushSize(0.5)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="0.5">
                            <div style="width: 1px; height: 1px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(1)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="1">
                            <div style="width: 1px; height: 1px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(1.3)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="1.3">
                            <div style="width: 1.3px; height: 1.3px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(2)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="2">
                            <div style="width: 2px; height: 2px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(4)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="4">
                            <div style="width: 4px; height: 4px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(6)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="6">
                            <div style="width: 6px; height: 6px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(8)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="8">
                            <div style="width: 8px; height: 8px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(11)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="11">
                            <div style="width: 11px; height: 11px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(14)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="14">
                            <div style="width: 14px; height: 14px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(16)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="16">
                            <div style="width: 16px; height: 16px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(18)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="18">
                            <div style="width: 18px; height: 18px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(20)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="20">
                            <div style="width: 20px; height: 20px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        
                        <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 mx-2"></div>
                        
                        <!-- Pressure Switch -->
                        <div class="flex items-center gap-2">
                            <i data-lucide="zap" class="w-3 h-3 text-gray-600 dark:text-gray-400"></i>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="pressureSwitch" class="sr-only peer" checked="">
                                <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Pressure</span>
                        </div>
                    </div>
                </div>

                <!-- Color Settings -->
                <div id="colorSettings" class="hidden flex items-center gap-4">
                    <!-- Color Grid -->
                    <div class="grid grid-cols-10 gap-1">
                        <button onclick="setColor('#000000')" class="w-5 h-5 rounded-full bg-black border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#FFFFFF')" class="w-5 h-5 rounded-full bg-white border border-gray-400 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#6B7280')" class="w-5 h-5 rounded-full bg-gray-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EF4444')" class="w-5 h-5 rounded-full bg-red-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F97316')" class="w-5 h-5 rounded-full bg-orange-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F59E0B')" class="w-5 h-5 rounded-full bg-yellow-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#84CC16')" class="w-5 h-5 rounded-full bg-lime-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#10B981')" class="w-5 h-5 rounded-full bg-emerald-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#06B6D4')" class="w-5 h-5 rounded-full bg-cyan-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#3B82F6')" class="w-5 h-5 rounded-full bg-blue-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        
                        <button onclick="setColor('#6366F1')" class="w-5 h-5 rounded-full bg-indigo-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#8B5CF6')" class="w-5 h-5 rounded-full bg-violet-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#A855F7')" class="w-5 h-5 rounded-full bg-purple-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EC4899')" class="w-5 h-5 rounded-full bg-pink-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F43F5E')" class="w-5 h-5 rounded-full bg-rose-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#DC2626')" class="w-5 h-5 rounded-full bg-red-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#059669')" class="w-5 h-5 rounded-full bg-emerald-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#2563EB')" class="w-5 h-5 rounded-full bg-blue-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#7C3AED')" class="w-5 h-5 rounded-full bg-violet-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#92400E')" class="w-5 h-5 rounded-full bg-yellow-800 border border-gray-300 hover:scale-110 transition-transform"></button>
                    </div>
                </div>

                <!-- Eraser Settings -->
                <div id="eraserSettings" class="hidden">
                    <!-- Eraser Size Dots in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setEraserSize(8)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-eraser-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="8">
                            <div style="width: 8px; height: 8px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(12)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="12">
                            <div style="width: 12px; height: 12px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(13)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="13">
                            <div style="width: 13px; height: 13px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(25)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="25">
                            <div style="width: 25px; height: 25px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(35)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="35">
                            <div style="width: 35px; height: 35px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(50)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="50">
                            <div style="width: 50px; height: 50px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Page Navigation -->
            <div id="pageNavigation" class="fixed top-4 right-4 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-3 py-1.5 flex items-center gap-2">
                <button onclick="changePage(-1)" id="prevPageBtn" class="w-6 h-6 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="chevron-left" class="w-3 h-3 text-gray-700 dark:text-gray-300"></i>
                </button>
                
                <button onclick="openPageThumbnailModal()" class="flex items-center gap-1 px-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors">
                    <span id="currentPageNum" class="text-xs font-medium text-gray-900 dark:text-gray-100">1</span>
                    <span class="text-xs text-gray-500 dark:text-gray-400">/</span>
                    <span id="totalPagesNum" class="text-xs text-gray-500 dark:text-gray-400">1</span>
                </button>
                
                <button onclick="changePage(1)" id="nextPageBtn" class="w-6 h-6 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="chevron-right" class="w-3 h-3 text-gray-700 dark:text-gray-300"></i>
                </button>
            </div>

            <!-- Bottom Left Toolbar -->
            <div id="floatingToolbar" class="fixed bottom-4 left-4 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-6 py-3 flex items-center gap-4">
                <!-- Tool Selection -->
                <button id="penTool" onclick="setTool('pen')" class="w-8 h-8 rounded-full flex items-center justify-center tool-active hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="pen-tool" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="eraserTool" onclick="setTool('eraser')" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="eraser" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="colorTool" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <div id="colorIndicator" class="w-5 h-5 rounded-full border-2 border-gray-400 dark:border-gray-500" style="background-color: #000000;"></div>
                </button>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600"></div>
                
                <!-- Actions -->
                <button onclick="openPresentationMode()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors" title="Cast to Secondary Monitor">
                    <i data-lucide="cast" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button onclick="toggleFullscreen()" id="fullscreenBtn" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="maximize" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button onclick="clearCanvas()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="trash-2" class="w-4 h-4 text-red-600 dark:text-red-400"></i>
                </button>
            </div>

            <!-- Page Thumbnail Modal -->
            <div id="pageThumbnailModal" class="page-thumbnail-modal fixed inset-y-0 right-0 w-80 bg-white dark:bg-gray-800 shadow-2xl z-[70] border-l border-gray-200 dark:border-gray-700">
                <div class="h-full flex flex-col">
                    <!-- Header -->
                    <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
                        <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Pages</h3>
                        <button onclick="closePageThumbnailModal()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                            <i data-lucide="x" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                        </button>
                    </div>
                    
                    <!-- Thumbnails Container -->
                    <div id="thumbnailContainer" class="flex-1 overflow-y-auto p-4 space-y-3">
                        <!-- Thumbnails will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Modal Backdrop -->
            <div id="modalBackdrop" class="fixed inset-0 bg-black bg-opacity-50 z-[65] hidden" onclick="closePageThumbnailModal()"></div>

            <!-- PDF Content -->
            <div id="pdfContent" class="w-full h-full flex items-center justify-center overflow-auto"></div>
            

        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Application state
        let pdfDoc = null;
        let pdfArrayBuffer = null; // Store PDF data for presentation window
        let currentPage = 1;
        let totalPages = 0;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentBrushSize = 1.3;
        let currentEraserSize = 8;
        let pressureEnabled = true;
        let isDrawing = false;
        let drawingData = {}; // Store drawing data for each page with scale info
        let originalPageDimensions = {}; // Store original PDF page dimensions
        
        // Speed-based eraser sizing variables
        let lastMoveTime = 0;
        let velocityHistory = [];
        let currentDynamicEraserSize = 8;
        let targetDynamicEraserSize = 8; // Target size for smooth transitions
        let sizeTransitionTimeout = null; // For delayed size reduction
        let isWaitingToShrink = false; // Track if we're already waiting to shrink
        const maxVelocityHistory = 5;
        const minEraserSize = 13;  // Minimum eraser size
        const maxEraserSizeMultiplier = 13.46; // Maximum size multiplier based on speed (13px -> 175px)
        
        // Presentation mode state
        let presentationWindow = null;
        
        // Secondary monitor detection function
        async function getSecondaryMonitorWindowFeatures() {
            try {
                // Try the newer Screen API first (Chrome 100+)
                if ('getScreenDetails' in window) {
                    const screenDetails = await window.getScreenDetails();
                    const screens = screenDetails.screens;
                    
                    if (screens.length > 1) {
                        // Find a secondary screen (not the current one)
                        const currentScreen = screenDetails.currentScreen;
                        const secondaryScreen = screens.find(screen => screen !== currentScreen) || screens[1];
                        
                        // Calculate window position and size for secondary monitor
                        const width = Math.min(1280, secondaryScreen.availWidth * 0.9);
                        const height = Math.min(720, secondaryScreen.availHeight * 0.9);
                        const left = secondaryScreen.availLeft + (secondaryScreen.availWidth - width) / 2;
                        const top = secondaryScreen.availTop + (secondaryScreen.availHeight - height) / 2;
                        
                        return `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no`;
                    }
                }
                
                // Fallback: Try to detect secondary monitor using screen properties
                if (window.screen.availWidth < window.outerWidth + 1280 || 
                    window.screen.availHeight < window.outerHeight + 720) {
                    // Likely has multiple monitors, position on the right side
                    const primaryWidth = window.screen.availWidth;
                    const left = primaryWidth + 100; // Position on secondary monitor
                    const top = 100;
                    
                    return `width=1280,height=720,left=${left},top=${top},resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no`;
                }
                
            } catch (error) {
                console.log('Screen API not available or permission denied:', error);
            }
            
            // Default fallback - center on current monitor
            const width = 1280;
            const height = 720;
            const left = (window.screen.availWidth - width) / 2;
            const top = (window.screen.availHeight - height) / 2;
            
            return `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no`;
        }
        
        // Stylus eraser button state
        let originalTool = 'pen'; // Track the original tool before eraser button press
        let isEraserButtonPressed = false;

        // Double-click detection
        let lastClickTime = 0;
        let lastClickTarget = null;
        const DOUBLE_CLICK_DELAY = 300; // milliseconds

        // Drawing state
        let lastX = 0;
        let lastY = 0;

        // Calculate dynamic eraser size based on velocity with delayed size reduction
        function calculateDynamicEraserSize(currentX, currentY, timestamp, canvasRect, canvasElement) {
            if (currentTool !== 'eraser') return currentEraserSize;
            
            const deltaTime = timestamp - lastMoveTime;
            if (deltaTime <= 0 || lastMoveTime === 0) {
                lastMoveTime = timestamp;
                currentDynamicEraserSize = currentEraserSize;
                targetDynamicEraserSize = currentEraserSize;
                return currentEraserSize;
            }
            
            // Calculate movement distance in normalized coordinates (independent of canvas scaling)
            const deltaX = currentX - lastX;
            const deltaY = currentY - lastY;
            
            // Normalize the distance to be independent of canvas resolution and page dimensions
            // Use the original PDF dimensions as reference for consistent velocity across pages
            const originalDimensions = originalPageDimensions[currentPage];
            let normalizedDistance;
            
            if (originalDimensions && canvasElement) {
                // Calculate the current canvas scale relative to original PDF dimensions
                const canvasToOriginalScaleX = canvasElement.width / originalDimensions.width;
                const canvasToOriginalScaleY = canvasElement.height / originalDimensions.height;
                const averageScale = (canvasToOriginalScaleX + canvasToOriginalScaleY) / 2;
                
                // Normalize distance back to original PDF coordinate space
                const normalizedDeltaX = deltaX / averageScale;
                const normalizedDeltaY = deltaY / averageScale;
                normalizedDistance = Math.sqrt(normalizedDeltaX * normalizedDeltaX + normalizedDeltaY * normalizedDeltaY);
            } else {
                // Fallback: use raw canvas distance
                normalizedDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            }
            
            // Calculate velocity (normalized pixels per millisecond)
            const velocity = normalizedDistance / deltaTime;
            
            // Add to velocity history for smoothing
            velocityHistory.push(velocity);
            if (velocityHistory.length > maxVelocityHistory) {
                velocityHistory.shift();
            }
            
            // Calculate average velocity for smoother transitions
            const avgVelocity = velocityHistory.reduce((sum, v) => sum + v, 0) / velocityHistory.length;
            

            
            // Map velocity to size multiplier (consistent thresholds across all pages)
            const velocityThreshold = 0.15; // Minimum velocity to start scaling (very sensitive)
            const maxVelocity = 2.2; // Velocity at which max size is reached (very easy to reach max)
            
            let newTargetSize;
            if (avgVelocity <= velocityThreshold) {
                newTargetSize = currentEraserSize;
            } else {
                const normalizedVelocity = Math.min((avgVelocity - velocityThreshold) / (maxVelocity - velocityThreshold), 1.0);
                const sizeMultiplier = 1.0 + (normalizedVelocity * (maxEraserSizeMultiplier - 1.0));
                newTargetSize = currentEraserSize * sizeMultiplier;
            }
            
            // Handle size increase vs decrease differently
            if (newTargetSize > currentDynamicEraserSize) {
                // Size increase: immediate response
                currentDynamicEraserSize = newTargetSize;
                targetDynamicEraserSize = newTargetSize;
                isWaitingToShrink = false;
                
                // Clear any pending size reduction
                if (sizeTransitionTimeout) {
                    clearTimeout(sizeTransitionTimeout);
                    sizeTransitionTimeout = null;
                }
            } else if (newTargetSize < currentDynamicEraserSize && !isWaitingToShrink) {
                // Size decrease: delayed response (only set timeout once)
                targetDynamicEraserSize = newTargetSize;
                isWaitingToShrink = true;
                
                // Delay size reduction by 300ms, then smooth transition
                sizeTransitionTimeout = setTimeout(() => {
                    // Start smooth transition to smaller size
                    const startSize = currentDynamicEraserSize;
                    const endSize = targetDynamicEraserSize;
                    const startTime = performance.now();
                    const duration = 200; // 200ms smooth transition
                    
                    function animateSize(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Ease-out cubic for smooth deceleration
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        
                        currentDynamicEraserSize = startSize - (startSize - endSize) * easedProgress;
                        
                        if (progress < 1 && isWaitingToShrink) {
                            requestAnimationFrame(animateSize);
                        } else {
                            // Animation complete
                            currentDynamicEraserSize = targetDynamicEraserSize;
                            sizeTransitionTimeout = null;
                            isWaitingToShrink = false;
                        }
                    }
                    
                    requestAnimationFrame(animateSize);
                }, 300); // 300ms delay before starting smooth size reduction
            }
            
            lastMoveTime = timestamp;
            return currentDynamicEraserSize;
        }

        // Reset speed tracking when starting a new stroke
        function resetSpeedTracking() {
            velocityHistory = [];
            lastMoveTime = 0;
            currentDynamicEraserSize = currentEraserSize;
            targetDynamicEraserSize = currentEraserSize;
            isWaitingToShrink = false;
            
            // Clear any pending size reduction
            if (sizeTransitionTimeout) {
                clearTimeout(sizeTransitionTimeout);
                sizeTransitionTimeout = null;
            }
        }

        // File upload handler
        document.getElementById('pdfUpload').addEventListener('change', handleFileUpload);

        // Settings event listeners
        function setupSettingsListeners() {
            // Pressure switch
            const pressureSwitch = document.getElementById('pressureSwitch');
            pressureSwitch.addEventListener('change', function() {
                pressureEnabled = this.checked;
            });

            // Theme toggle switch
            const themeToggle = document.getElementById('themeToggle');
            
            // Set initial state based on current theme
            themeToggle.checked = document.documentElement.classList.contains('dark');
            
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            // Tool buttons with double-click detection
            document.getElementById('penTool').addEventListener('pointerdown', handleToolDoubleClick);
            document.getElementById('eraserTool').addEventListener('pointerdown', handleToolDoubleClick);
            document.getElementById('colorTool').addEventListener('pointerdown', handleColorSingleClick);
        }

        // Brush size selection
        function setBrushSize(size) {
            currentBrushSize = size;
            
            // Update visual selection
            document.querySelectorAll('.brush-size-dot').forEach(btn => {
                btn.classList.remove('selected-size');
            });
            document.querySelector(`[data-size="${size}"]`).classList.add('selected-size');
            
            // Close modal after selection
            hideSettingsModal();
        }

        // Eraser size selection
        function setEraserSize(size) {
            currentEraserSize = size;
            currentDynamicEraserSize = size; // Reset dynamic size
            
            // Update visual selection
            document.querySelectorAll('.eraser-size-dot').forEach(btn => {
                btn.classList.remove('selected-eraser-size');
            });
            document.querySelector(`[data-eraser-size="${size}"]`).classList.add('selected-eraser-size');
            
            // Close modal after selection
            hideSettingsModal();
        }

        // Handle double-click on tool buttons
        function handleToolDoubleClick(e) {
            if (e.pointerType !== 'pen' && e.pointerType !== 'touch') return;
            
            const currentTime = Date.now();
            const target = e.currentTarget;
            
            if (lastClickTarget === target && (currentTime - lastClickTime) < DOUBLE_CLICK_DELAY) {
                // Double-click detected
                e.preventDefault();
                const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                showSettingsModal(toolType);
            } else {
                // Single click - set tool
                setTimeout(() => {
                    if (Date.now() - currentTime >= DOUBLE_CLICK_DELAY) {
                        const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                        setTool(toolType);
                    }
                }, DOUBLE_CLICK_DELAY);
            }
            
            lastClickTime = currentTime;
            lastClickTarget = target;
        }

        // Handle single-click on color button
        function handleColorSingleClick(e) {
            if (e.pointerType !== 'pen' && e.pointerType !== 'touch') return;
            
            // Immediately show color picker on single tap
            e.preventDefault();
            showSettingsModal('color');
        }

        // Modal management
        function showSettingsModal(toolType) {
            const modal = document.getElementById('settingsModal');
            const penSettings = document.getElementById('penSettings');
            const eraserSettings = document.getElementById('eraserSettings');
            const colorSettings = document.getElementById('colorSettings');
            
            // Hide all settings panels
            penSettings.classList.add('hidden');
            eraserSettings.classList.add('hidden');
            colorSettings.classList.add('hidden');
            
            // Show the appropriate settings panel
            if (toolType === 'pen') {
                penSettings.classList.remove('hidden');
                // Ensure the correct brush size is visually selected
                updateBrushSizeSelection();
            } else if (toolType === 'eraser') {
                eraserSettings.classList.remove('hidden');
                // Ensure the correct eraser size is visually selected
                updateEraserSizeSelection();
            } else if (toolType === 'color') {
                colorSettings.classList.remove('hidden');
            }
            
            // Show the modal
            modal.classList.remove('hidden');
        }

        // Function to update brush size visual selection
        function updateBrushSizeSelection() {
            // Remove selection from all brush size buttons
            document.querySelectorAll('.brush-size-dot').forEach(btn => {
                btn.classList.remove('selected-size');
            });
            // Add selection to the current brush size button
            const currentButton = document.querySelector(`[data-size="${currentBrushSize}"]`);
            if (currentButton) {
                currentButton.classList.add('selected-size');
            }
        }

        // Function to update eraser size visual selection
        function updateEraserSizeSelection() {
            // Remove selection from all eraser size buttons
            document.querySelectorAll('.eraser-size-dot').forEach(btn => {
                btn.classList.remove('selected-eraser-size');
            });
            // Add selection to the current eraser size button
            const currentButton = document.querySelector(`[data-eraser-size="${currentEraserSize}"]`);
            if (currentButton) {
                currentButton.classList.add('selected-eraser-size');
            }
        }

        function hideSettingsModal() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('hidden');
        }

        // Click outside modal to close
        document.addEventListener('pointerdown', function(e) {
            if (e.pointerType !== 'pen' && e.pointerType !== 'touch') return;
            
            const modal = document.getElementById('settingsModal');
            const toolbar = document.getElementById('floatingToolbar');
            
            if (!modal.contains(e.target) && !toolbar.contains(e.target) && !modal.classList.contains('hidden')) {
                hideSettingsModal();
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (!pdfDoc) return;
            
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                changePage(-1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                changePage(1);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closePDF();
            }
        });

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfArrayBuffer = arrayBuffer.slice(); // Store a copy for presentation window
                pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                drawingData = {}; // Reset drawing data
                
                // Hide upload area and header, show PDF viewer
                document.getElementById('uploadArea').style.display = 'none';
                document.querySelector('header').style.display = 'none';
                document.getElementById('pdfViewer').classList.remove('hidden');
                
                await renderPage(currentPage);
                document.getElementById('downloadBtn').disabled = false;
                
                // Update page navigation UI
                updatePageNavigation();
            } catch (error) {
                console.error('Error loading PDF:', error);
                showCustomAlert('Error loading PDF file. Please try again.');
            }
        }

        async function renderPage(pageNum, withTransition = false, direction = 1) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const container = document.getElementById('pdfContent');
                
                if (withTransition) {
                    await performFadeTransition(pageNum, direction);
                    return;
                }
                
                // Calculate scale to fit the screen width (with small margin to prevent scrollbars)
                const containerWidth = window.innerWidth - 20; // Small margin to prevent overflow
                const viewport = page.getViewport({ scale: 1 });
                
                // Ultra-High-DPI rendering: Scale to fill the width, then render at 4x resolution for maximum quality
                const displayScale = containerWidth / viewport.width;
                const renderScale = displayScale * 4; // 4x resolution for ultra-high quality
                const scaledViewport = page.getViewport({ scale: renderScale });
                
                // Calculate display dimensions (what user sees)
                const displayWidth = Math.floor(containerWidth);
                const displayHeight = Math.floor(viewport.height * displayScale);

                // Create page container with display dimensions
                const pageContainer = document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.style.width = displayWidth + 'px';
                pageContainer.style.height = displayHeight + 'px';

                // Create and setup PDF canvas with high resolution
                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;  // High resolution (2x)
                pdfCanvas.height = scaledViewport.height; // High resolution (2x)
                pdfCanvas.style.width = displayWidth + 'px';  // Display size
                pdfCanvas.style.height = displayHeight + 'px'; // Display size
                pdfCanvas.style.display = 'block';

                // Create and setup drawing canvas with CONSISTENT HIGH resolution across all pages
                const drawingCanvas = document.createElement('canvas');
                drawingCanvas.className = 'drawing-canvas';
                
                // Use CONSISTENT resolution scaling based on display size to ensure uniform pen thickness
                // This ensures the same pen size across all pages regardless of PDF page dimensions
                const targetResolutionMultiplier = 2; // Consistent 2x resolution for all pages
                drawingCanvas.width = displayWidth * targetResolutionMultiplier;   // Consistent high resolution
                drawingCanvas.height = displayHeight * targetResolutionMultiplier; // Consistent high resolution
                
                drawingCanvas.style.width = displayWidth + 'px';  // Display size
                drawingCanvas.style.height = displayHeight + 'px'; // Display size

                // Setup drawing event listeners
                setupDrawingEvents(drawingCanvas);

                // Clear container and add new elements
                container.innerHTML = '';
                pageContainer.appendChild(pdfCanvas);
                pageContainer.appendChild(drawingCanvas);
                container.appendChild(pageContainer);

                // Store original page dimensions for first render or if not stored
                if (!originalPageDimensions[pageNum]) {
                    originalPageDimensions[pageNum] = {
                        width: viewport.width,
                        height: viewport.height
                    };
                }

                // Render PDF page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;

                // Restore drawing data for this page with perfect quality preservation
                if (drawingData[pageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    
                    // Set optimal image rendering settings for crisp quality
                    ctx.imageSmoothingEnabled = false; // Disable smoothing for pixel-perfect restoration
                    
                    const img = new Image();
                    img.onload = function() {
                        // Calculate scaling factors based on canvas size changes (use drawing canvas dimensions)
                        const scaleX = drawingCanvas.width / drawingData[pageNum].canvasWidth;
                        const scaleY = drawingCanvas.height / drawingData[pageNum].canvasHeight;
                        
                        // Scale and draw the image to fit the new canvas size
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                        
                        // Re-enable smoothing for future drawing operations
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                    };
                    img.src = drawingData[pageNum].imageData;
                }

                // Update modal visual selections to reflect current settings
                updateBrushSizeSelection();
                updateEraserSizeSelection();

                // Reset any transition styles
                container.style.transition = '';
                container.style.transform = '';

            } catch (error) {
                console.error('Error rendering page:', error);
                // Reset styles on error
                const container = document.getElementById('pdfContent');
                container.style.transition = '';
                container.style.transform = '';
            }
        }

        async function performFadeTransition(targetPageNum, direction) {
            const container = document.getElementById('pdfContent');
            const currentPageElement = container.firstElementChild;
            
            // Calculate scale for consistent sizing with ultra-high quality
            const containerWidth = window.innerWidth - 20;
            const targetPage = await pdfDoc.getPage(targetPageNum);
            const viewport = targetPage.getViewport({ scale: 1 });
            
            // Ultra-High-DPI rendering: Same 4x scaling as main render
            const displayScale = containerWidth / viewport.width;
            const renderScale = displayScale * 4; // 4x resolution for ultra-high quality
            const scaledViewport = targetPage.getViewport({ scale: renderScale });
            
            // Calculate display dimensions (what user sees)
            const displayWidth = Math.floor(containerWidth);
            const displayHeight = Math.floor(viewport.height * displayScale);

            // Create new page container
            const newPageContainer = document.createElement('div');
            newPageContainer.className = 'pdf-page-container';
            newPageContainer.style.cssText = `
                width: ${displayWidth}px;
                height: ${displayHeight}px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                opacity: 0;
                transition: opacity 0.4s ease-in-out;
            `;

            // Create PDF canvas with ultra-high resolution
            const pdfCanvas = document.createElement('canvas');
            pdfCanvas.width = scaledViewport.width;  // Ultra-high resolution (4x)
            pdfCanvas.height = scaledViewport.height; // Ultra-high resolution (4x)
            pdfCanvas.style.width = displayWidth + 'px';  // Display size
            pdfCanvas.style.height = displayHeight + 'px'; // Display size
            pdfCanvas.style.display = 'block';

            // Create drawing canvas with CONSISTENT HIGH resolution (same as main render)
            const drawingCanvas = document.createElement('canvas');
            drawingCanvas.className = 'drawing-canvas';
            const targetResolutionMultiplier = 2; // Same multiplier as main render
            drawingCanvas.width = displayWidth * targetResolutionMultiplier;   // Consistent high resolution
            drawingCanvas.height = displayHeight * targetResolutionMultiplier; // Consistent high resolution
            drawingCanvas.style.width = displayWidth + 'px';  // Display size
            drawingCanvas.style.height = displayHeight + 'px'; // Display size

            newPageContainer.appendChild(pdfCanvas);
            newPageContainer.appendChild(drawingCanvas);

            // Render the new page
            const renderContext = {
                canvasContext: pdfCanvas.getContext('2d'),
                viewport: scaledViewport
            };
            await targetPage.render(renderContext).promise;

            // Restore drawing data for new page
            if (drawingData[targetPageNum]) {
                const ctx = drawingCanvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                    // Calculate scaling factors based on canvas size changes (use drawing canvas dimensions)
                    const scaleX = drawingCanvas.width / drawingData[targetPageNum].canvasWidth;
                    const scaleY = drawingCanvas.height / drawingData[targetPageNum].canvasHeight;
                    
                    ctx.save();
                    ctx.scale(scaleX, scaleY);
                    ctx.drawImage(img, 0, 0);
                    ctx.restore();
                };
                img.src = drawingData[targetPageNum].imageData;
            }

            // Position current page absolutely and prepare for fade out
            if (currentPageElement) {
                currentPageElement.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    opacity: 1;
                    transition: opacity 0.5s ease-in-out;
                `;
            }

            // Add new page to container (behind current page)
            container.appendChild(newPageContainer);

            // Force reflow
            newPageContainer.offsetHeight;

            // Start fade transition
            if (currentPageElement) {
                currentPageElement.style.opacity = '0';
            }
            newPageContainer.style.opacity = '1';

            // Wait for fade animation to complete
            await new Promise(resolve => setTimeout(resolve, 400));

            // Clean up: remove old page and reset container
            container.innerHTML = '';
            
            // Reset new page styles to normal positioning
            newPageContainer.style.cssText = `
                width: ${displayWidth}px;
                height: ${displayHeight}px;
                position: relative;
                margin: 0 auto;
                opacity: 1;
            `;
            
            container.appendChild(newPageContainer);

            // Setup drawing events for new page
            setupDrawingEvents(drawingCanvas);

            console.log('Fade transition complete'); // Debug log
        }

        function setupDrawingEvents(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Enhanced ink quality settings
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Stroke smoothing variables
            let points = [];
            let pressureHistory = [];
            const maxHistoryLength = 5;

            // 2-finger gesture variables
            let gestureStartTouches = [];
            let gestureCurrentTouches = [];
            let isGestureActive = false;
            let gestureStartTime = 0;
            const SWIPE_MIN_DISTANCE = 20; // Minimum swipe distance in pixels (very easy to trigger)
            const SWIPE_MAX_TIME = 2000; // Maximum time for swipe gesture in ms (very generous timing)

            // Create eraser indicator
            const eraserIndicator = document.createElement('div');
            eraserIndicator.id = 'eraserIndicator';
            eraserIndicator.style.cssText = `
                position: absolute;
                border: 2px dashed #666;
                border-radius: 50%;
                pointer-events: none;
                z-index: 15;
                display: none;
                background: rgba(255, 255, 255, 0.1);
            `;
            document.body.appendChild(eraserIndicator);

            // Pointer events for stylus detection
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', draw);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointercancel', stopDrawing);
            
            // Only stop drawing on pointerout if we're actually drawing and the pointer leaves the document
            canvas.addEventListener('pointerout', (e) => {
                // Only stop if we're actually drawing and the pointer is leaving the entire viewport
                if (isDrawing && (e.clientX < 0 || e.clientY < 0 || 
                    e.clientX > window.innerWidth || e.clientY > window.innerHeight)) {
                    stopDrawing(e);
                }
            });

            // Prevent default mouse behaviors to avoid conflicts (allow touch for finger input)
            canvas.addEventListener('mousedown', e => e.preventDefault());
            canvas.addEventListener('mousemove', e => e.preventDefault());
            canvas.addEventListener('mouseup', e => e.preventDefault());

            // 2-finger gesture detection with touch events
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

            function handleTouchStart(e) {
                if (e.touches.length === 2) {
                    // 2-finger gesture detected - prevent drawing and start gesture tracking
                    e.preventDefault();
                    isGestureActive = true;
                    gestureStartTime = Date.now();
                    
                    // Store initial touch positions
                    gestureStartTouches = Array.from(e.touches).map(touch => ({
                        x: touch.clientX,
                        y: touch.clientY
                    }));
                    
                    // Stop any ongoing drawing
                    if (isDrawing) {
                        isDrawing = false;
                        hideEraserIndicator();
                        updatePressureIndicator(0);
                        resetSpeedTracking();
                    }
                } else if (e.touches.length === 1 && !isGestureActive) {
                    // Allow single touch drawing to continue normally
                    // (the pointerdown handler will take care of this)
                }
            }

            function handleTouchMove(e) {
                if (isGestureActive && e.touches.length === 2) {
                    // Prevent scrolling/zooming while gesture is active
                    e.preventDefault();
                    
                    // Update current touch positions for gesture calculation
                    gestureCurrentTouches = Array.from(e.touches).map(touch => ({
                        x: touch.clientX,
                        y: touch.clientY
                    }));
                } else if (e.touches.length !== 2) {
                    // Reset gesture if touch count changes
                    isGestureActive = false;
                    gestureStartTouches = [];
                    gestureCurrentTouches = [];
                }
            }

            function handleTouchEnd(e) {
                if (isGestureActive) {
                    // 2-finger gesture completed (even if not both fingers up simultaneously)
                    e.preventDefault();
                    
                    const gestureEndTime = Date.now();
                    const gestureTime = gestureEndTime - gestureStartTime;
                    
                    console.log('Touch end - fingers remaining:', e.touches.length);
                    
                    // Much more forgiving conditions - check if we have any gesture data
                    if (gestureTime <= SWIPE_MAX_TIME && gestureStartTouches.length >= 2) {
                        
                        // Use the last known positions if we don't have current positions
                        let endTouches = gestureCurrentTouches;
                        if (endTouches.length < 2 && gestureStartTouches.length >= 2) {
                            // If we lost tracking, try to estimate from remaining touches
                            if (e.touches.length > 0) {
                                console.log('Using fallback position estimation');
                                // Use current touch positions as approximation
                                endTouches = Array.from(e.touches).map(touch => ({
                                    x: touch.clientX,
                                    y: touch.clientY
                                }));
                                // Duplicate if only one finger left
                                while (endTouches.length < 2) {
                                    endTouches.push(endTouches[0]);
                                }
                            } else {
                                // Use start positions as fallback (no movement detected)
                                endTouches = [...gestureStartTouches];
                            }
                        }
                        
                        if (endTouches.length >= 2) {
                            // Calculate average movement 
                            const avgStartX = (gestureStartTouches[0].x + gestureStartTouches[1].x) / 2;
                            const avgEndX = (endTouches[0].x + endTouches[1].x) / 2;
                            
                            const deltaX = avgEndX - avgStartX;
                            const absX = Math.abs(deltaX);
                            
                            console.log(`Gesture: start=${avgStartX}, end=${avgEndX}, deltaX=${deltaX}, distance=${absX}`);
                            
                            // Very generous distance check
                            if (absX >= SWIPE_MIN_DISTANCE) {
                                if (deltaX > 0) {
                                    console.log('Swipe right detected - going to previous page');
                                    changePage(-1);
                                } else {
                                    console.log('Swipe left detected - going to next page');
                                    changePage(1);
                                }
                            } else {
                                console.log('Swipe distance too small:', absX);
                            }
                        }
                    } else {
                        console.log('Gesture conditions not met:', { 
                            gestureTime, 
                            startTouches: gestureStartTouches.length, 
                            currentTouches: gestureCurrentTouches.length 
                        });
                    }
                    
                    // Always reset gesture state when any touch ends during an active gesture
                    isGestureActive = false;
                    gestureStartTouches = [];
                    gestureCurrentTouches = [];
                }
            }

            function startDrawing(e) {
                // Only allow pen/stylus input for drawing
                if (e.pointerType !== 'pen') {
                    return;
                }

                // Prevent drawing if 2-finger gesture is active
                if (isGestureActive) {
                    return;
                }

                // Enhanced eraser detection for multiple stylus types
                // MPP Stylus: button 2 (right click) or button 5 (eraser), buttons bitmask bit 2 = 4
                const eraserButtonPressed = 
                    e.button === 2 ||           // Standard right-click/barrel button
                    e.button === 5 ||           // Standard eraser button
                    (e.buttons & 2) !== 0 ||    // Right button bitmask
                    (e.buttons & 4) !== 0 ||    // Middle/barrel button bitmask
                    (e.buttons & 32) !== 0;     // Eraser button bitmask (some devices)
                
                if (eraserButtonPressed && !isEraserButtonPressed) {
                    // Store original tool and switch to eraser
                    originalTool = currentTool;
                    isEraserButtonPressed = true;
                    if (currentTool !== 'eraser') {
                        setTool('eraser');
                    }
                } else if (!eraserButtonPressed && isEraserButtonPressed) {
                    // Restore original tool when eraser button is released
                    isEraserButtonPressed = false;
                    setTool(originalTool);
                }

                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                
                // Calculate coordinates accounting for high-DPI scaling
                const displayX = e.clientX - rect.left;
                const displayY = e.clientY - rect.top;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                lastX = displayX * scaleX;
                lastY = displayY * scaleY;
                
                // Reset stroke history for new stroke
                points = [];
                pressureHistory = [];
                
                // Reset speed tracking for new stroke
                resetSpeedTracking();
                
                // Add initial point
                const pressure = e.pressure || 0.5;
                points.push({ x: lastX, y: lastY, pressure: pressure });
                pressureHistory.push(pressure);
                
                // Show eraser indicator if using eraser tool
                if (currentTool === 'eraser') {
                    showEraserIndicator(e.clientX, e.clientY, currentEraserSize);
                }
                
                // Update pressure indicator
                updatePressureIndicator(pressure);
            }

            function draw(e) {
                // Only allow pen/stylus input for drawing
                if (e.pointerType !== 'pen' || !isDrawing) {
                    return;
                }

                // Prevent drawing if 2-finger gesture is active
                if (isGestureActive) {
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                
                // Calculate coordinates accounting for high-DPI scaling
                const displayX = e.clientX - rect.left;
                const displayY = e.clientY - rect.top;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const currentX = displayX * scaleX;
                const currentY = displayY * scaleY;

                // Calculate dynamic eraser size based on speed using canvas coordinates (like the working version)
                let dynamicEraserSize = currentEraserSize;
                if (currentTool === 'eraser') {
                    // Check if there's actual movement before calculating dynamic size
                    const deltaX = currentX - lastX;
                    const deltaY = currentY - lastY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Only calculate dynamic sizing and update indicator if there's meaningful movement (more than 1 pixel)
                    if (distance > 1) {
                        dynamicEraserSize = calculateDynamicEraserSize(currentX, currentY, e.timeStamp, rect, canvas);
                        
                        // Calculate the screen size for the indicator to match actual eraser area
                        const originalDimensions = originalPageDimensions[currentPage];
                        let indicatorSize;
                        if (originalDimensions) {
                            const canvasToOriginalScale = canvas.width / originalDimensions.width;
                            const toolSizeInCanvas = dynamicEraserSize * canvasToOriginalScale;
                            indicatorSize = toolSizeInCanvas / Math.min(scaleX, scaleY);
                        } else {
                            indicatorSize = dynamicEraserSize;
                        }
                        
                        updateEraserIndicator(e.clientX, e.clientY, indicatorSize);
                    } else {
                        // Just update position without changing size for tiny movements
                        updateEraserIndicator(e.clientX, e.clientY);
                    }
                }

                // Get pressure value
                const pressure = e.pressure || 0.5;
                
                // Add current point to history for smoothing
                points.push({ x: currentX, y: currentY, pressure: pressure });
                pressureHistory.push(pressure);
                
                // Keep history within limits
                if (points.length > maxHistoryLength) {
                    points.shift();
                    pressureHistory.shift();
                }

                // Use CONSISTENT tool size scaling based on fixed resolution multiplier
                // This ensures identical pen thickness across all pages regardless of PDF dimensions
                const targetResolutionMultiplier = 2; // Same multiplier used for canvas creation
                const toolSize = (currentTool === 'eraser' ? dynamicEraserSize : currentBrushSize) * targetResolutionMultiplier;
                
                if (currentTool === 'eraser') {
                    // Eraser: Use destination-out to remove pixels
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = toolSize;
                    
                    // Draw eraser stroke - color doesn't matter for destination-out, but set it anyway
                    ctx.strokeStyle = 'rgba(0,0,0,1)';
                    
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    
                    // Reset composite operation for next draw
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    // Pen: Enhanced ink rendering with smoothing and pressure
                    ctx.globalCompositeOperation = 'source-over';
                    drawSmoothStroke(ctx, points, pressureHistory, toolSize);
                }

                // Update presentation window in real-time with advanced stroke data
                updatePresentationWindowRealtime(points, pressureHistory, toolSize, currentTool, currentColor);

                lastX = currentX;
                lastY = currentY;
                
                // Update pressure indicator (but only for pen tool)
                if (currentTool === 'pen') {
                    updatePressureIndicator(pressure);
                }
            }
            
            // Advanced smooth stroke rendering function
            function drawSmoothStroke(ctx, points, pressureHistory, baseSize) {
                if (points.length < 2) return;
                
                // Smooth pressure calculation
                const avgPressure = pressureHistory.reduce((sum, p) => sum + p, 0) / pressureHistory.length;
                const smoothPressure = pressureEnabled ? avgPressure : 0.7;
                
                // Calculate dynamic line width with pressure (ultra-high sensitivity)
                const pressureMultiplier = pressureEnabled ? (0.05 + (smoothPressure * 4.5)) : 1.0;
                const dynamicWidth = baseSize * pressureMultiplier;
                
                // Use solid, opaque color - no transparency
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = dynamicWidth;
                
                // Smooth curve drawing using quadratic curves
                if (points.length >= 3) {
                    const p0 = points[points.length - 3];
                    const p1 = points[points.length - 2];
                    const p2 = points[points.length - 1];
                    
                    // Calculate control point for smooth curve
                    const midPoint1 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
                    const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                    
                    ctx.beginPath();
                    ctx.moveTo(midPoint1.x, midPoint1.y);
                    ctx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
                    ctx.stroke();
                } else if (points.length === 2) {
                    // Fallback for first stroke segment
                    const p1 = points[0];
                    const p2 = points[1];
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
            
            // Helper function to convert hex color to rgba
            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function stopDrawing(e) {
                // Only allow pen/stylus input for drawing
                if (e.pointerType !== 'pen') return;
                
                if (isDrawing) {
                    isDrawing = false;
                    
                    // Save drawing data at current canvas resolution for perfect quality preservation
                    // No scaling = no quality loss
                    drawingData[currentPage] = {
                        imageData: canvas.toDataURL('image/png', 1.0), // Maximum quality PNG
                        canvasWidth: canvas.width,
                        canvasHeight: canvas.height
                    };
                    
                    // Hide eraser indicator
                    hideEraserIndicator();
                    
                    // Reset pressure indicator
                    updatePressureIndicator(0);
                    
                    // Reset speed tracking
                    resetSpeedTracking();
                }
            }

            function showEraserIndicator(clientX, clientY, size = null) {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator) {
                    const eraserSize = size || currentDynamicEraserSize || currentEraserSize;
                    indicator.style.width = eraserSize + 'px';
                    indicator.style.height = eraserSize + 'px';
                    indicator.style.left = (clientX - eraserSize/2) + 'px';
                    indicator.style.top = (clientY - eraserSize/2) + 'px';
                    indicator.style.display = 'block';
                }
            }

            function updateEraserIndicator(clientX, clientY, size = null) {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator && indicator.style.display === 'block') {
                    const eraserSize = size || currentDynamicEraserSize || currentEraserSize;
                    indicator.style.width = eraserSize + 'px';
                    indicator.style.height = eraserSize + 'px';
                    indicator.style.left = (clientX - eraserSize/2) + 'px';
                    indicator.style.top = (clientY - eraserSize/2) + 'px';
                }
            }

            function hideEraserIndicator() {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }
        }

        function updatePressureIndicator(pressure) {
            const indicator = document.getElementById('pressureIndicator');
            if (indicator) {
                const percentage = Math.round(pressure * 100);
                indicator.textContent = `Pressure: ${percentage}%`;
            }
        }

        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                
                // Reset speed tracking when changing pages to ensure consistent eraser behavior
                resetSpeedTracking();
                
                // Update page navigation UI
                updatePageNavigation();
                
                // Start transitions in both windows simultaneously
                renderPage(currentPage, true, direction); // Main window fade transition
                
                // Trigger presentation window fade transition if open
                if (presentationWindow && !presentationWindow.closed) {
                    triggerPresentationFadeTransition(currentPage, direction);
                }
            }
        }

        // Update page navigation UI
        function updatePageNavigation() {
            // Update page numbers
            document.getElementById('currentPageNum').textContent = currentPage;
            document.getElementById('totalPagesNum').textContent = totalPages;
            
            // Update button states
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            // Disable previous button if on first page
            if (currentPage <= 1) {
                prevBtn.disabled = true;
                prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                prevBtn.disabled = false;
                prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
            
            // Disable next button if on last page
            if (currentPage >= totalPages) {
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                nextBtn.disabled = false;
                nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
            
            // Update thumbnail selection if modal is open
            updateThumbnailSelection();
        }

        // Page Thumbnail Modal Functions
        async function openPageThumbnailModal() {
            if (!pdfDoc) return;

            const modal = document.getElementById('pageThumbnailModal');
            const backdrop = document.getElementById('modalBackdrop');
            const container = document.getElementById('thumbnailContainer');

            // Show backdrop
            backdrop.classList.remove('hidden');

            // Always regenerate thumbnails for better quality (force refresh)
            await generatePageThumbnails();

            // Update current page selection
            updateThumbnailSelection();

            // Show modal with slide animation
            setTimeout(() => {
                modal.classList.add('open');
            }, 10);

            // Scroll to current page
            scrollToCurrentThumbnail();
        }

        function closePageThumbnailModal() {
            const modal = document.getElementById('pageThumbnailModal');
            const backdrop = document.getElementById('modalBackdrop');

            // Hide modal with slide animation
            modal.classList.remove('open');

            // Hide backdrop after animation
            setTimeout(() => {
                backdrop.classList.add('hidden');
            }, 300);
        }

        async function generatePageThumbnails() {
            const container = document.getElementById('thumbnailContainer');
            container.innerHTML = '<div class="text-center py-8"><div class="text-gray-500 dark:text-gray-400">Generating thumbnails...</div></div>';

            const thumbnails = [];

            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    // Ultra-high quality thumbnails - scale to fit width of ~400px for crisp display
                    const targetWidth = 400;
                    const viewport = page.getViewport({ scale: 1 });
                    const scale = targetWidth / viewport.width;
                    const scaledViewport = page.getViewport({ scale });

                    // Create thumbnail container
                    const thumbnailDiv = document.createElement('div');
                    thumbnailDiv.className = 'page-thumbnail bg-white dark:bg-gray-700 rounded-lg border-2 border-gray-200 dark:border-gray-600 overflow-hidden cursor-pointer';
                    thumbnailDiv.setAttribute('data-page', pageNum);
                    thumbnailDiv.onclick = () => goToPage(pageNum);

                    // Create canvas for PDF with higher resolution
                    const canvas = document.createElement('canvas');
                    canvas.width = scaledViewport.width;
                    canvas.height = scaledViewport.height;
                    canvas.className = 'w-full h-auto';

                    // Create canvas for drawings overlay with higher resolution
                    const drawingCanvas = document.createElement('canvas');
                    drawingCanvas.width = scaledViewport.width;
                    drawingCanvas.height = scaledViewport.height;
                    drawingCanvas.className = 'absolute top-0 left-0 w-full h-auto';

                    // Container for canvases
                    const canvasContainer = document.createElement('div');
                    canvasContainer.className = 'relative';
                    canvasContainer.appendChild(canvas);
                    canvasContainer.appendChild(drawingCanvas);

                    // Page number label
                    const pageLabel = document.createElement('div');
                    pageLabel.className = 'p-2 text-xs text-center text-gray-600 dark:text-gray-400 border-t border-gray-200 dark:border-gray-600';
                    pageLabel.textContent = `Page ${pageNum}`;

                    thumbnailDiv.appendChild(canvasContainer);
                    thumbnailDiv.appendChild(pageLabel);

                    // Render PDF page with higher quality
                    const renderContext = {
                        canvasContext: canvas.getContext('2d'),
                        viewport: scaledViewport
                    };
                    await page.render(renderContext).promise;

                    // Render drawings if they exist with proper scaling
                    if (drawingData[pageNum]) {
                        const ctx = drawingCanvas.getContext('2d');
                        const img = new Image();
                        img.onload = function() {
                            const scaleX = scaledViewport.width / drawingData[pageNum].canvasWidth;
                            const scaleY = scaledViewport.height / drawingData[pageNum].canvasHeight;
                            
                            ctx.save();
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(img, 0, 0);
                            ctx.restore();
                        };
                        img.src = drawingData[pageNum].imageData;
                    }

                    thumbnails.push(thumbnailDiv);

                } catch (error) {
                    console.error(`Error generating thumbnail for page ${pageNum}:`, error);
                }
            }

            // Clear loading message and add all thumbnails
            container.innerHTML = '';
            thumbnails.forEach(thumb => container.appendChild(thumb));

            // Initialize icons for the thumbnails
            initializeLucideIcons();
        }

        function updateThumbnailSelection() {
            const thumbnails = document.querySelectorAll('.page-thumbnail');
            thumbnails.forEach(thumb => {
                const pageNum = parseInt(thumb.getAttribute('data-page'));
                if (pageNum === currentPage) {
                    thumb.classList.add('current');
                } else {
                    thumb.classList.remove('current');
                }
            });
        }

        function scrollToCurrentThumbnail() {
            const container = document.getElementById('thumbnailContainer');
            const currentThumbnail = container.querySelector(`[data-page="${currentPage}"]`);
            
            if (currentThumbnail) {
                // Scroll to center the current thumbnail
                const containerHeight = container.clientHeight;
                const thumbnailTop = currentThumbnail.offsetTop;
                const thumbnailHeight = currentThumbnail.offsetHeight;
                
                const scrollPosition = thumbnailTop - (containerHeight / 2) + (thumbnailHeight / 2);
                container.scrollTo({
                    top: Math.max(0, scrollPosition),
                    behavior: 'smooth'
                });
            }
        }

        function goToPage(pageNum) {
            if (pageNum >= 1 && pageNum <= totalPages && pageNum !== currentPage) {
                const direction = pageNum > currentPage ? 1 : -1;
                currentPage = pageNum;
                
                // Update page navigation UI
                updatePageNavigation();
                
                // Start transitions in both windows
                renderPage(currentPage, true, direction);
                
                // Trigger presentation window fade transition if open
                if (presentationWindow && !presentationWindow.closed) {
                    triggerPresentationFadeTransition(currentPage, direction);
                }
                
                // Close the modal
                closePageThumbnailModal();
            }
        }

        // Presentation Mode Functions
        async function openPresentationMode() {
            if (!pdfDoc || !pdfArrayBuffer) {
                showCustomAlert('Please load a PDF first before opening presentation mode.');
                return;
            }

            // Check if presentation window is already open
            if (presentationWindow && !presentationWindow.closed) {
                showConfirmDialog('Close the presentation window?', () => {
                    presentationWindow.close();
                    presentationWindow = null;
                });
                return;
            }

            // Try to get secondary monitor information
            let windowFeatures = await getSecondaryMonitorWindowFeatures();
            
            // Open new presentation window
            presentationWindow = window.open('about:blank', 'PDFPresentation', windowFeatures);
            
            if (presentationWindow) {
                // Handle presentation window close
                presentationWindow.addEventListener('beforeunload', () => {
                    presentationWindow = null;
                });
                
                // Create and inject presentation HTML
                const presentationHTML = createPresentationHTML();
                presentationWindow.document.write(presentationHTML);
                presentationWindow.document.close();
                
                // Use a different approach - wait for the window's load event
                presentationWindow.addEventListener('load', () => {
                    // Additional wait to ensure PDF.js is loaded
                    setTimeout(() => {
                        initializePresentationWindow();
                    }, 300);
                });
                
                // Backup initialization in case load event doesn't fire
                setTimeout(() => {
                    if (presentationWindow && !presentationWindow.closed) {
                        initializePresentationWindow();
                    }
                }, 1000);
                
            } else {
                showCustomAlert('Unable to open presentation window. Please allow popups for this site.');
            }
        }

        // Initialize presentation window with PDF data
        function initializePresentationWindow() {
            if (!presentationWindow || presentationWindow.closed) return;
            
            try {
                // Use postMessage for more reliable cross-window communication
                const initData = {
                    type: 'INIT_PDF',
                    pdfArrayBuffer: pdfArrayBuffer,
                    currentPage: currentPage,
                    totalPages: totalPages,
                    drawingData: drawingData
                };
                
                presentationWindow.postMessage(initData, '*');
                
            } catch (error) {
                console.error('Error initializing presentation window:', error);
                // Fallback to direct property assignment
                try {
                    presentationWindow.pdfArrayBuffer = pdfArrayBuffer;
                    presentationWindow.currentPage = currentPage;
                    presentationWindow.totalPages = totalPages;
                    presentationWindow.drawingData = drawingData;
                    
                    presentationWindow.eval(`
                        if (typeof initializePDF === 'function') {
                            initializePDF();
                        }
                    `);
                } catch (fallbackError) {
                    console.error('Fallback initialization also failed:', fallbackError);
                }
            }
        }

        function createPresentationHTML() {
            return '<!DOCTYPE html>' +
                '<html lang="en">' +
                '<head>' +
                    '<meta charset="UTF-8">' +
                    '<meta name="viewport" content="width=device-width, initial-scale=1.0">' +
                    '<title>PDF Presentation</title>' +
                    '<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"><\/script>' +
                    '<style>' +
                        'body {' +
                            'margin: 0;' +
                            'padding: 0;' +
                            'background: #000;' +
                            'display: flex;' +
                            'justify-content: center;' +
                            'align-items: center;' +
                            'min-height: 100vh;' +
                            'overflow: hidden;' +
                        '}' +
                        '#presentationContent {' +
                            'display: flex;' +
                            'justify-content: center;' +
                            'align-items: center;' +
                            'width: 100%;' +
                            'height: 100vh;' +
                        '}' +
                        '.pdf-page-container {' +
                            'position: relative;' +
                        '}' +
                        '.presentation-canvas {' +
                            'position: absolute;' +
                            'top: 0;' +
                            'left: 0;' +
                        '}' +
                        '#fullscreenBtn {' +
                            'position: fixed;' +
                            'top: 20px;' +
                            'right: 20px;' +
                            'z-index: 1000;' +
                            'background: rgba(255, 255, 255, 0.9);' +
                            'border: none;' +
                            'border-radius: 8px;' +
                            'padding: 12px 16px;' +
                            'cursor: pointer;' +
                            'font-size: 14px;' +
                            'font-weight: 600;' +
                            'color: #374151;' +
                            'box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);' +
                            'transition: all 0.2s ease;' +
                            'display: flex;' +
                            'align-items: center;' +
                            'gap: 8px;' +
                        '}' +
                        '#fullscreenBtn:hover {' +
                            'background: rgba(255, 255, 255, 1);' +
                            'transform: translateY(-1px);' +
                            'box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);' +
                        '}' +
                        '#fullscreenBtn:active {' +
                            'transform: translateY(0);' +
                        '}' +
                        '#fullscreenBtn svg {' +
                            'width: 16px;' +
                            'height: 16px;' +
                        '}' +
                        '.fullscreen-hidden {' +
                            'opacity: 0;' +
                            'pointer-events: none;' +
                            'transform: translateY(-10px);' +
                        '}' +
                    '</style>' +
                '</head>' +
                '<body>' +
                    '<button id="fullscreenBtn" onclick="enterFullscreen()">' +
                        '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>' +
                        '</svg>' +
                        'Fullscreen' +
                    '</button>' +
                    '<div id="presentationContent"></div>' +
                    '<script>' +
                        'pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";' +
                        'window.addEventListener("resize", () => {' +
                            'if (window.currentRenderFunction) {' +
                                'window.currentRenderFunction();' +
                            '}' +
                        '});' +
                        'window.addEventListener("message", async function(event) {' +
                            'if (event.data && event.data.type === "INIT_PDF") {' +
                                'try {' +
                                    'window.pdfArrayBuffer = event.data.pdfArrayBuffer;' +
                                    'window.currentPage = event.data.currentPage;' +
                                    'window.totalPages = event.data.totalPages;' +
                                    'window.drawingData = event.data.drawingData;' +
                                    'if (window.pdfArrayBuffer) {' +
                                        'window.presentationPdfDoc = await pdfjsLib.getDocument(window.pdfArrayBuffer).promise;' +
                                        'window.renderPresentationPage(window.currentPage);' +
                                    '}' +
                                '} catch (error) {' +
                                    'console.error("Error handling postMessage:", error);' +
                                '}' +
                            '} else if (event.data && event.data.type === "RENDER_PAGE") {' +
                                'try {' +
                                    'window.drawingData = event.data.drawingData;' +
                                    'window.renderPresentationPage(event.data.targetPageNum);' +
                                '} catch (error) {' +
                                    'console.error("Error handling page render:", error);' +
                                '}' +
                            '}' +
                        '});' +
                        'window.initializePDF = async function() {' +
                            'try {' +
                                'if (window.pdfArrayBuffer) {' +
                                    'window.presentationPdfDoc = await pdfjsLib.getDocument(window.pdfArrayBuffer).promise;' +
                                    'window.renderPresentationPage(window.currentPage || 1);' +
                                '}' +
                            '} catch (error) {' +
                                'console.error("Error in initializePDF:", error);' +
                            '}' +
                        '};' +
                        'window.renderPresentationPage = async function(pageNum) {' +
                            'if (!window.presentationPdfDoc) return;' +
                            'try {' +
                                'const page = await window.presentationPdfDoc.getPage(pageNum);' +
                                'const container = document.getElementById("presentationContent");' +
                                'const windowWidth = window.innerWidth;' +
                                'const windowHeight = window.innerHeight;' +
                                'const viewport = page.getViewport({ scale: 1 });' +
                                'const scaleX = windowWidth / viewport.width;' +
                                'const scaleY = windowHeight / viewport.height;' +
                                'const displayScale = scaleX;' +
                                'const renderScale = displayScale * 4;' +
                                'const scaledViewport = page.getViewport({ scale: renderScale });' +
                                'const displayWidth = Math.floor(viewport.width * displayScale);' +
                                'const displayHeight = Math.floor(viewport.height * displayScale);' +
                                'const pageContainer = document.createElement("div");' +
                                'pageContainer.className = "pdf-page-container";' +
                                'pageContainer.style.width = displayWidth + "px";' +
                                'pageContainer.style.height = displayHeight + "px";' +
                                'const pdfCanvas = document.createElement("canvas");' +
                                'pdfCanvas.width = scaledViewport.width;' +
                                'pdfCanvas.height = scaledViewport.height;' +
                                'pdfCanvas.style.width = displayWidth + "px";' +
                                'pdfCanvas.style.height = displayHeight + "px";' +
                                'pdfCanvas.style.display = "block";' +
                                'const drawingCanvas = document.createElement("canvas");' +
                                'drawingCanvas.className = "presentation-canvas";' +
                                'drawingCanvas.width = displayWidth;' +
                                'drawingCanvas.height = displayHeight;' +
                                'drawingCanvas.style.width = displayWidth + "px";' +
                                'drawingCanvas.style.height = displayHeight + "px";' +
                                'container.innerHTML = "";' +
                                'pageContainer.appendChild(pdfCanvas);' +
                                'pageContainer.appendChild(drawingCanvas);' +
                                'container.appendChild(pageContainer);' +
                                'const renderContext = {' +
                                    'canvasContext: pdfCanvas.getContext("2d"),' +
                                    'viewport: scaledViewport' +
                                '};' +
                                'await page.render(renderContext).promise;' +
                                'if (window.drawingData && window.drawingData[pageNum]) {' +
                                    'const ctx = drawingCanvas.getContext("2d");' +
                                    'const img = new Image();' +
                                    'img.onload = function() {' +
                                        'const scaleX = displayWidth / window.drawingData[pageNum].canvasWidth;' +
                                        'const scaleY = displayHeight / window.drawingData[pageNum].canvasHeight;' +
                                        'ctx.save();' +
                                        'ctx.scale(scaleX, scaleY);' +
                                        'ctx.drawImage(img, 0, 0);' +
                                        'ctx.restore();' +
                                    '};' +
                                    'img.src = window.drawingData[pageNum].imageData;' +
                                '}' +
                                'window.currentRenderFunction = () => window.renderPresentationPage(pageNum);' +
                            '} catch (error) {' +
                                'console.error("Error rendering presentation page:", error);' +
                            '}' +
                        '};' +
                        'window.performPresentationFadeTransition = async function(targetPageNum, direction) {' +
                            'if (!window.presentationPdfDoc) return;' +
                            'try {' +
                                'const container = document.getElementById("presentationContent");' +
                                'const currentPageElement = container.firstElementChild;' +
                                'const windowWidth = window.innerWidth;' +
                                'const windowHeight = window.innerHeight;' +
                                'const targetPage = await window.presentationPdfDoc.getPage(targetPageNum);' +
                                'const viewport = targetPage.getViewport({ scale: 1 });' +
                                'const scaleX = windowWidth / viewport.width;' +
                                'const scaleY = windowHeight / viewport.height;' +
                                'const displayScale = scaleX;' +
                                'const renderScale = displayScale * 4;' +
                                'const scaledViewport = targetPage.getViewport({ scale: renderScale });' +
                                'const displayWidth = Math.floor(viewport.width * displayScale);' +
                                'const displayHeight = Math.floor(viewport.height * displayScale);' +
                                'const newPageContainer = document.createElement("div");' +
                                'newPageContainer.className = "pdf-page-container";' +
                                'newPageContainer.style.cssText = `width: ${displayWidth}px; height: ${displayHeight}px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0; transition: opacity 0.5s ease-in-out;`;' +
                                'const pdfCanvas = document.createElement("canvas");' +
                                'pdfCanvas.width = scaledViewport.width;' +
                                'pdfCanvas.height = scaledViewport.height;' +
                                'pdfCanvas.style.width = displayWidth + "px";' +
                                'pdfCanvas.style.height = displayHeight + "px";' +
                                'pdfCanvas.style.display = "block";' +
                                'const drawingCanvas = document.createElement("canvas");' +
                                'drawingCanvas.className = "presentation-canvas";' +
                                'drawingCanvas.width = displayWidth;' +
                                'drawingCanvas.height = displayHeight;' +
                                'drawingCanvas.style.width = displayWidth + "px";' +
                                'drawingCanvas.style.height = displayHeight + "px";' +
                                'newPageContainer.appendChild(pdfCanvas);' +
                                'newPageContainer.appendChild(drawingCanvas);' +
                                'const renderContext = { canvasContext: pdfCanvas.getContext("2d"), viewport: scaledViewport };' +
                                'await targetPage.render(renderContext).promise;' +
                                'if (window.drawingData && window.drawingData[targetPageNum]) {' +
                                    'const ctx = drawingCanvas.getContext("2d");' +
                                    'const img = new Image();' +
                                    'img.onload = function() {' +
                                        'const scaleX = displayWidth / window.drawingData[targetPageNum].canvasWidth;' +
                                        'const scaleY = displayHeight / window.drawingData[targetPageNum].canvasHeight;' +
                                        'ctx.save();' +
                                        'ctx.scale(scaleX, scaleY);' +
                                        'ctx.drawImage(img, 0, 0);' +
                                        'ctx.restore();' +
                                    '};' +
                                    'img.src = window.drawingData[targetPageNum].imageData;' +
                                '}' +
                                'if (currentPageElement) {' +
                                    'currentPageElement.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 1; transition: opacity 0.5s ease-in-out;`;' +
                                '}' +
                                'container.appendChild(newPageContainer);' +
                                'newPageContainer.offsetHeight;' +
                                'if (currentPageElement) {' +
                                    'currentPageElement.style.opacity = "0";' +
                                '}' +
                                'newPageContainer.style.opacity = "1";' +
                                'await new Promise(resolve => setTimeout(resolve, 500));' +
                                'container.innerHTML = "";' +
                                'newPageContainer.style.cssText = `width: ${scaledViewport.width}px; height: ${scaledViewport.height}px; position: relative; opacity: 1;`;' +
                                'container.appendChild(newPageContainer);' +
                                'window.currentRenderFunction = () => window.renderPresentationPage(targetPageNum);' +
                            '} catch (error) {' +
                                'console.error("Error in presentation fade transition:", error);' +
                            '}' +
                        '};' +
                        'function enterFullscreen() {' +
                            'const btn = document.getElementById("fullscreenBtn");' +
                            'if (document.documentElement.requestFullscreen) {' +
                                'document.documentElement.requestFullscreen().then(() => {' +
                                    'btn.classList.add("fullscreen-hidden");' +
                                '}).catch(err => {' +
                                    'console.error("Error entering fullscreen:", err);' +
                                '});' +
                            '} else if (document.documentElement.webkitRequestFullscreen) {' +
                                'document.documentElement.webkitRequestFullscreen();' +
                                'btn.classList.add("fullscreen-hidden");' +
                            '} else if (document.documentElement.msRequestFullscreen) {' +
                                'document.documentElement.msRequestFullscreen();' +
                                'btn.classList.add("fullscreen-hidden");' +
                            '}' +
                        '}' +
                        'document.addEventListener("fullscreenchange", handleFullscreenChange);' +
                        'document.addEventListener("webkitfullscreenchange", handleFullscreenChange);' +
                        'document.addEventListener("msfullscreenchange", handleFullscreenChange);' +
                        'function handleFullscreenChange() {' +
                            'const btn = document.getElementById("fullscreenBtn");' +
                            'const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);' +
                            'if (isFullscreen) {' +
                                'btn.classList.add("fullscreen-hidden");' +
                            '} else {' +
                                'btn.classList.remove("fullscreen-hidden");' +
                            '}' +
                            'setTimeout(() => {' +
                                'if (window.currentRenderFunction) {' +
                                    'window.currentRenderFunction();' +
                                '}' +
                            '}, 100);' +
                        '}' +
                    '<\/script>' +
                '</body>' +
                '</html>';
        }

        async function renderPresentationPage(pageNum) {
            if (!presentationWindow || presentationWindow.closed || !pdfDoc) return;

            try {
                const page = await pdfDoc.getPage(pageNum);
                const container = presentationWindow.document.getElementById('presentationContent');
                
                // Calculate scale to fit the presentation window
                const windowWidth = presentationWindow.innerWidth;
                const windowHeight = presentationWindow.innerHeight;
                const viewport = page.getViewport({ scale: 1 });
                
                // Scale to fit both width and height with some padding
                const scaleX = (windowWidth - 40) / viewport.width;
                const scaleY = (windowHeight - 40) / viewport.height;
                const scale = Math.min(scaleX, scaleY);
                
                const scaledViewport = page.getViewport({ scale });

                // Create page container
                const pageContainer = presentationWindow.document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.style.width = scaledViewport.width + 'px';
                pageContainer.style.height = scaledViewport.height + 'px';

                // Create and setup PDF canvas
                const pdfCanvas = presentationWindow.document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;
                pdfCanvas.height = scaledViewport.height;
                pdfCanvas.style.display = 'block';

                // Create and setup presentation canvas for drawings
                const drawingCanvas = presentationWindow.document.createElement('canvas');
                drawingCanvas.className = 'presentation-canvas';
                drawingCanvas.width = scaledViewport.width;
                drawingCanvas.height = scaledViewport.height;

                // Clear container and add new elements
                container.innerHTML = '';
                pageContainer.appendChild(pdfCanvas);
                pageContainer.appendChild(drawingCanvas);
                container.appendChild(pageContainer);

                // Render PDF page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;

                // Restore drawing data for this page with proper scaling
                if (drawingData[pageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    const img = new Image();
                    img.onload = function() {
                        // Calculate scaling factors based on canvas size changes
                        const scaleX = scaledViewport.width / drawingData[pageNum].canvasWidth;
                        const scaleY = scaledViewport.height / drawingData[pageNum].canvasHeight;
                        
                        // Scale and draw the image to fit the new canvas size
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                    };
                    img.src = drawingData[pageNum].imageData;
                }

                // Store render function for window resize
                presentationWindow.currentRenderFunction = () => renderPresentationPage(pageNum);

            } catch (error) {
                console.error('Error rendering presentation page:', error);
            }
        }

        function updatePresentationWindow() {
            if (presentationWindow && !presentationWindow.closed) {
                try {
                    // Update drawing data in presentation window
                    presentationWindow.drawingData = drawingData;
                    presentationWindow.currentPage = currentPage;
                    
                    // Call the presentation window's render function
                    presentationWindow.renderPresentationPage(currentPage);
                } catch (error) {
                    console.error('Error updating presentation window:', error);
                }
            }
        }

        // Update presentation window page (simplified, no transitions to avoid black screen)
        function triggerPresentationFadeTransition(targetPageNum, direction) {
            if (!presentationWindow || presentationWindow.closed) return;

            try {
                // Send simple render message (no complex transitions)
                presentationWindow.postMessage({
                    type: 'RENDER_PAGE',
                    targetPageNum: targetPageNum,
                    drawingData: drawingData
                }, '*');
            } catch (error) {
                console.error('Error updating presentation window:', error);
                // Fallback: direct function call
                try {
                    presentationWindow.drawingData = drawingData;
                    presentationWindow.renderPresentationPage(targetPageNum);
                } catch (fallbackError) {
                    console.error('Fallback presentation update failed:', fallbackError);
                }
            }
        }

        // Store presentation window stroke data
        let presentationStrokeData = {
            points: [],
            pressureHistory: [],
            isDrawing: false
        };

        // Real-time presentation window update for drawing - Enhanced with same advanced stroke rendering as main window
        function updatePresentationWindowRealtime(points, pressureHistory, toolSize, tool, color) {
            if (!presentationWindow || presentationWindow.closed) return;

            try {
                const container = presentationWindow.document.getElementById('presentationContent');
                const drawingCanvas = container.querySelector('.presentation-canvas');
                if (!drawingCanvas) return;

                const ctx = drawingCanvas.getContext('2d');
                const mainCanvas = document.querySelector('.drawing-canvas');
                
                if (!mainCanvas) return;

                // Calculate scaling factors between main canvas and presentation canvas
                const scaleX = drawingCanvas.width / mainCanvas.width;
                const scaleY = drawingCanvas.height / mainCanvas.height;
                const scaleFactor = Math.min(scaleX, scaleY);

                // Apply enhanced ink quality settings (same as main window)
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Scale points to presentation window coordinates
                const scaledPoints = points.map(point => ({
                    x: point.x * scaleX,
                    y: point.y * scaleY,
                    pressure: point.pressure
                }));

                if (tool === 'eraser') {
                    // Eraser: Use destination-out to remove pixels
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.strokeStyle = 'rgba(0,0,0,1)';
                    ctx.lineWidth = toolSize * scaleFactor;
                    
                    if (scaledPoints.length >= 2) {
                        const lastPoint = scaledPoints[scaledPoints.length - 2];
                        const currentPoint = scaledPoints[scaledPoints.length - 1];
                        
                        ctx.beginPath();
                        ctx.moveTo(lastPoint.x, lastPoint.y);
                        ctx.lineTo(currentPoint.x, currentPoint.y);
                        ctx.stroke();
                    }
                    
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    // Pen: Use the same advanced smooth stroke rendering as main window
                    drawPresentationSmoothStroke(ctx, scaledPoints, pressureHistory, toolSize * scaleFactor, color);
                }

            } catch (error) {
                console.error('Error updating presentation window in real-time:', error);
            }
        }

        // Advanced smooth stroke rendering function for presentation window (identical to main window)
        function drawPresentationSmoothStroke(ctx, points, pressureHistory, baseSize, color) {
            if (points.length < 2) return;
            
            // Smooth pressure calculation
            const avgPressure = pressureHistory.reduce((sum, p) => sum + p, 0) / pressureHistory.length;
            const smoothPressure = pressureEnabled ? avgPressure : 0.7;
            
            // Calculate dynamic line width with pressure (enhanced sensitivity)
            const pressureMultiplier = pressureEnabled ? (0.1 + (smoothPressure * 3.0)) : 1.0;
            const dynamicWidth = baseSize * pressureMultiplier;
            
            // Use solid, opaque color - no transparency
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = color;
            ctx.lineWidth = dynamicWidth;
            
            // Smooth curve drawing using quadratic curves (identical to main window)
            if (points.length >= 3) {
                const p0 = points[points.length - 3];
                const p1 = points[points.length - 2];
                const p2 = points[points.length - 1];
                
                // Calculate control point for smooth curve
                const midPoint1 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
                const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                
                ctx.beginPath();
                ctx.moveTo(midPoint1.x, midPoint1.y);
                ctx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
                ctx.stroke();
            } else if (points.length === 2) {
                // Fallback for first stroke segment
                const p1 = points[0];
                const p2 = points[1];
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }

        function closePDF() {
            // Show upload area and header, hide PDF viewer
            document.getElementById('uploadArea').style.display = 'block';
            document.querySelector('header').style.display = 'block';
            document.getElementById('pdfViewer').classList.add('hidden');
            
            // Reset state
            pdfDoc = null;
            currentPage = 1;
            totalPages = 0;
            drawingData = {};
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('pdfUpload').value = '';
        }

        function setTool(tool) {
            currentTool = tool;
            
            // Update tool buttons
            document.querySelectorAll('#penTool, #eraserTool').forEach(btn => {
                btn.classList.remove('tool-active');
            });
            
            if (tool === 'pen') {
                document.getElementById('penTool').classList.add('tool-active');
            } else if (tool === 'eraser') {
                document.getElementById('eraserTool').classList.add('tool-active');
            }

            // Update cursor
            const canvas = document.querySelector('.drawing-canvas');
            if (canvas) {
                canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            }
            

            
            // Reset speed tracking when changing tools
            resetSpeedTracking();
        }



        function setColor(color) {
            currentColor = color;
            
            // Update color indicator
            const colorIndicator = document.getElementById('colorIndicator');
            if (colorIndicator) {
                colorIndicator.style.backgroundColor = color;
            }
            
            // Close modal after selection
            hideSettingsModal();
        }

        function clearCanvas() {
            showConfirmDialog('Are you sure you want to clear all drawings on this page?', () => {
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    delete drawingData[currentPage];
                    
                    // Clear presentation window canvas in real-time
                    clearPresentationCanvas();
                }
            });
        }

        // Clear presentation window canvas
        function clearPresentationCanvas() {
            if (!presentationWindow || presentationWindow.closed) return;

            try {
                const container = presentationWindow.document.getElementById('presentationContent');
                const drawingCanvas = container.querySelector('.presentation-canvas');
                if (drawingCanvas) {
                    const ctx = drawingCanvas.getContext('2d');
                    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                }
            } catch (error) {
                console.error('Error clearing presentation canvas:', error);
            }
        }

        async function downloadPDF() {
            if (!pdfDoc) return;

            try {
                if (drawingData[currentPage]) {
                    const link = document.createElement('a');
                    link.download = `pdf-drawing-page-${currentPage}.png`;
                    link.href = drawingData[currentPage].imageData;
                    link.click();
                } else {
                    showCustomAlert('No drawings found on current page to download.');
                }
                
            } catch (error) {
                console.error('Error downloading:', error);
                showCustomAlert('Error downloading the file.');
            }
        }

        // Fullscreen functionality for Android devices
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    // Safari
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) {
                    // IE/Edge
                    element.msRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    // Firefox
                    element.mozRequestFullScreen();
                }
                
                // Update icon to minimize
                updateFullscreenIcon(true);
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                }
                
                // Update icon to maximize
                updateFullscreenIcon(false);
            }
        }

        function updateFullscreenIcon(isFullscreen) {
            const icon = document.querySelector('#fullscreenBtn i');
            if (icon) {
                if (isFullscreen) {
                    icon.setAttribute('data-lucide', 'minimize');
                } else {
                    icon.setAttribute('data-lucide', 'maximize');
                }
                // Reinitialize icons to update the display
                initializeLucideIcons();
            }
        }

        // Listen for fullscreen changes to update the icon
        document.addEventListener('fullscreenchange', () => {
            updateFullscreenIcon(!!document.fullscreenElement);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            updateFullscreenIcon(!!document.webkitFullscreenElement);
        });
        document.addEventListener('msfullscreenchange', () => {
            updateFullscreenIcon(!!document.msFullscreenElement);
        });
        document.addEventListener('mozfullscreenchange', () => {
            updateFullscreenIcon(!!document.mozFullScreenElement);
        });

        // Custom dialog functions (replacing alert/confirm)
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-primary text-white hover:bg-primary/90 rounded text-base" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showConfirmDialog(message, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base" onclick="this.closest('.fixed').remove()">Cancel</button>
                        <button class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded text-base" onclick="this.closest('.fixed').remove(); (${onConfirm})()">Confirm</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Initialize Lucide icons
        function initializeLucideIcons() {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                // Retry after a short delay if Lucide isn't loaded yet
                setTimeout(initializeLucideIcons, 100);
            }
        }

        // Initialize icons when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeLucideIcons();
            setupSettingsListeners();
            // Initialize brush and eraser size visual selections
            updateBrushSizeSelection();
            updateEraserSizeSelection();
        });
        
        // Also initialize when PDF viewer is shown
        const originalRenderPage = renderPage;
        renderPage = async function(pageNum, withTransition = false) {
            await originalRenderPage(pageNum, withTransition);
            initializeLucideIcons();
        };

        // Handle window resize for responsive behavior with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                // Clear existing timeout
                clearTimeout(resizeTimeout);
                
                // Set new timeout to prevent excessive re-rendering
                resizeTimeout = setTimeout(() => {
                    renderPage(currentPage);
                }, 250); // Wait 250ms after resize stops
            }
        });
    </script>



</body></html>
