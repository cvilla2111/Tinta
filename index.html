<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotation App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'md-primary': '#6750A4',
                        'md-on-primary': '#FFFFFF',
                        'md-primary-container': '#EADDFF',
                        'md-on-primary-container': '#21005D',
                        'md-surface': '#FEF7FF',
                        'md-on-surface': '#1D1B20',
                        'md-surface-variant': '#E7E0EC',
                        'md-on-surface-variant': '#49454F',
                        'md-outline': '#79747E',
                        'md-surface-container': '#F3EDF7',
                        'md-surface-container-high': '#ECE6F0',
                    }
                }
            },
            darkMode: 'class'
        }

        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        .md-elevation-3 {
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.30), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
        }
        .md-elevation-1 {
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.30), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
        }
        .annotation-canvas {
            touch-action: none;
        }
        .fullscreen-container {
            background: #000;
        }
        .thumbnail-container {
            background: linear-gradient(135deg, #f3edf7 0%, #e7e0ec 100%);
        }
        .dark .thumbnail-container {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        }
    </style>
</head>
<body class="bg-md-surface dark:bg-gray-900 text-md-on-surface dark:text-gray-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const PDFAnnotationApp = () => {
            const [pdfDoc, setPdfDoc] = useState(null);
            const [currentPage, setCurrentPage] = useState(1);
            const [totalPages, setTotalPages] = useState(0);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [shouldEnterFullscreen, setShouldEnterFullscreen] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [thumbnailSrc, setThumbnailSrc] = useState(null);
            const [annotations, setAnnotations] = useState(new Map());
            const [fileName, setFileName] = useState('');
            const [selectedColor, setSelectedColor] = useState('#800080');
            const [penSize, setPenSize] = useState(3);
            const [selectedTool, setSelectedTool] = useState('pen');
            const [eraserPosition, setEraserPosition] = useState({ x: 0, y: 0 });
            const [showEraserCircle, setShowEraserCircle] = useState(false);
            const [showColorPicker, setShowColorPicker] = useState(false);
            const [pressureSensitivity, setPressureSensitivity] = useState(1.0);
            const [toolbarMinimized, setToolbarMinimized] = useState(false);
            const [currentEraserSize, setCurrentEraserSize] = useState(15);
            const [smoothedSpeed, setSmoothedSpeed] = useState(0);
            const [eraserMinSize, setEraserMinSize] = useState(1); // Min eraser size in pixels
            const [eraserMaxSize, setEraserMaxSize] = useState(60); // Max eraser size in pixels
            const [speedSensitivity, setSpeedSensitivity] = useState(1.9); // Speed sensitivity factor
            const [speedThreshold, setSpeedThreshold] = useState(50); // Speed threshold in pixels/second to start growing
            const lastMoveTimeRef = useRef(0);
            const lastPositionRef = useRef({ x: 0, y: 0 });
            const lastEraserPositionRef = useRef({ x: 0, y: 0 });
            const speedHistoryRef = useRef([]); // Rolling average for ultra-smooth speed
            const sizeHistoryRef = useRef([]); // Rolling average for ultra-smooth size
            
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const drawingCanvasRef = useRef(null);
            const containerRef = useRef(null);
            const thumbnailRef = useRef(null);
            const lastPointRef = useRef(null);
            const isDrawingRef = useRef(false);

            // Load PDF file
            const loadPDF = async (file) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    setPdfDoc(pdf);
                    setTotalPages(pdf.numPages);
                    setCurrentPage(1);
                    
                    // Generate thumbnail from first page
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const thumbnailCanvas = document.createElement('canvas');
                    const thumbnailCtx = thumbnailCanvas.getContext('2d');
                    thumbnailCanvas.width = viewport.width;
                    thumbnailCanvas.height = viewport.height;
                    
                    await page.render({
                        canvasContext: thumbnailCtx,
                        viewport: viewport
                    }).promise;
                    
                    setThumbnailSrc(thumbnailCanvas.toDataURL());
                    
                    // Enter fullscreen immediately (using the file input user gesture)
                    requestFullscreen();
                } catch (error) {
                    console.error('Error loading PDF:', error);
                }
            };

            // Direct fullscreen request
            const requestFullscreen = () => {
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen().then(() => {
                        setIsFullscreen(true);
                    }).catch(err => {
                        console.log('Fullscreen request failed:', err);
                    });
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                    setIsFullscreen(true);
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                    setIsFullscreen(true);
                }
            };

            // Render PDF page with Canvas overlay for raster drawing
            const renderPage = async (pageNum) => {
                if (!pdfDoc || !canvasRef.current) return;

                const page = await pdfDoc.getPage(pageNum);
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                // Calculate scale to fit full screen width
                const pageViewport = page.getViewport({ scale: 1.0 });
                const scale = window.innerWidth / pageViewport.width;
                const viewport = page.getViewport({ scale });
                
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Clear and render page
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport
                }).promise;

                // Setup drawing canvas overlay
                const drawingCanvas = drawingCanvasRef.current;
                if (drawingCanvas) {
                    drawingCanvas.width = viewport.width;
                    drawingCanvas.height = viewport.height;
                    drawingCanvas.style.width = viewport.width + 'px';
                    drawingCanvas.style.height = viewport.height + 'px';
                    
                    const drawingCtx = drawingCanvas.getContext('2d');
                    drawingCtx.clearRect(0, 0, viewport.width, viewport.height);
                    
                    // Restore annotations for this page from saved image data
                    const pageAnnotations = annotations.get(pageNum);
                    if (pageAnnotations && pageAnnotations.imageData) {
                        const img = new Image();
                        img.onload = () => {
                            drawingCtx.drawImage(img, 0, 0);
                        };
                        img.src = pageAnnotations.imageData;
                    }
                }
            };

            // Fullscreen management
            const enterFullscreen = () => {
                if (containerRef.current) {
                    if (containerRef.current.requestFullscreen) {
                        containerRef.current.requestFullscreen();
                    } else if (containerRef.current.webkitRequestFullscreen) {
                        containerRef.current.webkitRequestFullscreen();
                    } else if (containerRef.current.msRequestFullscreen) {
                        containerRef.current.msRequestFullscreen();
                    }
                }
            };

            const exitFullscreen = () => {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            };

            // Canvas-based drawing functions with perfect pixel erasing
            const startDrawing = (e) => {
                if (!isFullscreen || !drawingCanvasRef.current) return;
                
                // Only allow stylus input
                if (e.pointerType !== 'pen') return;
                
                setIsDrawing(true);
                
                const rect = drawingCanvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const ctx = drawingCanvasRef.current.getContext('2d');
                
                if (selectedTool === 'eraser') {
                    // Eraser mode: erase pixels in circular area
                    eraseAtPoint(ctx, x, y);
                } else {
                    // Drawing mode: start new stroke
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = selectedColor;
                    ctx.lineWidth = penSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Apply tool-specific styles
                    if (selectedTool === 'highlighter') {
                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = Math.max(penSize, 8);
                    } else {
                        ctx.globalAlpha = 1.0;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    lastPointRef.current = { x, y };
                }
            };

            const draw = (e) => {
                if (!isDrawing || !isFullscreen || e.pointerType !== 'pen') return;
                
                const rect = drawingCanvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const ctx = drawingCanvasRef.current.getContext('2d');
                
                if (selectedTool === 'eraser') {
                    // Continue erasing pixels
                    eraseAtPoint(ctx, x, y);
                } else {
                    // Continue drawing stroke
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                }
            };

            const stopDrawing = () => {
                if (!isDrawing) return;
                
                setIsDrawing(false);
                
                // Save the canvas state as image data for this page
                if (drawingCanvasRef.current) {
                    const imageData = drawingCanvasRef.current.toDataURL();
                    setAnnotations(prev => {
                        const newMap = new Map(prev);
                        newMap.set(currentPage, { imageData });
                        return newMap;
                    });
                }
                
                lastPointRef.current = null;
            };

            // Smooth continuous pixel eraser - interpolates between points for seamless erasing
            const eraseAtPoint = (ctx, x, y) => {
                const eraserSize = currentEraserSize;
                
                // Set composite operation to erase pixels
                ctx.globalCompositeOperation = 'destination-out';
                ctx.globalAlpha = 1.0;
                
                // If we have a previous eraser position and we're actively drawing
                if (isDrawing && lastEraserPositionRef.current.x !== 0 && lastEraserPositionRef.current.y !== 0) {
                    const lastX = lastEraserPositionRef.current.x;
                    const lastY = lastEraserPositionRef.current.y;
                    
                    // Calculate distance between points
                    const dx = x - lastX;
                    const dy = y - lastY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only interpolate if points are far apart (high speed movement)
                    if (distance > eraserSize * 0.5) {
                        // Use stroke approach for smooth line erasing
                        ctx.lineWidth = eraserSize * 2;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    } else {
                        // Points are close, just draw circle at current position
                        ctx.beginPath();
                        ctx.arc(x, y, eraserSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // First point or not drawing, just draw circle
                    ctx.beginPath();
                    ctx.arc(x, y, eraserSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Update last eraser position for next interpolation
                lastEraserPositionRef.current = { x, y };
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
            };

            // Handle thumbnail click (any touch/click)
            const handleThumbnailClick = (e) => {
                e.preventDefault();
                requestFullscreen();
            };

            // Navigation
            const nextPage = () => {
                if (currentPage < totalPages) {
                    setCurrentPage(currentPage + 1);
                }
            };

            const prevPage = () => {
                if (currentPage > 1) {
                    setCurrentPage(currentPage - 1);
                }
            };

            // Effects
            useEffect(() => {
                const handleFullscreenChange = () => {
                    setIsFullscreen(!!document.fullscreenElement);
                };

                const handleKeyDown = (e) => {
                    if (isFullscreen && pdfDoc) {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            prevPage();
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            nextPage();
                        } else if (e.key === 'Escape') {
                            // Prevent escape key from exiting fullscreen
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    }
                };

                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                document.addEventListener('msfullscreenchange', handleFullscreenChange);
                document.addEventListener('keydown', handleKeyDown);

                return () => {
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.removeEventListener('msfullscreenchange', handleFullscreenChange);
                    document.removeEventListener('keydown', handleKeyDown);
                };
            }, [isFullscreen, pdfDoc, currentPage, totalPages]);

            // Effect to handle fullscreen trigger
            useEffect(() => {
                if (shouldEnterFullscreen && pdfDoc && containerRef.current) {
                    // Reset the trigger
                    setShouldEnterFullscreen(false);
                    
                    // Enter fullscreen after a brief delay to ensure DOM is ready
                    const timer = setTimeout(() => {
                        enterFullscreen();
                    }, 50);
                    
                    return () => clearTimeout(timer);
                }
            }, [shouldEnterFullscreen, pdfDoc]);

            // Single effect to handle PDF rendering
            useEffect(() => {
                if (pdfDoc && isFullscreen) {
                    const timer = setTimeout(() => {
                        renderPage(currentPage);
                    }, 150);
                    return () => clearTimeout(timer);
                }
            }, [currentPage, pdfDoc, isFullscreen]);

            // Effect to reset eraser size when switching to eraser tool
            useEffect(() => {
                if (selectedTool === 'eraser') {
                    // Reset to minimum size when switching to eraser
                    setCurrentEraserSize(eraserMinSize);
                    setSmoothedSpeed(0);
                    // Reset position tracking
                    lastMoveTimeRef.current = 0;
                    lastPositionRef.current = { x: 0, y: 0 };
                    lastEraserPositionRef.current = { x: 0, y: 0 };
                }
            }, [selectedTool, eraserMinSize]);

            return (
                <div className="min-h-screen bg-md-surface dark:bg-gray-900">
                    {!pdfDoc ? (
                        // Load screen
                        <div className="flex flex-col items-center justify-center min-h-screen p-6 relative">
                            {/* Dark Mode Toggle - Top Right Corner */}
                            <button
                                onClick={() => {
                                    document.documentElement.classList.toggle('dark');
                                }}
                                className="absolute top-6 right-6 w-12 h-12 bg-md-surface-container dark:bg-gray-700 rounded-full shadow-lg flex items-center justify-center hover:scale-110 transition-all md-elevation-1"
                                title="Toggle dark mode"
                            >
                                <span className="text-2xl">
                                    {document.documentElement.classList.contains('dark') ? '☀️' : '🌙'}
                                </span>
                            </button>

                            <div className="bg-md-surface-container dark:bg-gray-800 rounded-3xl p-8 md-elevation-3 max-w-md w-full">
                                <div className="text-center mb-8">
                                    <div className="w-16 h-16 bg-md-primary-container dark:bg-gray-700 rounded-full flex items-center justify-center mx-auto mb-4">
                                        <svg className="w-8 h-8 text-md-on-primary-container dark:text-gray-300" fill="currentColor" viewBox="0 0 24 24">
                                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                                        </svg>
                                    </div>
                                    <h1 className="text-2xl font-bold text-md-on-surface dark:text-gray-100 mb-2">
                                        PDF Annotation
                                    </h1>
                                    <p className="text-md-on-surface-variant dark:text-gray-400">
                                        Load a PDF to start annotating with your stylus
                                    </p>
                                </div>
                                
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    className="w-full bg-md-primary hover:bg-md-primary/90 text-md-on-primary py-4 px-6 rounded-xl font-medium transition-colors md-elevation-1"
                                >
                                    Load PDF
                                </button>
                                
                                <input
                                    ref={fileInputRef}
                                    type="file"
                                    accept=".pdf"
                                    onChange={(e) => {
                                        const file = e.target.files[0];
                                        if (file) {
                                            setFileName(file.name);
                                            loadPDF(file);
                                        }
                                    }}
                                    className="hidden"
                                />
                            </div>
                        </div>
                    ) : isFullscreen ? (
                        // Fullscreen PDF viewer with pill toolbar
                        <div ref={containerRef} className="fullscreen-container relative w-full h-screen flex items-start justify-start overflow-hidden">
                            <div className="relative">
                                <canvas ref={canvasRef} className="block" />
                                <canvas
                                    ref={drawingCanvasRef}
                                    className="absolute top-0 left-0 block"
                                    style={{ 
                                        touchAction: 'none',
                                        cursor: selectedTool === 'eraser' ? 'none' : 'crosshair',
                                        userSelect: 'none',
                                        webkitUserSelect: 'none',
                                        webkitTouchCallout: 'none',
                                        msUserSelect: 'none',
                                        mozUserSelect: 'none',
                                        webkitTapHighlightColor: 'transparent',
                                        msContentZooming: 'none',
                                        msTouchAction: 'none',
                                        msScrollChaining: 'none',
                                        msTouchSelect: 'none'
                                    }}
                                    onPointerDown={startDrawing}
                                    onContextMenu={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        return false;
                                    }}
                                    onSelectStart={(e) => {
                                        e.preventDefault();
                                        return false;
                                    }}
                                    onDragStart={(e) => {
                                        e.preventDefault();
                                        return false;
                                    }}
                                    onPointerMove={(e) => {
                                        // Always update eraser position when eraser is selected
                                        if (selectedTool === 'eraser' && drawingCanvasRef.current) {
                                            const rect = drawingCanvasRef.current.getBoundingClientRect();
                                            const newX = e.clientX - rect.left;
                                            const newY = e.clientY - rect.top;
                                            const currentTime = performance.now();
                                            
                                            // Always show eraser circle at correct position
                                            setEraserPosition({ x: newX, y: newY });
                                            setShowEraserCircle(true);
                                            
                                            // ONLY calculate speed and size when actively drawing (stylus touching screen)
                                            if (isDrawing) {
                                                // Speed-based eraser sizing with configurable threshold
                                                if (lastMoveTimeRef.current > 0 && 
                                                    lastPositionRef.current.x !== 0 && 
                                                    lastPositionRef.current.y !== 0) {
                                                    
                                                    const deltaTime = currentTime - lastMoveTimeRef.current;
                                                    const deltaX = newX - lastPositionRef.current.x;
                                                    const deltaY = newY - lastPositionRef.current.y;
                                                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                                                    
                                                    // Calculate speed in pixels per second (more intuitive unit)
                                                    if (deltaTime > 0 && deltaTime < 50 && distance > 0.5) {
                                                        const currentSpeed = (distance / deltaTime) * 1000; // Convert to pixels/second
                                                        
                                                        // Multi-layer smoothing for ultra-smooth response
                                                        speedHistoryRef.current.push(currentSpeed);
                                                        if (speedHistoryRef.current.length > 6) {
                                                            speedHistoryRef.current.shift();
                                                        }
                                                        
                                                        // Calculate weighted average (recent samples have more weight)
                                                        let weightedSum = 0;
                                                        let totalWeight = 0;
                                                        speedHistoryRef.current.forEach((speed, index) => {
                                                            const weight = (index + 1) / speedHistoryRef.current.length;
                                                            weightedSum += speed * weight;
                                                            totalWeight += weight;
                                                        });
                                                        const avgSpeed = weightedSum / totalWeight;
                                                        
                                                        // Ultra-smooth temporal filtering
                                                        const alpha = Math.min(deltaTime / 20, 0.2);
                                                        const newSmoothedSpeed = smoothedSpeed * (1 - alpha) + avgSpeed * alpha;
                                                        setSmoothedSpeed(newSmoothedSpeed);
                                                        
                                                        // Apply speed threshold - no change below threshold
                                                        if (newSmoothedSpeed > speedThreshold) {
                                                            // Calculate size based on speed above threshold
                                                            const excessSpeed = newSmoothedSpeed - speedThreshold;
                                                            const maxExcessSpeed = 400; // Max speed range above threshold
                                                            const speedRatio = Math.min(excessSpeed / maxExcessSpeed, 1);
                                                            
                                                            // Smooth easing curve for natural feel
                                                            const easedRatio = speedRatio * speedRatio * (3 - 2 * speedRatio); // Smoothstep
                                                            const scaledRatio = easedRatio * speedSensitivity * 0.6;
                                                            
                                                            const targetSize = eraserMinSize + (eraserMaxSize - eraserMinSize) * scaledRatio;
                                                            
                                                            // Smooth interpolation to target size
                                                            const currentSize = currentEraserSize;
                                                            const interpolationSpeed = 0.12;
                                                            const newSize = currentSize * (1 - interpolationSpeed) + targetSize * interpolationSpeed;
                                                            
                                                            setCurrentEraserSize(Math.round(newSize * 10) / 10);
                                                        } else {
                                                            // Below threshold - gentle return to minimum size
                                                            const currentSize = currentEraserSize;
                                                            const returnSize = currentSize * 0.92 + eraserMinSize * 0.08;
                                                            setCurrentEraserSize(Math.max(returnSize, eraserMinSize));
                                                        }
                                                    } else {
                                                        // No meaningful movement - gentle decay toward min
                                                        const currentSize = currentEraserSize;
                                                        const decaySize = currentSize * 0.98 + eraserMinSize * 0.02;
                                                        setCurrentEraserSize(Math.max(decaySize, eraserMinSize));
                                                    }
                                                    
                                                    // Update tracking data
                                                    lastPositionRef.current = { x: newX, y: newY };
                                                    lastMoveTimeRef.current = currentTime;
                                                } else {
                                                    // First touch - start at min size with clean tracking
                                                    setCurrentEraserSize(eraserMinSize);
                                                    setSmoothedSpeed(0);
                                                    speedHistoryRef.current = [];
                                                    lastPositionRef.current = { x: newX, y: newY };
                                                    lastMoveTimeRef.current = currentTime;
                                                }
                                            } else {
                                                // Just hovering - always use min size, no speed calculation
                                                setCurrentEraserSize(eraserMinSize);
                                                // Don't update tracking data when hovering
                                            }
                                        } else {
                                            setShowEraserCircle(false);
                                        }
                                        draw(e);
                                    }}
                                    onPointerUp={stopDrawing}
                                    onPointerLeave={() => {
                                        setShowEraserCircle(false);
                                        stopDrawing();
                                    }}
                                    onPointerEnter={(e) => {
                                        if (selectedTool === 'eraser' && drawingCanvasRef.current) {
                                            const rect = drawingCanvasRef.current.getBoundingClientRect();
                                            setEraserPosition({
                                                x: e.clientX - rect.left,
                                                y: e.clientY - rect.top
                                            });
                                            // Force eraser to correct min size on enter
                                            setCurrentEraserSize(eraserMinSize);
                                            setSmoothedSpeed(0);
                                            // Reset tracking completely
                                            lastMoveTimeRef.current = 0;
                                            lastPositionRef.current = { x: 0, y: 0 };
                                            lastEraserPositionRef.current = { x: 0, y: 0 };
                                            setShowEraserCircle(true);
                                        }
                                    }}
                                />
                                
                                {/* Dynamic Eraser Circle - Size increases with speed, no transitions for smoothness */}
                                {showEraserCircle && selectedTool === 'eraser' && (
                                    <div
                                        className="absolute pointer-events-none"
                                        style={{
                                            left: `${eraserPosition.x - currentEraserSize}px`,
                                            top: `${eraserPosition.y - currentEraserSize}px`,
                                            width: `${currentEraserSize * 2}px`,
                                            height: `${currentEraserSize * 2}px`,
                                            border: '2px dashed #808080',
                                            borderRadius: '50%',
                                            zIndex: 999,
                                            background: 'rgba(128, 128, 128, 0.1)',
                                            transform: 'translateZ(0)', // Hardware acceleration
                                            willChange: 'transform, width, height' // Optimize for changes
                                        }}
                                    />
                                )}
                            </div>
                            
                            {/* Centered Fixed Toolbar */}
                            <div
                                className="fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-gray-900 rounded-full shadow-2xl border border-gray-700"
                                style={{
                                    zIndex: 1000,
                                    userSelect: 'none',
                                    minWidth: '650px',
                                    height: '60px'
                                }}
                            >
                                <div className="flex items-center justify-between h-full px-6 py-2">
                                    {/* Left: Simplified Color Picker */}
                                    <div className="flex items-center gap-3 relative">
                                        <span className="text-white text-xs font-bold">🎨</span>
                                        <button
                                            onClick={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                setShowColorPicker(!showColorPicker);
                                            }}
                                            className="w-10 h-10 rounded-full border-2 border-white shadow-lg transition-all hover:scale-110"
                                            style={{ backgroundColor: selectedColor }}
                                        />
                                        
                                        {/* Enhanced Color Picker Popup */}
                                        {showColorPicker && (
                                            <div className="absolute bottom-16 left-0 bg-gradient-to-br from-gray-800 to-gray-900 rounded-2xl p-4 shadow-2xl border border-gray-600 backdrop-blur-sm">
                                                {/* Header */}
                                                <div className="flex items-center justify-between mb-3">
                                                    <span className="text-white text-sm font-medium">Pick Color</span>
                                                    <button
                                                        onClick={(e) => {
                                                            e.preventDefault();
                                                            e.stopPropagation();
                                                            setShowColorPicker(false);
                                                        }}
                                                        className="text-gray-400 hover:text-white text-lg leading-none"
                                                    >
                                                        ×
                                                    </button>
                                                </div>
                                                
                                                {/* Popular Colors */}
                                                <div className="mb-4">
                                                    <p className="text-gray-300 text-xs mb-2">Popular</p>
                                                    <div className="grid grid-cols-5 gap-2">
                                                        {['#000000', '#FF0000', '#0000FF', '#800080', '#FFA500'].map((color) => (
                                                            <button
                                                                key={color}
                                                                onClick={(e) => {
                                                                    e.preventDefault();
                                                                    e.stopPropagation();
                                                                    setSelectedColor(color);
                                                                    setShowColorPicker(false);
                                                                }}
                                                                className={`w-10 h-10 rounded-lg border-2 transition-all hover:scale-110 shadow-lg ${
                                                                    selectedColor === color ? 'border-white ring-2 ring-blue-400' : 'border-gray-500 hover:border-gray-300'
                                                                }`}
                                                                style={{ backgroundColor: color }}
                                                                title={color}
                                                            />
                                                        ))}
                                                    </div>
                                                </div>
                                                
                                                {/* More Colors */}
                                                <div className="mb-4">
                                                    <p className="text-gray-300 text-xs mb-2">More Colors</p>
                                                    <div className="grid grid-cols-5 gap-2">
                                                        {['#00FF00', '#FFFF00', '#FF00FF', '#00FFFF', '#FFFFFF'].map((color) => (
                                                            <button
                                                                key={color}
                                                                onClick={(e) => {
                                                                    e.preventDefault();
                                                                    e.stopPropagation();
                                                                    setSelectedColor(color);
                                                                    setShowColorPicker(false);
                                                                }}
                                                                className={`w-10 h-10 rounded-lg border-2 transition-all hover:scale-110 shadow-lg ${
                                                                    selectedColor === color ? 'border-white ring-2 ring-blue-400' : 'border-gray-500 hover:border-gray-300'
                                                                }`}
                                                                style={{ backgroundColor: color }}
                                                                title={color}
                                                            />
                                                        ))}
                                                    </div>
                                                </div>
                                                
                                                {/* Custom Color Picker */}
                                                <div>
                                                    <p className="text-gray-300 text-xs mb-2">Custom</p>
                                                    <div className="relative">
                                                        <input
                                                            type="color"
                                                            value={selectedColor}
                                                            onChange={(e) => {
                                                                setSelectedColor(e.target.value);
                                                                setShowColorPicker(false);
                                                            }}
                                                            className="w-full h-12 rounded-lg cursor-pointer border-2 border-gray-500 hover:border-gray-300 transition-colors"
                                                            title="Custom color picker"
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Center: Tools & Size */}
                                    <div className="flex items-center gap-4">
                                        <div className="flex gap-1">
                                            {[
                                                { tool: 'pen', icon: '✏️' },
                                                { tool: 'highlighter', icon: '🖍️' },
                                                { tool: 'eraser', icon: '🧽' }
                                            ].map((toolOption) => (
                                                <button
                                                    key={toolOption.tool}
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        setSelectedTool(toolOption.tool);
                                                    }}
                                                    className={`px-3 py-2 text-sm rounded-full transition-all hover:scale-105 ${
                                                        selectedTool === toolOption.tool
                                                            ? 'bg-blue-500 text-white'
                                                            : 'bg-gray-700 text-gray-300'
                                                    }`}
                                                >
                                                    {toolOption.icon}
                                                </button>
                                            ))}
                                        </div>
                                        
                                        {selectedTool === 'eraser' ? (
                                            // Eraser specific controls - compact layout
                                            <div className="flex items-center gap-2 text-white text-xs">
                                                <div className="flex flex-col items-center">
                                                    <span>Min</span>
                                                    <span>{eraserMinSize}px</span>
                                                    <input
                                                        type="range"
                                                        min="1"
                                                        max="20"
                                                        step="1"
                                                        value={eraserMinSize}
                                                        onChange={(e) => {
                                                            e.preventDefault();
                                                            e.stopPropagation();
                                                            setEraserMinSize(parseInt(e.target.value));
                                                        }}
                                                        className="w-10 h-1 bg-gray-600 rounded appearance-none"
                                                    />
                                                </div>
                                                <div className="flex flex-col items-center">
                                                    <span>Max</span>
                                                    <span>{eraserMaxSize}px</span>
                                                    <input
                                                        type="range"
                                                        min="1"
                                                        max="120"
                                                        step="1"
                                                        value={eraserMaxSize}
                                                        onChange={(e) => {
                                                            e.preventDefault();
                                                            e.stopPropagation();
                                                            setEraserMaxSize(parseInt(e.target.value));
                                                        }}
                                                        className="w-10 h-1 bg-gray-600 rounded appearance-none"
                                                    />
                                                </div>
                                                <div className="flex flex-col items-center">
                                                    <span>Speed</span>
                                                    <span>{speedSensitivity.toFixed(1)}</span>
                                                    <input
                                                        type="range"
                                                        min="0.5"
                                                        max="3"
                                                        step="0.1"
                                                        value={speedSensitivity}
                                                        onChange={(e) => {
                                                            e.preventDefault();
                                                            e.stopPropagation();
                                                            setSpeedSensitivity(parseFloat(e.target.value));
                                                        }}
                                                        className="w-10 h-1 bg-gray-600 rounded appearance-none"
                                                    />
                                                </div>
                                                <div className="flex flex-col items-center">
                                                    <span>Threshold</span>
                                                    <span>{speedThreshold}px/s</span>
                                                    <input
                                                        type="range"
                                                        min="10"
                                                        max="300"
                                                        step="10"
                                                        value={speedThreshold}
                                                        onChange={(e) => {
                                                            e.preventDefault();
                                                            e.stopPropagation();
                                                            setSpeedThreshold(parseInt(e.target.value));
                                                        }}
                                                        className="w-10 h-1 bg-gray-600 rounded appearance-none"
                                                    />
                                                </div>
                                            </div>
                                        ) : (
                                            // Standard size control for pen/highlighter - more compact
                                            <div className="flex flex-col items-center text-white text-xs">
                                                <span>Size</span>
                                                <span>{penSize}px</span>
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="80"
                                                    value={penSize}
                                                    onChange={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        setPenSize(parseInt(e.target.value));
                                                    }}
                                                    className="w-16 h-1 bg-gray-600 rounded appearance-none"
                                                />
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Right: Actions & Status */}
                                    <div className="flex items-center gap-3">
                                        <button
                                            onClick={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                // Clear current page annotations
                                                setAnnotations(prev => {
                                                    const newMap = new Map(prev);
                                                    newMap.delete(currentPage);
                                                    return newMap;
                                                });
                                                // Clear drawing canvas
                                                if (drawingCanvasRef.current) {
                                                    const ctx = drawingCanvasRef.current.getContext('2d');
                                                    ctx.clearRect(0, 0, drawingCanvasRef.current.width, drawingCanvasRef.current.height);
                                                }
                                            }}
                                            className="px-3 py-1 bg-red-600 text-white text-xs rounded-full hover:bg-red-700"
                                        >
                                            Clear
                                        </button>
                                        
                                        <div className="text-white text-xs">
                                            Page {currentPage}/{totalPages}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ) : (
                        // Clean thumbnail view at (400, 200)
                        <div className="min-h-screen relative">
                            {/* PDF Thumbnail positioned at x:400 y:200 with 200px width */}
                            {thumbnailSrc && (
                                <>
                                    <div
                                        className="absolute cursor-pointer rounded-xl overflow-hidden md-elevation-1 hover:md-elevation-3 transition-shadow"
                                        style={{
                                            left: '400px',
                                            top: '200px',
                                            width: '200px'
                                        }}
                                        onPointerDown={handleThumbnailClick}
                                    >
                                        <img
                                            ref={thumbnailRef}
                                            src={thumbnailSrc}
                                            alt="PDF Thumbnail"
                                            style={{
                                                width: '200px',
                                                height: 'auto'
                                            }}
                                        />
                                    </div>
                                    
                                    {/* Filename positioned closer and centered below thumbnail */}
                                    <div className="absolute" style={{ left: '400px', top: '328px', width: '200px' }}>
                                        <p className="text-sm text-md-on-surface dark:text-gray-100 font-medium text-center truncate">
                                            {fileName}
                                        </p>
                                    </div>
                                </>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<PDFAnnotationApp />, document.getElementById('root'));
    </script>


</body></html>
