<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotation App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'md-primary': '#6750A4',
                        'md-on-primary': '#FFFFFF',
                        'md-primary-container': '#EADDFF',
                        'md-on-primary-container': '#21005D',
                        'md-surface': '#FEF7FF',
                        'md-on-surface': '#1D1B20',
                        'md-surface-variant': '#E7E0EC',
                        'md-on-surface-variant': '#49454F',
                        'md-outline': '#79747E',
                        'md-surface-container': '#F3EDF7',
                        'md-surface-container-high': '#ECE6F0',
                    }
                }
            },
            darkMode: 'class'
        }

        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        .md-elevation-3 {
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.30), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
        }
        .md-elevation-1 {
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.30), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
        }
        .annotation-canvas {
            touch-action: none;
        }
        .fullscreen-container {
            background: #000;
        }
        .thumbnail-container {
            background: linear-gradient(135deg, #f3edf7 0%, #e7e0ec 100%);
        }
        .dark .thumbnail-container {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        }
    </style>
</head>
<body class="bg-md-surface dark:bg-gray-900 text-md-on-surface dark:text-gray-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const PDFAnnotationApp = () => {
            const [pdfDoc, setPdfDoc] = useState(null);
            const [currentPage, setCurrentPage] = useState(1);
            const [totalPages, setTotalPages] = useState(0);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [shouldEnterFullscreen, setShouldEnterFullscreen] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [thumbnailSrc, setThumbnailSrc] = useState(null);
            const [annotations, setAnnotations] = useState(new Map());
            const [fileName, setFileName] = useState('');
            const [selectedColor, setSelectedColor] = useState('#800080');
            const [penSize, setPenSize] = useState(3);
            const [selectedTool, setSelectedTool] = useState('pen');
            const [toolbarPosition, setToolbarPosition] = useState({ x: (window.innerWidth - 600) / 2, y: window.innerHeight - 100 });
            const [eraserPosition, setEraserPosition] = useState({ x: 0, y: 0 });
            const [showEraserCircle, setShowEraserCircle] = useState(false);
            const [isDraggingToolbar, setIsDraggingToolbar] = useState(false);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [pressureSensitivity, setPressureSensitivity] = useState(1.0);
            const [toolbarMinimized, setToolbarMinimized] = useState(false);
            const [currentEraserSize, setCurrentEraserSize] = useState(penSize * 3);
            const [smoothedSpeed, setSmoothedSpeed] = useState(0);
            const lastMoveTimeRef = useRef(0);
            const lastPositionRef = useRef({ x: 0, y: 0 });
            
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const drawingCanvasRef = useRef(null);
            const containerRef = useRef(null);
            const thumbnailRef = useRef(null);
            const lastPointRef = useRef(null);
            const isDrawingRef = useRef(false);

            // Load PDF file
            const loadPDF = async (file) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    setPdfDoc(pdf);
                    setTotalPages(pdf.numPages);
                    setCurrentPage(1);
                    
                    // Generate thumbnail from first page
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const thumbnailCanvas = document.createElement('canvas');
                    const thumbnailCtx = thumbnailCanvas.getContext('2d');
                    thumbnailCanvas.width = viewport.width;
                    thumbnailCanvas.height = viewport.height;
                    
                    await page.render({
                        canvasContext: thumbnailCtx,
                        viewport: viewport
                    }).promise;
                    
                    setThumbnailSrc(thumbnailCanvas.toDataURL());
                    
                    // Enter fullscreen immediately (using the file input user gesture)
                    requestFullscreen();
                } catch (error) {
                    console.error('Error loading PDF:', error);
                }
            };

            // Direct fullscreen request
            const requestFullscreen = () => {
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen().then(() => {
                        setIsFullscreen(true);
                    }).catch(err => {
                        console.log('Fullscreen request failed:', err);
                    });
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                    setIsFullscreen(true);
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                    setIsFullscreen(true);
                }
            };

            // Render PDF page with Canvas overlay for raster drawing
            const renderPage = async (pageNum) => {
                if (!pdfDoc || !canvasRef.current) return;

                const page = await pdfDoc.getPage(pageNum);
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                // Calculate scale to fit full screen width
                const pageViewport = page.getViewport({ scale: 1.0 });
                const scale = window.innerWidth / pageViewport.width;
                const viewport = page.getViewport({ scale });
                
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Clear and render page
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport
                }).promise;

                // Setup drawing canvas overlay
                const drawingCanvas = drawingCanvasRef.current;
                if (drawingCanvas) {
                    drawingCanvas.width = viewport.width;
                    drawingCanvas.height = viewport.height;
                    drawingCanvas.style.width = viewport.width + 'px';
                    drawingCanvas.style.height = viewport.height + 'px';
                    
                    const drawingCtx = drawingCanvas.getContext('2d');
                    drawingCtx.clearRect(0, 0, viewport.width, viewport.height);
                    
                    // Restore annotations for this page from saved image data
                    const pageAnnotations = annotations.get(pageNum);
                    if (pageAnnotations && pageAnnotations.imageData) {
                        const img = new Image();
                        img.onload = () => {
                            drawingCtx.drawImage(img, 0, 0);
                        };
                        img.src = pageAnnotations.imageData;
                    }
                }
            };

            // Fullscreen management
            const enterFullscreen = () => {
                if (containerRef.current) {
                    if (containerRef.current.requestFullscreen) {
                        containerRef.current.requestFullscreen();
                    } else if (containerRef.current.webkitRequestFullscreen) {
                        containerRef.current.webkitRequestFullscreen();
                    } else if (containerRef.current.msRequestFullscreen) {
                        containerRef.current.msRequestFullscreen();
                    }
                }
            };

            const exitFullscreen = () => {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            };

            // Canvas-based drawing functions with perfect pixel erasing
            const startDrawing = (e) => {
                if (!isFullscreen || !drawingCanvasRef.current) return;
                
                // Only allow stylus input
                if (e.pointerType !== 'pen') return;
                
                setIsDrawing(true);
                
                const rect = drawingCanvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const ctx = drawingCanvasRef.current.getContext('2d');
                
                if (selectedTool === 'eraser') {
                    // Eraser mode: erase pixels in circular area
                    eraseAtPoint(ctx, x, y);
                } else {
                    // Drawing mode: start new stroke
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = selectedColor;
                    ctx.lineWidth = penSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Apply tool-specific styles
                    if (selectedTool === 'highlighter') {
                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = Math.max(penSize, 8);
                    } else {
                        ctx.globalAlpha = 1.0;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    lastPointRef.current = { x, y };
                }
            };

            const draw = (e) => {
                if (!isDrawing || !isFullscreen || e.pointerType !== 'pen') return;
                
                const rect = drawingCanvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const ctx = drawingCanvasRef.current.getContext('2d');
                
                if (selectedTool === 'eraser') {
                    // Continue erasing pixels
                    eraseAtPoint(ctx, x, y);
                } else {
                    // Continue drawing stroke
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                }
            };

            const stopDrawing = () => {
                if (!isDrawing) return;
                
                setIsDrawing(false);
                
                // Save the canvas state as image data for this page
                if (drawingCanvasRef.current) {
                    const imageData = drawingCanvasRef.current.toDataURL();
                    setAnnotations(prev => {
                        const newMap = new Map(prev);
                        newMap.set(currentPage, { imageData });
                        return newMap;
                    });
                }
                
                lastPointRef.current = null;
            };

            // Speed-responsive pixel eraser
            const eraseAtPoint = (ctx, x, y) => {
                // Use dynamic size that matches the visual circle
                const eraserSize = currentEraserSize;
                
                // Set composite operation to erase pixels
                ctx.globalCompositeOperation = 'destination-out';
                ctx.globalAlpha = 1.0;
                
                // Draw a circle to erase pixels in that area
                ctx.beginPath();
                ctx.arc(x, y, eraserSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
            };

            // Handle thumbnail click (any touch/click)
            const handleThumbnailClick = (e) => {
                e.preventDefault();
                requestFullscreen();
            };

            // Navigation
            const nextPage = () => {
                if (currentPage < totalPages) {
                    setCurrentPage(currentPage + 1);
                }
            };

            const prevPage = () => {
                if (currentPage > 1) {
                    setCurrentPage(currentPage - 1);
                }
            };

            // Effects
            useEffect(() => {
                const handleFullscreenChange = () => {
                    setIsFullscreen(!!document.fullscreenElement);
                };

                const handleKeyDown = (e) => {
                    if (isFullscreen && pdfDoc) {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            prevPage();
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            nextPage();
                        }
                    }
                };

                // Global toolbar drag handling
                const handleGlobalPointerMove = (e) => {
                    if (isDraggingToolbar) {
                        setToolbarPosition({
                            x: e.clientX - dragOffset.x,
                            y: e.clientY - dragOffset.y
                        });
                    }
                };

                const handleGlobalPointerUp = () => {
                    if (isDraggingToolbar) {
                        setIsDraggingToolbar(false);
                    }
                };

                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                document.addEventListener('msfullscreenchange', handleFullscreenChange);
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('pointermove', handleGlobalPointerMove);
                document.addEventListener('pointerup', handleGlobalPointerUp);

                return () => {
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.removeEventListener('msfullscreenchange', handleFullscreenChange);
                    document.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('pointermove', handleGlobalPointerMove);
                    document.removeEventListener('pointerup', handleGlobalPointerUp);
                };
            }, [isFullscreen, pdfDoc, currentPage, totalPages, isDraggingToolbar, dragOffset]);

            // Effect to handle fullscreen trigger
            useEffect(() => {
                if (shouldEnterFullscreen && pdfDoc && containerRef.current) {
                    // Reset the trigger
                    setShouldEnterFullscreen(false);
                    
                    // Enter fullscreen after a brief delay to ensure DOM is ready
                    const timer = setTimeout(() => {
                        enterFullscreen();
                    }, 50);
                    
                    return () => clearTimeout(timer);
                }
            }, [shouldEnterFullscreen, pdfDoc]);

            // Single effect to handle PDF rendering
            useEffect(() => {
                if (pdfDoc && isFullscreen) {
                    const timer = setTimeout(() => {
                        renderPage(currentPage);
                    }, 150);
                    return () => clearTimeout(timer);
                }
            }, [currentPage, pdfDoc, isFullscreen]);

            return (
                <div className="min-h-screen bg-md-surface dark:bg-gray-900">
                    {!pdfDoc ? (
                        // Load screen
                        <div className="flex flex-col items-center justify-center min-h-screen p-6">
                            <div className="bg-md-surface-container dark:bg-gray-800 rounded-3xl p-8 md-elevation-3 max-w-md w-full">
                                <div className="text-center mb-8">
                                    <div className="w-16 h-16 bg-md-primary-container dark:bg-gray-700 rounded-full flex items-center justify-center mx-auto mb-4">
                                        <svg className="w-8 h-8 text-md-on-primary-container dark:text-gray-300" fill="currentColor" viewBox="0 0 24 24">
                                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                                        </svg>
                                    </div>
                                    <h1 className="text-2xl font-bold text-md-on-surface dark:text-gray-100 mb-2">
                                        PDF Annotation
                                    </h1>
                                    <p className="text-md-on-surface-variant dark:text-gray-400">
                                        Load a PDF to start annotating with your stylus
                                    </p>
                                </div>
                                
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    className="w-full bg-md-primary hover:bg-md-primary/90 text-md-on-primary py-4 px-6 rounded-xl font-medium transition-colors md-elevation-1"
                                >
                                    Load PDF
                                </button>
                                
                                <input
                                    ref={fileInputRef}
                                    type="file"
                                    accept=".pdf"
                                    onChange={(e) => {
                                        const file = e.target.files[0];
                                        if (file) {
                                            setFileName(file.name);
                                            loadPDF(file);
                                        }
                                    }}
                                    className="hidden"
                                />
                            </div>
                        </div>
                    ) : isFullscreen ? (
                        // Fullscreen PDF viewer with pill toolbar
                        <div ref={containerRef} className="fullscreen-container relative w-full h-screen flex items-start justify-start overflow-hidden">
                            <div className="relative">
                                <canvas ref={canvasRef} className="block" />
                                <canvas
                                    ref={drawingCanvasRef}
                                    className="absolute top-0 left-0 block"
                                    style={{ 
                                        touchAction: 'none',
                                        cursor: selectedTool === 'eraser' ? 'none' : 'crosshair'
                                    }}
                                    onPointerDown={startDrawing}
                                    onPointerMove={(e) => {
                                        // Always update eraser position when eraser is selected
                                        if (selectedTool === 'eraser' && drawingCanvasRef.current) {
                                            const rect = drawingCanvasRef.current.getBoundingClientRect();
                                            const newX = e.clientX - rect.left;
                                            const newY = e.clientY - rect.top;
                                            const currentTime = performance.now();
                                            
                                            // Smooth speed calculation
                                            if (lastMoveTimeRef.current > 0 && lastPositionRef.current.x !== 0) {
                                                const deltaTime = currentTime - lastMoveTimeRef.current;
                                                const deltaX = newX - lastPositionRef.current.x;
                                                const deltaY = newY - lastPositionRef.current.y;
                                                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                                                
                                                if (deltaTime > 0 && deltaTime < 100) { // Only use recent movements
                                                    const currentSpeed = distance / deltaTime; // pixels per ms
                                                    // Exponential smoothing for responsive but smooth changes
                                                    const newSmoothedSpeed = smoothedSpeed * 0.7 + currentSpeed * 0.3;
                                                    setSmoothedSpeed(newSmoothedSpeed);
                                                    
                                                    const speedMultiplier = Math.min(1 + (newSmoothedSpeed * 1.5), 2.5); // Max 2.5x size
                                                    const dynamicSize = (penSize * 3) * speedMultiplier;
                                                    setCurrentEraserSize(dynamicSize);
                                                }
                                            }
                                            
                                            // Update position immediately for smooth circle following
                                            setEraserPosition({ x: newX, y: newY });
                                            lastPositionRef.current = { x: newX, y: newY };
                                            lastMoveTimeRef.current = currentTime;
                                            setShowEraserCircle(true);
                                        } else {
                                            setShowEraserCircle(false);
                                        }
                                        draw(e);
                                    }}
                                    onPointerUp={stopDrawing}
                                    onPointerLeave={() => {
                                        setShowEraserCircle(false);
                                        stopDrawing();
                                    }}
                                    onPointerEnter={(e) => {
                                        if (selectedTool === 'eraser' && drawingCanvasRef.current) {
                                            const rect = drawingCanvasRef.current.getBoundingClientRect();
                                            setEraserPosition({
                                                x: e.clientX - rect.left,
                                                y: e.clientY - rect.top
                                            });
                                            setShowEraserCircle(true);
                                        }
                                    }}
                                />
                                
                                {/* Dynamic Eraser Circle - Size increases with speed, no transitions for smoothness */}
                                {showEraserCircle && selectedTool === 'eraser' && (
                                    <div
                                        className="absolute pointer-events-none"
                                        style={{
                                            left: `${eraserPosition.x - currentEraserSize}px`,
                                            top: `${eraserPosition.y - currentEraserSize}px`,
                                            width: `${currentEraserSize * 2}px`,
                                            height: `${currentEraserSize * 2}px`,
                                            border: '2px dashed #808080',
                                            borderRadius: '50%',
                                            zIndex: 999,
                                            background: 'rgba(128, 128, 128, 0.1)',
                                            transform: 'translateZ(0)', // Hardware acceleration
                                            willChange: 'transform, width, height' // Optimize for changes
                                        }}
                                    />
                                )}
                            </div>
                            
                            {/* Horizontal Pill Toolbar - Bottom Positioned */}
                            <div
                                className="absolute bg-gray-900 rounded-full shadow-2xl border border-gray-700 cursor-move"
                                style={{
                                    left: `${toolbarPosition.x}px`,
                                    bottom: '20px',
                                    zIndex: 1000,
                                    userSelect: 'none',
                                    minWidth: '600px',
                                    height: '60px',
                                    touchAction: 'none'
                                }}
                                onPointerDown={(e) => {
                                    // Only start drag if clicking on empty space, not buttons
                                    if (e.target.closest('button, input')) {
                                        return;
                                    }
                                    e.preventDefault();
                                    e.stopPropagation();
                                    const rect = e.currentTarget.getBoundingClientRect();
                                    setDragOffset({
                                        x: e.clientX - rect.left,
                                        y: e.clientY - rect.top
                                    });
                                    setIsDraggingToolbar(true);
                                }}
                            >
                                <div className="flex items-center justify-between h-full px-6 py-2">
                                    {/* Left: Colors */}
                                    <div className="flex items-center gap-3">
                                        <span className="text-white text-xs font-bold">🎨</span>
                                        <div className="flex gap-1">
                                            {['#000000', '#FF0000', '#0000FF', '#800080', '#FFA500'].map((color) => (
                                                <button
                                                    key={color}
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        setSelectedColor(color);
                                                    }}
                                                    className={`w-8 h-8 rounded-full border-2 transition-all hover:scale-110 ${
                                                        selectedColor === color ? 'border-white shadow-lg' : 'border-gray-400'
                                                    }`}
                                                    style={{ backgroundColor: color }}
                                                />
                                            ))}
                                        </div>
                                    </div>
                                    
                                    {/* Center: Tools & Size */}
                                    <div className="flex items-center gap-4">
                                        <div className="flex gap-1">
                                            {[
                                                { tool: 'pen', icon: '✏️' },
                                                { tool: 'highlighter', icon: '🖍️' },
                                                { tool: 'eraser', icon: '🧽' }
                                            ].map((toolOption) => (
                                                <button
                                                    key={toolOption.tool}
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        setSelectedTool(toolOption.tool);
                                                    }}
                                                    className={`px-3 py-2 text-sm rounded-full transition-all hover:scale-105 ${
                                                        selectedTool === toolOption.tool
                                                            ? 'bg-blue-500 text-white'
                                                            : 'bg-gray-700 text-gray-300'
                                                    }`}
                                                >
                                                    {toolOption.icon}
                                                </button>
                                            ))}
                                        </div>
                                        
                                        <div className="text-white text-xs">
                                            Size: {penSize}px
                                            <input
                                                type="range"
                                                min="1"
                                                max="30"
                                                value={penSize}
                                                onChange={(e) => {
                                                    e.preventDefault();
                                                    e.stopPropagation();
                                                    setPenSize(parseInt(e.target.value));
                                                }}
                                                className="ml-2 w-20 h-1 bg-gray-600 rounded appearance-none"
                                            />
                                        </div>
                                    </div>
                                    
                                    {/* Right: Actions & Status */}
                                    <div className="flex items-center gap-3">
                                        <button
                                            onClick={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                // Clear current page annotations
                                                setAnnotations(prev => {
                                                    const newMap = new Map(prev);
                                                    newMap.delete(currentPage);
                                                    return newMap;
                                                });
                                                // Clear drawing canvas
                                                if (drawingCanvasRef.current) {
                                                    const ctx = drawingCanvasRef.current.getContext('2d');
                                                    ctx.clearRect(0, 0, drawingCanvasRef.current.width, drawingCanvasRef.current.height);
                                                }
                                            }}
                                            className="px-3 py-1 bg-red-600 text-white text-xs rounded-full hover:bg-red-700"
                                        >
                                            Clear
                                        </button>
                                        
                                        <div className="text-white text-xs">
                                            Page {currentPage}/{totalPages}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ) : (
                        // Clean thumbnail view at (400, 200)
                        <div className="min-h-screen relative">
                            {/* PDF Thumbnail positioned at x:400 y:200 with 200px width */}
                            {thumbnailSrc && (
                                <>
                                    <div
                                        className="absolute cursor-pointer rounded-xl overflow-hidden md-elevation-1 hover:md-elevation-3 transition-shadow"
                                        style={{
                                            left: '400px',
                                            top: '200px',
                                            width: '200px'
                                        }}
                                        onPointerDown={handleThumbnailClick}
                                    >
                                        <img
                                            ref={thumbnailRef}
                                            src={thumbnailSrc}
                                            alt="PDF Thumbnail"
                                            style={{
                                                width: '200px',
                                                height: 'auto'
                                            }}
                                        />
                                    </div>
                                    
                                    {/* Filename positioned closer and centered below thumbnail */}
                                    <div className="absolute" style={{ left: '400px', top: '328px', width: '200px' }}>
                                        <p className="text-sm text-md-on-surface dark:text-gray-100 font-medium text-center truncate">
                                            {fileName}
                                        </p>
                                    </div>
                                </>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<PDFAnnotationApp />, document.getElementById('root'));
    </script>


</body></html>
