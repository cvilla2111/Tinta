<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: { primary: '#5D5CDE' }
                }
            }
        }
    </script>
    <style>
        .aspect-16-9 { aspect-ratio: 16 / 9; }
        .lucide { stroke-width: 0.5px; }
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto;
            cursor: none;
        }
        .pdf-container { position: relative; overflow: auto; }
        .toolbar {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
        }
        .dark .toolbar { background: rgba(30, 30, 30, 0.9); }
        .eraser-cursor {
            position: fixed;
            border: 2px dashed #666;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            display: none;
        }
        .dark .eraser-cursor { border-color: #999; }
        .tool-btn {
            @apply text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-gray-100;
        }
        .tool-btn.active {
            @apply bg-primary text-white hover:bg-primary/90;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            border: none;
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script><script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body class="bg-white text-gray-900 transition-colors duration-200">
    <!-- Home Screen -->
    <div id="homeScreen" class="min-h-screen flex items-center justify-center p-8">
        <div class="max-w-4xl w-full aspect-16-9 bg-gray-50 dark:bg-gray-800 rounded-2xl border-2 border-dashed border-gray-300 dark:border-gray-600 flex flex-col items-center justify-center relative">
            <!-- Dark Mode Toggle -->
            <button id="themeToggle" class="absolute top-6 right-6 p-2 rounded-lg bg-white dark:bg-gray-700 shadow-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors">
                <i data-lucide="sun" class="w-5 h-5 dark:hidden"></i>
                <i data-lucide="moon" class="w-5 h-5 hidden dark:block"></i>
            </button>

            <div class="text-center">
                <div class="mb-8">
                    <i data-lucide="file-text" class="w-16 h-16 mx-auto text-gray-400 dark:text-gray-500 mb-4"></i>
                    <h1 class="text-3xl font-bold text-gray-700 dark:text-gray-200 mb-2">PDF Annotator</h1>
                    <p class="text-gray-500 dark:text-gray-400">Load a PDF file to start annotating</p>
                </div>
                
                <button id="loadPdfBtn" class="inline-flex items-center px-8 py-4 bg-primary text-white rounded-xl hover:bg-primary/90 transition-colors shadow-lg">
                    <i data-lucide="upload" class="w-5 h-5 mr-3"></i>
                    Load PDF
                </button>
                
                <input type="file" id="pdfInput" accept=".pdf" class="hidden">
            </div>
        </div>
    </div>

    <!-- PDF Viewer Screen -->
    <div id="pdfScreen" class="hidden h-screen bg-gray-100 dark:bg-gray-900 overflow-hidden">
        <!-- PDF Container -->
        <div class="pdf-container h-full w-full">
            <div id="pdfViewerContainer" class="w-full h-full relative bg-white dark:bg-gray-800 overflow-hidden">
                <canvas id="pdfCanvas" class="block w-full h-full"></canvas>
                <canvas id="annotationCanvas" class="drawing-canvas"></canvas>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" class="hidden fixed bottom-20 left-6 bg-white dark:bg-gray-800 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-600 p-4 w-64">
            <!-- Pen Settings -->
            <div id="penSettings">
                <!-- Color Palette -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Color</h3>
                    <div class="grid grid-cols-8 gap-2" id="colorPalette">
                        <!-- Colors will be generated dynamically -->
                    </div>
                </div>
                
                <!-- Pen Size -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Pen Size</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">1</span>
                        <input type="range" id="penSizeSlider" min="1" max="20" value="2" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">20</span>
                    </div>
                    <div class="flex justify-center mt-2">
                        <div id="penSizePreview" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                    </div>
                </div>

                <!-- Pressure Sensitivity -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Pressure</h3>
                    <div class="flex items-center justify-between">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Pressure Sensitivity</span>
                        <button id="pressureToggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 dark:bg-gray-600 transition-colors focus:outline-none">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"></span>
                        </button>
                    </div>
                    <div class="mt-2 text-xs text-gray-500 dark:text-gray-400">
                        <span id="pressureStatus">Disabled</span>
                        <span id="pressureValue" class="ml-2"></span>
                    </div>
                </div>

                <!-- Opacity -->
                <div>
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Opacity</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">10%</span>
                        <input type="range" id="opacitySlider" min="0.1" max="1" step="0.1" value="1" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">100%</span>
                    </div>
                </div>
            </div>

            <!-- Eraser Settings -->
            <div id="eraserSettings" class="hidden">
                <!-- Eraser Size -->
                <div>
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Eraser Size</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">5</span>
                        <input type="range" id="eraserSizeSlider" min="5" max="90" value="10" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">90</span>
                    </div>
                    <div class="flex justify-center mt-2">
                        <div id="eraserSizePreview" class="border-2 border-gray-400 dark:border-gray-500 rounded-full bg-transparent"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Floating Toolbar -->
        <div id="toolbar" class="toolbar fixed bottom-6 left-6 flex items-center space-x-0.5 px-2 py-1 rounded-full border border-gray-200 dark:border-gray-600 shadow-lg">
            <button id="penTool" class="tool-btn active p-1 rounded-lg transition-colors" data-tool="pen">
                <i data-lucide="pen-tool" class="w-5 h-5"></i>
            </button>
            <button id="eraserTool" class="tool-btn p-1 rounded-lg transition-colors" data-tool="eraser">
                <i data-lucide="eraser" class="w-5 h-5"></i>
            </button>
            <div class="w-px h-4 bg-gray-300 dark:bg-gray-600 mx-1"></div>
            <button id="undoBtn" class="tool-btn p-1 rounded-lg transition-colors">
                <i data-lucide="undo" class="w-5 h-5"></i>
            </button>
            <button id="redoBtn" class="tool-btn p-1 rounded-lg transition-colors">
                <i data-lucide="redo" class="w-5 h-5"></i>
            </button>
            <button id="clearBtn" class="tool-btn p-1 rounded-lg transition-colors">
                <i data-lucide="trash-2" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- Eraser Cursor -->
        <div id="eraserCursor" class="eraser-cursor"></div>
    </div>

    <script>
        // Initialize Lucide icons and theme
        lucide.createIcons();
        
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
        });

        class PDFAnnotator {
            constructor() {
                // Core properties
                this.pdfDoc = null;
                this.currentPage = 1;
                this.totalPages = 0;
                
                // Drawing state
                this.isDrawing = false;
                this.currentTool = 'pen';
                this.previousTool = 'pen';
                this.strokeColor = '#000000';
                this.penSize = 2;
                this.eraserSize = 10;
                this.strokeOpacity = 1;
                this.pressureSensitive = false;
                this.isEraserButtonPressed = false;
                
                // Cursor management
                this.cursorTimeout = null;
                this.cursorVisible = false;
                
                // Pressure sensitivity properties
                this.currentPressure = 0.5;
                this.lastPoint = null;
                this.pressureMultiplier = 3; // How much pressure affects line width
                
                // Quadratic interpolation properties
                this.points = []; // Store multiple points for smooth curves
                this.smoothing = 0.5; // Smoothing factor (0 = no smoothing, 1 = maximum smoothing)
                
                // History management
                this.undoStack = [];
                this.redoStack = [];
                
                // Page-specific annotations storage
                this.pageAnnotations = new Map(); // Store annotations per page
                
                // Device pixel ratio for crisp rendering
                this.devicePixelRatio = window.devicePixelRatio || 1;
                
                // Constants
                this.MAX_UNDO_STATES = 20;
                this.DOUBLE_TAP_DELAY = 300;
                
                // Color palette
                this.colors = [
                    '#000000', '#ef4444', '#3b82f6', '#22c55e',
                    '#eab308', '#a855f7', '#ec4899', '#f97316',
                    '#6b7280', '#6366f1', '#14b8a6', '#84cc16',
                    '#f59e0b', '#f43f5e', '#06b6d4', '#ffffff'
                ];
                
                this.init();
            }

            init() {
                this.setupElements();
                this.generateColorPalette();
                this.bindEvents();
                this.updateUI();
            }

            setupElements() {
                // Cache DOM elements
                this.elements = {
                    homeScreen: document.getElementById('homeScreen'),
                    pdfScreen: document.getElementById('pdfScreen'),
                    pdfCanvas: document.getElementById('pdfCanvas'),
                    annotationCanvas: document.getElementById('annotationCanvas'),
                    settingsModal: document.getElementById('settingsModal'),
                    eraserCursor: document.getElementById('eraserCursor'),
                    toolbar: document.getElementById('toolbar')
                };
                
                // Setup canvas contexts
                this.pdfCtx = this.elements.pdfCanvas.getContext('2d');
                this.annotationCtx = this.elements.annotationCanvas.getContext('2d');
                
                // Apply initial optimization settings
                this.optimizeCanvasContext(this.annotationCtx);
            }

            optimizeCanvasContext(ctx) {
                // Apply better rendering settings for smoother, crisper lines
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            }

            generateColorPalette() {
                const palette = document.getElementById('colorPalette');
                palette.innerHTML = this.colors.map(color => 
                    `<button class="color-btn w-6 h-6 rounded-full border-2 border-gray-300 hover:border-gray-500" 
                             style="background-color: ${color}" 
                             data-color="${color}"></button>`
                ).join('');
            }

            bindEvents() {
                // Theme toggle
                document.getElementById('themeToggle').addEventListener('click', () => {
                    document.documentElement.classList.toggle('dark');
                });

                // File loading
                document.getElementById('loadPdfBtn').addEventListener('click', () => {
                    document.getElementById('pdfInput').click();
                });

                document.getElementById('pdfInput').addEventListener('change', (e) => {
                    if (e.target.files[0]) this.loadPDF(e.target.files[0]);
                });

                // Keyboard navigation
                document.addEventListener('keydown', this.handleKeydown.bind(this));

                // Tool events
                this.elements.toolbar.addEventListener('click', this.handleToolbarClick.bind(this));

                // Settings events
                this.bindSettingsEvents();

                // Drawing events
                this.bindDrawingEvents();

                // Modal events
                this.bindModalEvents();
            }

            bindSettingsEvents() {
                // Color selection
                document.getElementById('colorPalette').addEventListener('click', (e) => {
                    if (e.target.classList.contains('color-btn')) {
                        this.setColor(e.target.dataset.color);
                        this.hideSettingsModal();
                    }
                });

                // Sliders
                document.getElementById('penSizeSlider').addEventListener('input', (e) => {
                    this.penSize = parseInt(e.target.value);
                    this.updatePreview('pen');
                });

                document.getElementById('eraserSizeSlider').addEventListener('input', (e) => {
                    this.eraserSize = parseInt(e.target.value);
                    this.updatePreview('eraser');
                    this.updateEraserCursor();
                });

                document.getElementById('opacitySlider').addEventListener('input', (e) => {
                    this.strokeOpacity = parseFloat(e.target.value);
                });

                document.getElementById('pressureToggle').addEventListener('click', () => {
                    this.togglePressureSensitivity();
                });
            }

            bindDrawingEvents() {
                const canvas = this.elements.annotationCanvas;
                
                // Pointer events (supports mouse, stylus/pen, but excludes finger touch)
                canvas.addEventListener('pointerdown', this.handlePointerStart.bind(this));
                canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
                canvas.addEventListener('pointerup', this.handlePointerEnd.bind(this));
                canvas.addEventListener('pointerout', this.handlePointerEnd.bind(this));
                canvas.addEventListener('pointerenter', this.showEraserCursor.bind(this));
                canvas.addEventListener('pointerleave', this.hideEraserCursor.bind(this));

                // Fallback mouse events for older browsers
                canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                canvas.addEventListener('mouseout', this.stopDrawing.bind(this));
                canvas.addEventListener('mouseenter', this.showEraserCursor.bind(this));
                canvas.addEventListener('mouseleave', this.hideEraserCursor.bind(this));

                // Prevent default touch behavior to avoid scrolling during drawing
                canvas.addEventListener('touchstart', (e) => e.preventDefault());
                canvas.addEventListener('touchmove', (e) => e.preventDefault());
                canvas.addEventListener('touchend', (e) => e.preventDefault());
            }

            bindModalEvents() {
                // Double tap on tool buttons to open settings
                let lastTapTime = 0;
                let lastTappedTool = null;
                let tapTimeout = null;
                
                // Handle tool button clicks (both single and double tap)
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent toolbar click handler
                        
                        const tool = btn.dataset.tool;
                        const currentTime = Date.now();
                        const timeSinceLastTap = currentTime - lastTapTime;
                        
                        if (timeSinceLastTap < this.DOUBLE_TAP_DELAY && 
                            timeSinceLastTap > 0 && 
                            lastTappedTool === tool) {
                            // Double tap detected on same tool
                            clearTimeout(tapTimeout);
                            this.setTool(tool); // Ensure tool is selected
                            this.toggleSettingsModal();
                            lastTapTime = 0; // Reset to prevent triple tap
                            lastTappedTool = null;
                        } else {
                            // First tap or different tool
                            this.setTool(tool);
                            lastTapTime = currentTime;
                            lastTappedTool = tool;
                            
                            // Clear any existing timeout
                            clearTimeout(tapTimeout);
                            
                            // Set timeout to reset if no second tap comes
                            tapTimeout = setTimeout(() => {
                                lastTapTime = 0;
                                lastTappedTool = null;
                            }, this.DOUBLE_TAP_DELAY);
                        }
                    });
                });

                // Close modal on outside click/touch
                document.addEventListener('click', (e) => {
                    if (!this.elements.settingsModal.contains(e.target) && 
                        !this.elements.toolbar.contains(e.target)) {
                        this.hideSettingsModal();
                    }
                });

                // Close modal on outside touch (stylus, finger)
                document.addEventListener('touchstart', (e) => {
                    if (!this.elements.settingsModal.classList.contains('hidden') &&
                        !this.elements.settingsModal.contains(e.target) && 
                        !this.elements.toolbar.contains(e.target)) {
                        this.hideSettingsModal();
                    }
                });

                // Also handle touchend for better touch responsiveness
                document.addEventListener('touchend', (e) => {
                    if (!this.elements.settingsModal.classList.contains('hidden') &&
                        !this.elements.settingsModal.contains(e.target) && 
                        !this.elements.toolbar.contains(e.target)) {
                        this.hideSettingsModal();
                    }
                });
            }

            handleKeydown(e) {
                if (this.elements.pdfScreen.classList.contains('hidden')) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        if (this.currentPage > 1) {
                            this.navigateToPage(this.currentPage - 1);
                        }
                        break;
                    case 'ArrowRight':
                        if (this.currentPage < this.totalPages) {
                            this.navigateToPage(this.currentPage + 1);
                        }
                        break;
                    case 'Escape':
                        this.showHomeScreen();
                        break;
                }
            }

            navigateToPage(newPage) {
                if (newPage < 1 || newPage > this.totalPages) return;
                
                // Save annotations for current page before switching
                this.savePageAnnotations(this.currentPage);
                
                // Update to new page
                this.currentPage = newPage;
                
                // Render the new page
                this.renderPage();
            }

            handleToolbarClick(e) {
                const toolBtn = e.target.closest('.tool-btn');
                if (!toolBtn) return;

                // Only handle non-tool buttons here (undo, redo, clear)
                // Tool buttons are handled in bindModalEvents
                if (!toolBtn.dataset.tool) {
                    const action = toolBtn.id;
                    switch (action) {
                        case 'undoBtn': this.undo(); break;
                        case 'redoBtn': this.redo(); break;
                        case 'clearBtn': this.clearAnnotations(); break;
                    }
                }
            }

            handleMouseMove(e) {
                // Show cursor when mouse moves (indicates mouse/trackpad usage)
                this.showCursor();
                
                if (this.currentTool === 'eraser') {
                    this.positionEraserCursor(e.clientX, e.clientY);
                }
                this.draw(e);
            }

            handlePointerStart(e) {
                // Only allow drawing with stylus/pen and mouse, not finger touch
                if (e.pointerType === 'touch') {
                    return; // Ignore finger touch for drawing
                }
                
                // Store pressure information
                this.currentPressure = e.pressure || 0.5;
                this.updatePressureDisplay();
                
                // Check for eraser button press (stylus eraser)
                this.checkEraserButton(e);
                
                this.startDrawing(e);
            }

            handlePointerMove(e) {
                // Only allow drawing with stylus/pen and mouse, not finger touch
                if (e.pointerType === 'touch') {
                    return; // Ignore finger touch for drawing
                }
                
                // Update pressure information
                this.currentPressure = e.pressure || 0.5;
                this.updatePressureDisplay();
                
                // Check for eraser button during move
                this.checkEraserButton(e);
                
                if (this.currentTool === 'eraser') {
                    this.positionEraserCursor(e.clientX, e.clientY);
                }
                this.draw(e);
            }

            handlePointerEnd(e) {
                // Only allow drawing with stylus/pen and mouse, not finger touch
                if (e.pointerType === 'touch') {
                    return; // Ignore finger touch for drawing
                }
                
                // Reset pressure
                this.currentPressure = 0.5;
                this.updatePressureDisplay();
                
                // Check if eraser button was released
                this.checkEraserButton(e);
                
                this.stopDrawing();
            }

            updatePressureDisplay() {
                const pressureValue = document.getElementById('pressureValue');
                if (pressureValue && this.pressureSensitive) {
                    pressureValue.textContent = `(${(this.currentPressure * 100).toFixed(0)}%)`;
                } else if (pressureValue) {
                    pressureValue.textContent = '';
                }
            }

            checkEraserButton(e) {
                // Detect eraser button press on stylus
                // buttons: 32 = eraser button, 2 = secondary button (also used for eraser on some styluses)
                const eraserPressed = (e.buttons & 32) !== 0 || (e.pointerType === 'pen' && (e.buttons & 2) !== 0);
                
                if (eraserPressed && !this.isEraserButtonPressed) {
                    // Eraser button just pressed
                    this.isEraserButtonPressed = true;
                    if (this.currentTool !== 'eraser') {
                        this.previousTool = this.currentTool;
                        this.setTool('eraser');
                        // Show eraser cursor when switching to eraser via stylus button
                        this.showEraserCursor();
                        this.positionEraserCursor(e.clientX, e.clientY);
                    }
                } else if (!eraserPressed && this.isEraserButtonPressed) {
                    // Eraser button just released
                    this.isEraserButtonPressed = false;
                    if (this.currentTool === 'eraser' && this.previousTool) {
                        // Hide eraser cursor when switching away from eraser
                        this.hideEraserCursor();
                        this.setTool(this.previousTool);
                    }
                }
                
                // Update eraser cursor position if eraser is active
                if (this.currentTool === 'eraser' && this.isEraserButtonPressed) {
                    this.positionEraserCursor(e.clientX, e.clientY);
                }
            }

            async loadPDF(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                    this.totalPages = this.pdfDoc.numPages;
                    this.currentPage = 1;
                    
                    this.showPdfScreen();
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await this.renderPage();
                } catch (error) {
                    console.error('Error loading PDF:', error);
                }
            }

            async renderPage() {
                const page = await this.pdfDoc.getPage(this.currentPage);
                
                // Use fixed scale instead of dynamic scaling
                const scale = this.fixedScale || this.calculateInitialScale(page);
                this.fixedScale = scale; // Store for consistency
                
                const viewport = page.getViewport({ scale });
                
                // Set canvas dimensions with device pixel ratio support
                this.setCanvasDimensions(viewport.width, viewport.height);
                
                // Render PDF to the PDF canvas with proper scaling
                await page.render({
                    canvasContext: this.pdfCtx,
                    viewport: viewport
                }).promise;
                
                // Clear annotations canvas first
                this.annotationCtx.clearRect(
                    0, 0,
                    viewport.width,
                    viewport.height
                );
                
                // Restore annotations for current page
                this.restoreCurrentPageAnnotations();
                
                // Reset undo/redo stacks for the new page
                this.undoStack = [];
                this.redoStack = [];
            }

            setCanvasDimensions(width, height) {
                // Account for device pixel ratio for crisp rendering
                const devicePixelRatio = this.devicePixelRatio;
                
                [this.elements.pdfCanvas, this.elements.annotationCanvas].forEach(canvas => {
                    // Set the display size (CSS pixels)
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    canvas.style.display = 'block';
                    
                    // Set the internal canvas size accounting for device pixel ratio
                    canvas.width = width * devicePixelRatio;
                    canvas.height = height * devicePixelRatio;
                    
                    // Get context and scale it
                    const ctx = canvas.getContext('2d');
                    ctx.scale(devicePixelRatio, devicePixelRatio);
                    
                    // Apply optimization settings
                    this.optimizeCanvasContext(ctx);
                });
            }

            saveCurrentPageAnnotations() {
                if (this.elements.annotationCanvas.width > 0 && this.elements.annotationCanvas.height > 0) {
                    const imageData = this.annotationCtx.getImageData(
                        0, 0,
                        this.elements.annotationCanvas.width / this.devicePixelRatio,
                        this.elements.annotationCanvas.height / this.devicePixelRatio
                    );
                    this.pageAnnotations.set(this.currentPage, imageData);
                }
            }

            restoreCurrentPageAnnotations() {
                const savedAnnotations = this.pageAnnotations.get(this.currentPage);
                if (savedAnnotations) {
                    this.annotationCtx.putImageData(savedAnnotations, 0, 0);
                }
            }

            savePageAnnotations(pageNumber) {
                if (this.elements.annotationCanvas.width > 0 && this.elements.annotationCanvas.height > 0) {
                    const imageData = this.annotationCtx.getImageData(
                        0, 0,
                        this.elements.annotationCanvas.width / this.devicePixelRatio,
                        this.elements.annotationCanvas.height / this.devicePixelRatio
                    );
                    this.pageAnnotations.set(pageNumber, imageData);
                }
            }

            calculateInitialScale(page) {
                // Calculate scale only once when first loading
                const container = document.getElementById('pdfViewerContainer');
                const containerWidth = container.clientWidth;
                const baseViewport = page.getViewport({ scale: 1 });
                
                // Use a reasonable default scale that fits most screens
                const fitScale = containerWidth / baseViewport.width;
                // Cap the scale to prevent too large or too small rendering
                return Math.min(Math.max(fitScale, 0.5), 2.0);
            }

            setTool(tool) {
                this.currentTool = tool;
                
                // Update active state
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });
                
                // Always hide cursor by default (will show on mouse movement)
                this.hideCursor();
                this.updateEraserCursor();
            }

            startDrawing(e) {
                this.isDrawing = true;
                this.saveState();
                
                const { x, y } = this.getCanvasCoordinates(e);
                this.lastPoint = { x, y };
                
                // Initialize points array for quadratic interpolation
                this.points = [{ x, y, pressure: this.currentPressure }];
                
                this.annotationCtx.beginPath();
                this.annotationCtx.moveTo(x, y);
                
                // Set tool properties
                if (this.currentTool === 'pen') {
                    this.annotationCtx.globalCompositeOperation = 'source-over';
                    this.annotationCtx.strokeStyle = this.strokeColor;
                    
                    // Apply pressure sensitivity to line width if enabled
                    if (this.pressureSensitive) {
                        this.annotationCtx.lineWidth = this.penSize * (0.3 + this.currentPressure * this.pressureMultiplier);
                    } else {
                        this.annotationCtx.lineWidth = this.penSize;
                    }
                    
                    this.annotationCtx.globalAlpha = this.strokeOpacity;
                } else if (this.currentTool === 'eraser') {
                    this.annotationCtx.globalCompositeOperation = 'destination-out';
                    this.annotationCtx.lineWidth = this.eraserSize;
                    this.annotationCtx.globalAlpha = 1;
                }
            }

            draw(e) {
                if (!this.isDrawing) return;
                
                const { x, y } = this.getCanvasCoordinates(e);
                
                // Add new point to the points array
                this.points.push({ x, y, pressure: this.currentPressure });
                
                if (this.currentTool === 'pen') {
                    this.drawSmoothLine();
                } else if (this.currentTool === 'eraser') {
                    // For eraser, use simpler line drawing
                    this.annotationCtx.lineTo(x, y);
                    this.annotationCtx.stroke();
                }
                
                this.lastPoint = { x, y };
            }

            drawSmoothLine() {
                const pointsLength = this.points.length;
                
                // Need at least 2 points to draw
                if (pointsLength < 2) return;
                
                // For the first segment, just draw a line
                if (pointsLength === 2) {
                    const [p0, p1] = this.points;
                    
                    if (this.pressureSensitive) {
                        this.annotationCtx.lineWidth = this.penSize * (0.3 + p1.pressure * this.pressureMultiplier);
                    }
                    
                    this.annotationCtx.lineTo(p1.x, p1.y);
                    this.annotationCtx.stroke();
                    return;
                }
                
                // Use quadratic interpolation for smoother curves
                const p0 = this.points[pointsLength - 3]; // Previous point
                const p1 = this.points[pointsLength - 2]; // Control point
                const p2 = this.points[pointsLength - 1]; // Current point
                
                // Calculate control point using smoothing factor
                const cpX = p1.x + (p2.x - p0.x) * this.smoothing * 0.25;
                const cpY = p1.y + (p2.y - p0.y) * this.smoothing * 0.25;
                
                // Calculate midpoint for smooth connection
                const midX = (p1.x + p2.x) * 0.5;
                const midY = (p1.y + p2.y) * 0.5;
                
                // Set line width based on pressure if enabled
                if (this.pressureSensitive) {
                    const avgPressure = (p1.pressure + p2.pressure) * 0.5;
                    this.annotationCtx.lineWidth = this.penSize * (0.3 + avgPressure * this.pressureMultiplier);
                }
                
                // Draw quadratic curve from previous point to midpoint
                this.annotationCtx.quadraticCurveTo(cpX, cpY, midX, midY);
                this.annotationCtx.stroke();
                
                // Start new path from the midpoint for the next segment
                this.annotationCtx.beginPath();
                this.annotationCtx.moveTo(midX, midY);
            }
            
            drawPressureSensitiveLine(x, y) {
                if (!this.lastPoint) return;
                
                // Calculate distance for smoother lines
                const dx = x - this.lastPoint.x;
                const dy = y - this.lastPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only draw if there's enough movement
                if (distance < 1) return;
                
                // Update line width based on pressure
                const newLineWidth = this.penSize * (0.3 + this.currentPressure * this.pressureMultiplier);
                this.annotationCtx.lineWidth = newLineWidth;
                
                // Draw smooth line segment
                this.annotationCtx.lineTo(x, y);
                this.annotationCtx.stroke();
                
                // Start new path for next segment to allow for line width changes
                this.annotationCtx.beginPath();
                this.annotationCtx.moveTo(x, y);
            }

            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.lastPoint = null;
                    this.redoStack = [];
                }
            }

            getCanvasCoordinates(e) {
                const rect = this.elements.annotationCanvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            saveState() {
                const imageData = this.annotationCtx.getImageData(
                    0, 0, 
                    this.elements.annotationCanvas.width / this.devicePixelRatio, 
                    this.elements.annotationCanvas.height / this.devicePixelRatio
                );
                
                this.undoStack.push(imageData);
                if (this.undoStack.length > this.MAX_UNDO_STATES) {
                    this.undoStack.shift();
                }
            }

            undo() {
                if (this.undoStack.length === 0) return;
                
                this.redoStack.push(this.annotationCtx.getImageData(
                    0, 0,
                    this.elements.annotationCanvas.width / this.devicePixelRatio,
                    this.elements.annotationCanvas.height / this.devicePixelRatio
                ));
                
                const previousState = this.undoStack.pop();
                this.annotationCtx.putImageData(previousState, 0, 0);
            }

            redo() {
                if (this.redoStack.length === 0) return;
                
                this.undoStack.push(this.annotationCtx.getImageData(
                    0, 0,
                    this.elements.annotationCanvas.width / this.devicePixelRatio,
                    this.elements.annotationCanvas.height / this.devicePixelRatio
                ));
                
                const nextState = this.redoStack.pop();
                this.annotationCtx.putImageData(nextState, 0, 0);
            }

            clearAnnotations() {
                this.saveState();
                this.annotationCtx.clearRect(
                    0, 0,
                    this.elements.annotationCanvas.width / this.devicePixelRatio,
                    this.elements.annotationCanvas.height / this.devicePixelRatio
                );
                // Also remove the current page annotations from storage
                this.pageAnnotations.delete(this.currentPage);
                this.redoStack = [];
            }

            showHomeScreen() {
                this.elements.homeScreen.classList.remove('hidden');
                this.elements.pdfScreen.classList.add('hidden');
            }

            showPdfScreen() {
                this.elements.homeScreen.classList.add('hidden');
                this.elements.pdfScreen.classList.remove('hidden');
            }

            toggleSettingsModal() {
                const isHidden = this.elements.settingsModal.classList.contains('hidden');
                if (isHidden) {
                    this.showSettingsModal();
                } else {
                    this.hideSettingsModal();
                }
            }

            showSettingsModal() {
                this.elements.settingsModal.classList.remove('hidden');
                this.updateModalForCurrentTool();
                this.updatePreview(this.currentTool);
                this.updateColorSelection();
            }

            hideSettingsModal() {
                this.elements.settingsModal.classList.add('hidden');
            }

            setColor(color) {
                this.strokeColor = color;
                this.updateColorSelection();
            }

            updateColorSelection() {
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.classList.toggle('ring-2', btn.dataset.color === this.strokeColor);
                    btn.classList.toggle('ring-primary', btn.dataset.color === this.strokeColor);
                });
            }

            updateModalForCurrentTool() {
                const penSettings = document.getElementById('penSettings');
                const eraserSettings = document.getElementById('eraserSettings');
                
                penSettings.classList.toggle('hidden', this.currentTool !== 'pen');
                eraserSettings.classList.toggle('hidden', this.currentTool !== 'eraser');
            }

            updatePreview(tool) {
                if (tool === 'pen') {
                    this.updatePenSizePreview();
                } else if (tool === 'eraser') {
                    this.updateEraserSizePreview();
                }
            }

            updatePenSizePreview() {
                const preview = document.getElementById('penSizePreview');
                const size = this.penSize;
                preview.style.width = size + 'px';
                preview.style.height = size + 'px';
            }

            updateEraserSizePreview() {
                const preview = document.getElementById('eraserSizePreview');
                const size = this.eraserSize;
                preview.style.width = size + 'px';
                preview.style.height = size + 'px';
            }

            updateEraserCursor() {
                const cursor = this.elements.eraserCursor;
                cursor.style.width = this.eraserSize + 'px';
                cursor.style.height = this.eraserSize + 'px';
            }

            positionEraserCursor(x, y) {
                const cursor = this.elements.eraserCursor;
                cursor.style.left = x + 'px';
                cursor.style.top = y + 'px';
            }

            showEraserCursor() {
                if (this.currentTool === 'eraser') {
                    this.elements.eraserCursor.style.display = 'block';
                }
            }

            hideEraserCursor() {
                this.elements.eraserCursor.style.display = 'none';
            }

            togglePressureSensitivity() {
                this.pressureSensitive = !this.pressureSensitive;
                const toggle = document.getElementById('pressureToggle');
                const slider = toggle.querySelector('span');
                const status = document.getElementById('pressureStatus');
                
                toggle.classList.toggle('bg-primary', this.pressureSensitive);
                toggle.classList.toggle('bg-gray-200', !this.pressureSensitive);
                toggle.classList.toggle('dark:bg-gray-600', !this.pressureSensitive);
                
                slider.classList.toggle('translate-x-5', this.pressureSensitive);
                slider.classList.toggle('translate-x-1', !this.pressureSensitive);
                
                // Update status text
                status.textContent = this.pressureSensitive ? 'Enabled' : 'Disabled';
                
                // Update pressure display
                this.updatePressureDisplay();
            }

            showCursor() {
                // Show crosshair cursor for mouse/trackpad usage
                if (!this.cursorVisible) {
                    this.cursorVisible = true;
                    if (this.currentTool === 'pen') {
                        this.elements.annotationCanvas.style.cursor = 'crosshair';
                    }
                }
                
                // Clear existing timeout
                if (this.cursorTimeout) {
                    clearTimeout(this.cursorTimeout);
                }
                
                // Hide cursor after 2 seconds of no mouse movement
                this.cursorTimeout = setTimeout(() => {
                    this.hideCursor();
                }, 2000);
            }
            
            hideCursor() {
                this.cursorVisible = false;
                this.elements.annotationCanvas.style.cursor = 'none';
                
                if (this.cursorTimeout) {
                    clearTimeout(this.cursorTimeout);
                    this.cursorTimeout = null;
                }
            }

            updateUI() {
                this.updatePreview(this.currentTool);
                this.updateColorSelection();
                this.updateEraserCursor();
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new PDFAnnotator();
        });
    </script>


</body></html>
