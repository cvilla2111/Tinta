<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Canvas</title>
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlZlY3RvciBDYW52YXMiLAogICJzaG9ydF9uYW1lIjogIkNhbnZhcyIsCiAgInN0YXJ0X3VybCI6ICIvIiwKICAiZGlzcGxheSI6ICJmdWxsc2NyZWVuIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjZmZmZmZmIiwKICAidGhlbWVfY29sb3IiOiAiI2ZmZmZmZiIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5EZ2lJR2hsYVdkb2REMGlORGdpSUhabGQzZENiM2c5SWpBZ01DQTBPRUEwT0NJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdVpuTXViM0puTHpJd01EQXZjM1puSWo0TkNqeHlaV04wSUhkcFpIUm9QU0kwT0NJZ2FHVnBaMmgwUFNJME9DSWdabWxzYkQwaVkyWm1abVptWmlJdlBnMEtQQzl6ZG1jKyIsCiAgICAgICJzaXplcyI6ICI0OHg0OCIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXQp9">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
            background: white;
            touch-action: none;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: white;
            cursor: crosshair;
        }
        
        #canvas.eraser-mode {
            cursor: none;
        }
        
        .eraser-cursor {
            position: fixed;
            border: 2px dashed #ff0000;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            background: rgba(255, 0, 0, 0.1);
            display: none;
        }
        
        .drawing-path {
            stroke: #000000;
            stroke-linecap: round;
            stroke-linejoin: round;
            vector-effect: non-scaling-stroke;
        }
        
        #clearButton {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 35px;
            height: 35px;
            border-radius: 4px;
            background: white;
            border: 0.75px solid #000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.2s ease;
        }
        
        #clearButton:hover {
            background: #f5f5f5;
            transform: scale(1.05);
        }
        
        #clearButton:active {
            transform: scale(0.95);
        }
        
        #menuButton {
            position: fixed;
            top: 16px;
            left: 16px;
            width: 35px;
            height: 35px;
            border-radius: 4px;
            background: white;
            border: 0.75px solid #000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: all 0.2s ease;
        }
        
        #menuButton:hover {
            background: #f5f5f5;
            transform: scale(1.05);
        }
        
        #menuButton:active {
            transform: scale(0.95);
        }
        
        #slidePanel {
            position: fixed;
            top: 0;
            left: -300px;
            width: 300px;
            height: 100vh;
            background: white;
            border-right: 0.75px solid #000;
            z-index: 1000;
            transition: left 0.3s ease;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        #slidePanel.open {
            left: 0;
        }
        
        #slidePanel h3 {
            margin: 0 0 20px 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: #000;
        }
        
        #slidePanel .panel-section {
            margin-bottom: 20px;
        }
        
        #slidePanel .panel-section label {
            display: block;
            margin-bottom: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: #000;
        }
        
        .color-palette {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.selected {
            border-color: #000;
            transform: scale(1.1);
        }
        
        .stroke-stepper {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .stepper-button {
            width: 30px;
            height: 30px;
            border: 0.75px solid #000;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        
        .stepper-button:hover {
            background: #f5f5f5;
        }
        
        .stepper-button:active {
            transform: scale(0.95);
        }
        
        .stroke-value {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            font-weight: 500;
            min-width: 40px;
            text-align: center;
        }
        
        .pressure-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .pressure-toggle input[type="checkbox"] {
            display: none;
        }
        
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: #ccc;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .toggle-switch:hover {
            background: #bbb;
        }
        
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        input[type="checkbox"]:checked + .toggle-switch {
            background: #5D5CDE;
        }
        
        input[type="checkbox"]:checked + .toggle-switch .toggle-slider {
            transform: translateX(20px);
        }
        
        .toggle-label {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: #000;
        }
        
        .pressure-controls {
            transition: all 0.3s ease;
        }
        
        .pressure-controls.hidden {
            opacity: 0.3;
            pointer-events: none;
            transform: translateX(-10px);
        }
        
        .stroke-width-control {
            transition: all 0.3s ease;
        }
        
        .stroke-width-control.hidden {
            opacity: 0.3;
            pointer-events: none;
            transform: translateX(-10px);
        }
        
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        #loadingOverlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f0f0f0;
            border-top: 3px solid #5D5CDE;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            text-align: center;
        }
        
        .loading-subtext {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            color: #999;
            margin-top: 8px;
            text-align: center;
        }
    </style>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script>
</head>
<body>
    <div id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Vector Canvas</div>
        <div class="loading-subtext">Initializing drawing engine...</div>
    </div>
    
    <svg id="canvas" xmlns="http://www.w3.org/2000/svg"></svg>
    
    <div id="eraserCursor" class="eraser-cursor"></div>
    
    <button id="menuButton" onclick="togglePanel()" title="Open menu">
        <i data-lucide="menu" style="width: 24px; height: 24px; stroke-width: 0.75px;"></i>
    </button>
    
    <button id="clearButton" onclick="clearCanvas()" title="Clear canvas">
        <i data-lucide="trash" style="width: 24px; height: 24px; stroke-width: 0.75px;"></i>
    </button>
    
    <div id="slidePanel">
        <h3>Drawing Tools</h3>
        
        <div class="panel-section stroke-width-control">
            <label>Stroke Width</label>
            <div class="stroke-stepper">
                <button class="stepper-button" onclick="changeStrokeWidth(-0.5)">−</button>
                <span class="stroke-value" id="strokeValue">2.0</span>
                <button class="stepper-button" onclick="changeStrokeWidth(0.5)">+</button>
            </div>
        </div>
        
        <div class="panel-section">
            <label>Pressure Sensitivity</label>
            <div class="pressure-toggle">
                <input type="checkbox" id="pressureToggle" checked>
                <label for="pressureToggle" class="toggle-switch">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">Enabled</span>
            </div>
        </div>
        
        <div class="panel-section pressure-controls">
            <label>Min Width</label>
            <div class="stroke-stepper">
                <button class="stepper-button" onclick="changeMinWidth(-0.1)">−</button>
                <span class="stroke-value" id="minWidthValue">0.1</span>
                <button class="stepper-button" onclick="changeMinWidth(0.1)">+</button>
            </div>
        </div>
        
        <div class="panel-section pressure-controls">
            <label>Max Width</label>
            <div class="stroke-stepper">
                <button class="stepper-button" onclick="changeMaxWidth(-0.1)">−</button>
                <span class="stroke-value" id="maxWidthValue">2.5</span>
                <button class="stepper-button" onclick="changeMaxWidth(0.1)">+</button>
            </div>
        </div>
        
        <div class="panel-section pressure-controls">
            <label>Sensitivity</label>
            <div class="stroke-stepper">
                <button class="stepper-button" onclick="changeSensitivity(-0.1)">−</button>
                <span class="stroke-value" id="sensitivityValue">0.3</span>
                <button class="stepper-button" onclick="changeSensitivity(0.1)">+</button>
            </div>
        </div>
        
        <div class="panel-section">
            <label>Smoothing</label>
            <div class="stroke-stepper">
                <button class="stepper-button" onclick="changeSmoothing(-0.1)">−</button>
                <span class="stroke-value" id="smoothingValue">1.0</span>
                <button class="stepper-button" onclick="changeSmoothing(0.1)">+</button>
            </div>
        </div>
        
        <div class="panel-section">
            <label>Stroke Color</label>
            <div class="color-palette">
                <div class="color-option selected" style="background-color: #000000;" data-color="#000000"></div>
                <div class="color-option" style="background-color: #FF0000;" data-color="#FF0000"></div>
                <div class="color-option" style="background-color: #00FF00;" data-color="#00FF00"></div>
                <div class="color-option" style="background-color: #0000FF;" data-color="#0000FF"></div>
                <div class="color-option" style="background-color: #FFFF00;" data-color="#FFFF00"></div>
                <div class="color-option" style="background-color: #FFA500;" data-color="#FFA500"></div>
                <div class="color-option" style="background-color: #800080;" data-color="#800080"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            const swCode = `
                const CACHE_NAME = 'vector-canvas-v1';
                
                self.addEventListener('install', (event) => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then((cache) => {
                            return cache.addAll(['/']);
                        })
                    );
                });
                
                self.addEventListener('fetch', (event) => {
                    event.respondWith(
                        caches.match(event.request).then((response) => {
                            return response || fetch(event.request);
                        })
                    );
                });
            `;
            
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);
            
            navigator.serviceWorker.register(swUrl);
        }
        
        // SVG Setup
        const svg = document.getElementById('canvas');
        let currentPath = null;
        let isDrawing = false;
        let paths = []; // Store all drawing paths
        let baseViewport = { width: window.innerWidth, height: window.innerHeight };
        let currentStrokeWidth = 2;
        
        function calculateStrokeWidth() {
            // Base stroke width on viewport diagonal for consistent appearance across devices
            const diagonal = Math.sqrt(window.innerWidth ** 2 + window.innerHeight ** 2);
            return Math.max(1, diagonal / 500); // Adjust divisor to control thickness
        }
        
        function updateAllStrokeWidths() {
            currentStrokeWidth = calculateStrokeWidth();
            // Update all existing paths
            const allPaths = svg.querySelectorAll('.drawing-path');
            allPaths.forEach(path => {
                path.setAttribute('stroke-width', currentStrokeWidth);
            });
        }
        
        function resizeSVG() {
            svg.setAttribute('width', window.innerWidth);
            svg.setAttribute('height', window.innerHeight);
            
            // Keep the original viewBox but scale content to fit
            svg.setAttribute('viewBox', `0 0 ${baseViewport.width} ${baseViewport.height}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            
            updateAllStrokeWidths();
        }
        
        // Initialize with proper loading sequence
        async function initializeCanvas() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const subtext = loadingOverlay.querySelector('.loading-subtext');
            
            try {
                // Step 1: Initialize viewport
                subtext.textContent = 'Setting up canvas...';
                await new Promise(resolve => setTimeout(resolve, 200));
                resizeSVG();
                
                // Step 2: Calculate stroke widths
                subtext.textContent = 'Calculating stroke widths...';
                await new Promise(resolve => setTimeout(resolve, 200));
                updateAllStrokeWidths();
                
                // Step 3: Initialize UI controls
                subtext.textContent = 'Initializing controls...';
                await new Promise(resolve => setTimeout(resolve, 200));
                updatePressureControlsVisibility();
                
                // Step 4: Load Lucide icons
                subtext.textContent = 'Loading icons...';
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Step 5: Final setup
                subtext.textContent = 'Ready to draw!';
                await new Promise(resolve => setTimeout(resolve, 200));
                
                console.log('Canvas fully initialized and ready');
                
                // Hide loading overlay with smooth transition
                loadingOverlay.classList.add('hidden');
                
                // Remove loading overlay from DOM after transition
                setTimeout(() => {
                    loadingOverlay.remove();
                }, 500);
                
            } catch (error) {
                console.error('Error during initialization:', error);
                subtext.textContent = 'Error loading app. Please refresh.';
            }
        }
        
        // Initialize with proper sequence after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeCanvas);
        } else {
            initializeCanvas();
        }
        
        window.addEventListener('resize', resizeSVG);
        
        // Drawing functionality
        let currentPoints = []; // Store points for current stroke
        const SMOOTH_WINDOW = 4; // Number of recent points to keep smooth
        let isPressureSupported = false;
        let pressureSensitivityEnabled = true; // User toggle for pressure sensitivity
        let isEraserMode = false; // Track if we're in eraser mode
        let eraserRadius = 20; // Eraser size in pixels
        
        // Pressure settings
        let minWidthMultiplier = 0.1; // Minimum width as multiplier of base width
        let maxWidthMultiplier = 2.5; // Maximum width as multiplier of base width  
        let pressureSensitivity = 0.3; // Sensitivity curve adjustment
        let smoothingIntensity = 1.0; // Universal smoothing intensity (0 = none, 1 = maximum)
        
        function getCoords(e) {
            const rect = svg.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const pressure = e.pressure || (e.touches && e.touches[0].force) || 0.5; // Default to 0.5 if no pressure
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top,
                pressure: Math.max(0.1, Math.min(1.0, pressure)) // Clamp pressure between 0.1 and 1.0
            };
        }
        
        function getPressureStrokeWidth(pressure) {
            // Apply sensitivity curve to pressure (0.1 to 1.0)
            const adjustedPressure = Math.pow(pressure, 1 / pressureSensitivity);
            
            // Calculate multiplier between min and max width
            const range = maxWidthMultiplier - minWidthMultiplier;
            const pressureMultiplier = minWidthMultiplier + (adjustedPressure * range);
            
            const diagonal = Math.sqrt(window.innerWidth ** 2 + window.innerHeight ** 2);
            return Math.max(1, (diagonal / 500) * baseStrokeWidth * pressureMultiplier);
        }
        
        let currentColor = '#000000'; // Track current drawing color
        
        function startDrawing(e) {
            isDrawing = true;
            const coords = getCoords(e);
            
            // Reset points array for new stroke
            currentPoints = [coords];
            
            // Create new path element
            currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            currentPath.setAttribute('class', 'drawing-path');
            
            // Check both hardware capability AND user toggle
            const usePressure = isPressureSupported && pressureSensitivityEnabled;
            
            if (usePressure) {
                // For pressure-sensitive drawing, use fill instead of stroke
                currentPath.setAttribute('fill', currentColor);
                currentPath.setAttribute('stroke', 'none');
            } else {
                // Standard stroke-based drawing
                currentPath.setAttribute('stroke', currentColor);
                currentPath.setAttribute('stroke-width', currentStrokeWidth);
                currentPath.setAttribute('fill', 'none');
            }
            
            currentPath.setAttribute('d', `M ${coords.x} ${coords.y}`);
            
            svg.appendChild(currentPath);
            paths.push({
                element: currentPath,
                points: currentPoints
            });
        }
        
        function draw(e) {
            if (!isDrawing || !currentPath) return;
            
            const coords = getCoords(e);
            
            // Add new point
            currentPoints.push(coords);
            
            // Check both hardware capability AND user toggle
            const usePressure = isPressureSupported && pressureSensitivityEnabled;
            
            if (usePressure) {
                // Use pressure-sensitive variable width stroke
                updatePressurePath();
            } else {
                // Standard drawing without pressure sensitivity
                updateSmoothPath();
            }
        }
        
        function updatePressurePath() {
            if (currentPoints.length < 2) return;
            
            // Calculate variable-width stroke outline
            const strokeOutline = calculateVariableStroke(currentPoints);
            
            if (strokeOutline) {
                currentPath.setAttribute('d', strokeOutline);
            }
        }
        
        function calculateVariableStroke(points) {
            if (points.length < 2) return null;
            
            // First, create smooth center line points using smoothing intensity
            const smoothedPoints = createSmoothPoints(points, smoothingIntensity);
            
            const leftEdge = [];
            const rightEdge = [];
            
            for (let i = 0; i < smoothedPoints.length; i++) {
                const point = smoothedPoints[i];
                const width = getPressureStrokeWidth(point.pressure) / 2; // Half width for radius
                
                let normal;
                if (i === 0 && smoothedPoints.length > 1) {
                    // First point: use direction to next point
                    const next = smoothedPoints[i + 1];
                    normal = getNormal(point, next);
                } else if (i === smoothedPoints.length - 1) {
                    // Last point: use direction from previous point
                    const prev = smoothedPoints[i - 1];
                    normal = getNormal(prev, point);
                } else {
                    // Middle point: average normals from both directions
                    const prev = smoothedPoints[i - 1];
                    const next = smoothedPoints[i + 1];
                    const normal1 = getNormal(prev, point);
                    const normal2 = getNormal(point, next);
                    normal = {
                        x: (normal1.x + normal2.x) / 2,
                        y: (normal1.y + normal2.y) / 2
                    };
                    // Normalize
                    const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                    if (length > 0) {
                        normal.x /= length;
                        normal.y /= length;
                    }
                }
                
                // Calculate left and right edge points
                leftEdge.push({
                    x: point.x + normal.x * width,
                    y: point.y + normal.y * width
                });
                
                rightEdge.push({
                    x: point.x - normal.x * width,
                    y: point.y - normal.y * width
                });
            }
            
            // Add round caps to the start and end
            const firstPoint = smoothedPoints[0];
            const lastPoint = smoothedPoints[smoothedPoints.length - 1];
            const firstWidth = getPressureStrokeWidth(firstPoint.pressure) / 2;
            const lastWidth = getPressureStrokeWidth(lastPoint.pressure) / 2;
            
            // Build path with round caps
            let pathData = '';
            
            // Start cap (semicircle)
            pathData += `M ${leftEdge[0].x} ${leftEdge[0].y}`;
            pathData += ` A ${firstWidth} ${firstWidth} 0 0 1 ${rightEdge[0].x} ${rightEdge[0].y}`;
            
            // Right edge (backward) - from start to end
            if (rightEdge.length > 2 && smoothingIntensity > 0) {
                for (let i = 1; i < rightEdge.length - 1; i++) {
                    const current = rightEdge[i];
                    const next = rightEdge[i + 1];
                    const endX = current.x + (next.x - current.x) * smoothingIntensity;
                    const endY = current.y + (next.y - current.y) * smoothingIntensity;
                    pathData += ` Q ${current.x} ${current.y} ${endX} ${endY}`;
                }
                // Final segment to end
                const lastRight = rightEdge[rightEdge.length - 1];
                const secondLastRight = rightEdge[rightEdge.length - 2];
                pathData += ` Q ${secondLastRight.x} ${secondLastRight.y} ${lastRight.x} ${lastRight.y}`;
            } else {
                for (let i = 1; i < rightEdge.length; i++) {
                    pathData += ` L ${rightEdge[i].x} ${rightEdge[i].y}`;
                }
            }
            
            // End cap (semicircle)
            pathData += ` A ${lastWidth} ${lastWidth} 0 0 1 ${leftEdge[leftEdge.length - 1].x} ${leftEdge[leftEdge.length - 1].y}`;
            
            // Left edge (backward) - from end to start
            if (leftEdge.length > 2 && smoothingIntensity > 0) {
                for (let i = leftEdge.length - 2; i > 0; i--) {
                    const current = leftEdge[i];
                    const next = leftEdge[i - 1];
                    const endX = current.x + (next.x - current.x) * smoothingIntensity;
                    const endY = current.y + (next.y - current.y) * smoothingIntensity;
                    pathData += ` Q ${current.x} ${current.y} ${endX} ${endY}`;
                }
            } else {
                for (let i = leftEdge.length - 2; i >= 0; i--) {
                    pathData += ` L ${leftEdge[i].x} ${leftEdge[i].y}`;
                }
            }
            
            // Close the path
            pathData += ' Z';
            
            return pathData;
        }
        
        function createSmoothPoints(rawPoints, smoothingIntensity) {
            if (rawPoints.length < 3 || smoothingIntensity === 0) return rawPoints;
            
            const smoothedPoints = [];
            
            // Add first point as-is
            smoothedPoints.push(rawPoints[0]);
            
            // Create interpolated points along the smooth curve with intensity control
            for (let i = 1; i < rawPoints.length - 1; i++) {
                const prev = rawPoints[i - 1];
                const current = rawPoints[i];
                const next = rawPoints[i + 1];
                
                // Add the current point (possibly smoothed toward average)
                if (smoothingIntensity > 0 && i > 0 && i < rawPoints.length - 1) {
                    // Smooth current point toward average of neighbors
                    const avgX = (prev.x + next.x) / 2;
                    const avgY = (prev.y + next.y) / 2;
                    const avgPressure = (prev.pressure + next.pressure) / 2;
                    
                    const smoothedPoint = {
                        x: current.x + (avgX - current.x) * smoothingIntensity * 0.3,
                        y: current.y + (avgY - current.y) * smoothingIntensity * 0.3,
                        pressure: current.pressure + (avgPressure - current.pressure) * smoothingIntensity * 0.2
                    };
                    smoothedPoints.push(smoothedPoint);
                } else {
                    smoothedPoints.push(current);
                }
                
                // Add interpolated point between current and next with smoothing intensity
                if (i < rawPoints.length - 2) {
                    const interpolationStrength = 0.5 * smoothingIntensity;
                    const interpolated = {
                        x: current.x + (next.x - current.x) * interpolationStrength,
                        y: current.y + (next.y - current.y) * interpolationStrength,
                        pressure: current.pressure + (next.pressure - current.pressure) * interpolationStrength
                    };
                    smoothedPoints.push(interpolated);
                }
            }
            
            // Add last point as-is
            smoothedPoints.push(rawPoints[rawPoints.length - 1]);
            
            return smoothedPoints;
        }
        
        function getNormal(p1, p2) {
            // Get perpendicular normal vector
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) return { x: 0, y: 1 };
            
            // Perpendicular vector (rotate 90 degrees)
            return {
                x: -dy / length,
                y: dx / length
            };
        }
        
        function updateSmoothPath() {
            if (currentPoints.length < 2) return;
            
            let pathData = `M ${currentPoints[0].x} ${currentPoints[0].y}`;
            
            if (currentPoints.length === 2 || smoothingIntensity === 0) {
                // Just a line for the first segment or when smoothing is disabled
                for (let i = 1; i < currentPoints.length; i++) {
                    pathData += ` L ${currentPoints[i].x} ${currentPoints[i].y}`;
                }
            } else {
                // Create smooth curves with intensity control
                for (let i = 1; i < currentPoints.length - 1; i++) {
                    const current = currentPoints[i];
                    const next = currentPoints[i + 1];
                    
                    // Control smoothing intensity - higher values make more aggressive smoothing
                    const smoothFactor = 0.5 * smoothingIntensity;
                    const endX = current.x + (next.x - current.x) * smoothFactor;
                    const endY = current.y + (next.y - current.y) * smoothFactor;
                    
                    pathData += ` Q ${current.x} ${current.y} ${endX} ${endY}`;
                }
                
                // Add final segment to the last point with smoothing
                const lastPoint = currentPoints[currentPoints.length - 1];
                const secondLast = currentPoints[currentPoints.length - 2];
                
                if (smoothingIntensity > 0) {
                    const smoothFactor = 0.5 * smoothingIntensity;
                    const endX = secondLast.x + (lastPoint.x - secondLast.x) * (1 - smoothFactor);
                    const endY = secondLast.y + (lastPoint.y - secondLast.y) * (1 - smoothFactor);
                    pathData += ` Q ${endX} ${endY} ${lastPoint.x} ${lastPoint.y}`;
                } else {
                    pathData += ` L ${lastPoint.x} ${lastPoint.y}`;
                }
            }
            
            currentPath.setAttribute('d', pathData);
        }
        
        function stopDrawing() {
            isDrawing = false;
            currentPath = null;
            currentPoints = [];
        }
        
        // Export functionality
        function exportSVG() {
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'vector-drawing.svg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Clear canvas
        function clearCanvas() {
            svg.innerHTML = '';
            paths = [];
        }
        
        // Eraser functionality
        function setEraserMode(enabled) {
            isEraserMode = enabled;
            const eraserCursor = document.getElementById('eraserCursor');
            
            if (enabled) {
                svg.classList.add('eraser-mode');
                eraserCursor.style.display = 'block';
                console.log('Eraser mode activated');
            } else {
                svg.classList.remove('eraser-mode');
                eraserCursor.style.display = 'none';
                console.log('Drawing mode activated');
            }
        }
        
        function updateEraserCursor(x, y) {
            const eraserCursor = document.getElementById('eraserCursor');
            const size = eraserRadius * 2;
            eraserCursor.style.width = size + 'px';
            eraserCursor.style.height = size + 'px';
            eraserCursor.style.left = (x - eraserRadius) + 'px';
            eraserCursor.style.top = (y - eraserRadius) + 'px';
        }
        
        function eraseAtPoint(x, y) {
            // Check all paths for intersection with eraser circle
            const allPaths = svg.querySelectorAll('.drawing-path');
            const eraserBounds = {
                x: x - eraserRadius,
                y: y - eraserRadius,
                width: eraserRadius * 2,
                height: eraserRadius * 2
            };
            
            allPaths.forEach(path => {
                const pathBounds = path.getBBox();
                
                // Quick bounding box check first
                if (pathBounds.x < eraserBounds.x + eraserBounds.width &&
                    pathBounds.x + pathBounds.width > eraserBounds.x &&
                    pathBounds.y < eraserBounds.y + eraserBounds.height &&
                    pathBounds.y + pathBounds.height > eraserBounds.y) {
                    
                    // More precise check: test if eraser circle intersects with path
                    if (pathIntersectsCircle(path, x, y, eraserRadius)) {
                        // Remove the entire path for simplicity
                        path.remove();
                        
                        // Remove from paths array
                        const pathIndex = paths.findIndex(p => p.element === path);
                        if (pathIndex > -1) {
                            paths.splice(pathIndex, 1);
                        }
                    }
                }
            });
        }
        
        function pathIntersectsCircle(pathElement, circleX, circleY, radius) {
            // Sample points along the path to check intersection
            const pathLength = pathElement.getTotalLength();
            const sampleDistance = 5; // Check every 5 pixels along path
            
            for (let i = 0; i <= pathLength; i += sampleDistance) {
                const point = pathElement.getPointAtLength(i);
                const distance = Math.sqrt(
                    Math.pow(point.x - circleX, 2) + 
                    Math.pow(point.y - circleY, 2)
                );
                
                if (distance <= radius) {
                    return true; // Intersection found
                }
            }
            
            return false; // No intersection
        }
        
        function startErasing(e) {
            const coords = getCoords(e);
            eraseAtPoint(coords.x, coords.y);
            isDrawing = true; // Track that we're in an erasing session
        }
        
        function continueErasing(e) {
            if (!isDrawing) return;
            const coords = getCoords(e);
            eraseAtPoint(coords.x, coords.y);
        }
        
        function stopErasing() {
            isDrawing = false;
        }
        
        // Pointer Events with eraser support
        if (window.PointerEvent) {
            svg.addEventListener('pointerdown', (e) => {
                // Only allow pen and mouse input, disable finger touch
                if (e.pointerType === 'touch') {
                    return; // Block finger touch
                }
                
                // Detect eraser button: buttons value of 32 indicates eraser button pressed
                const isEraserPressed = (e.buttons === 32) || (e.button === 5);
                
                if (e.pointerType === 'pen') {
                    isPressureSupported = e.pressure > 0;
                    setEraserMode(isEraserPressed);
                }
                
                svg.setPointerCapture(e.pointerId);
                
                if (isEraserMode) {
                    startErasing(e);
                } else {
                    startDrawing(e);
                }
            });
            
            svg.addEventListener('pointermove', (e) => {
                // Only allow pen and mouse input
                if (e.pointerType === 'touch') {
                    return; // Block finger touch
                }
                
                // Update eraser cursor position if in eraser mode
                if (isEraserMode) {
                    updateEraserCursor(e.clientX, e.clientY);
                    continueErasing(e);
                } else {
                    draw(e);
                }
            });
            
            svg.addEventListener('pointerup', (e) => {
                // Only allow pen and mouse input
                if (e.pointerType === 'touch') {
                    return; // Block finger touch
                }
                
                // Check if eraser button is released
                const isEraserPressed = (e.buttons === 32) || (e.button === 5);
                
                if (e.pointerType === 'pen') {
                    setEraserMode(isEraserPressed);
                }
                
                if (isEraserMode) {
                    stopErasing();
                } else {
                    stopDrawing();
                }
            });
            
            svg.addEventListener('pointerleave', (e) => {
                // Only allow pen and mouse input
                if (e.pointerType === 'touch') {
                    return; // Block finger touch
                }
                
                if (isEraserMode) {
                    stopErasing();
                } else {
                    stopDrawing();
                }
                
                // Hide eraser cursor when leaving canvas
                const eraserCursor = document.getElementById('eraserCursor');
                eraserCursor.style.display = 'none';
            });
            
            // Track pointer movement over entire document for eraser cursor
            document.addEventListener('pointermove', (e) => {
                if (isEraserMode && e.pointerType === 'pen') {
                    updateEraserCursor(e.clientX, e.clientY);
                }
            });
            
            console.log('Pen and mouse drawing enabled with eraser support (finger touch disabled)');
        } else {
            // Fallback to mouse events only (no touch support)
            // Mouse events
            svg.addEventListener('mousedown', startDrawing);
            svg.addEventListener('mousemove', draw);
            svg.addEventListener('mouseup', stopDrawing);
            svg.addEventListener('mouseleave', stopDrawing);
            
            console.log('Mouse-only drawing mode (touch disabled, no eraser support)');
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                exportSVG();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'Backspace') {
                e.preventDefault();
                clearCanvas();
            }
        });
        
        // Prevent default behaviors
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('selectstart', (e) => e.preventDefault());
        
        // Panel functionality
        let panelOpen = false;
        
        function togglePanel() {
            const panel = document.getElementById('slidePanel');
            const menuButton = document.getElementById('menuButton');
            panelOpen = !panelOpen;
            
            if (panelOpen) {
                panel.classList.add('open');
                // Hide menu button when panel opens
                menuButton.style.opacity = '0';
                menuButton.style.pointerEvents = 'none';
            } else {
                panel.classList.remove('open');
                // Show menu button when panel closes
                menuButton.style.opacity = '1';
                menuButton.style.pointerEvents = 'auto';
            }
        }
        
        // Tool controls
        let baseStrokeWidth = 2.0;
        
        function changeStrokeWidth(delta) {
            baseStrokeWidth = Math.max(0.5, Math.min(10, baseStrokeWidth + delta));
            document.getElementById('strokeValue').textContent = baseStrokeWidth.toFixed(1);
            
            // Apply the same scaling as the viewport-based calculation
            const diagonal = Math.sqrt(window.innerWidth ** 2 + window.innerHeight ** 2);
            currentStrokeWidth = Math.max(1, (diagonal / 500) * baseStrokeWidth);
        }
        
        // Pressure control functions
        function changeMinWidth(delta) {
            minWidthMultiplier = Math.max(0.1, Math.min(1.0, minWidthMultiplier + delta));
            // Ensure min is always less than max
            if (minWidthMultiplier >= maxWidthMultiplier) {
                minWidthMultiplier = maxWidthMultiplier - 0.1;
            }
            document.getElementById('minWidthValue').textContent = minWidthMultiplier.toFixed(1);
        }
        
        function changeMaxWidth(delta) {
            maxWidthMultiplier = Math.max(0.2, Math.min(3.0, maxWidthMultiplier + delta));
            // Ensure max is always greater than min
            if (maxWidthMultiplier <= minWidthMultiplier) {
                maxWidthMultiplier = minWidthMultiplier + 0.1;
            }
            document.getElementById('maxWidthValue').textContent = maxWidthMultiplier.toFixed(1);
        }
        
        function changeSensitivity(delta) {
            pressureSensitivity = Math.max(0.1, Math.min(3.0, pressureSensitivity + delta));
            document.getElementById('sensitivityValue').textContent = pressureSensitivity.toFixed(1);
        }
        
        function changeSmoothing(delta) {
            smoothingIntensity = Math.max(0.0, Math.min(1.0, smoothingIntensity + delta));
            document.getElementById('smoothingValue').textContent = smoothingIntensity.toFixed(1);
        }
        
        function updatePressureControlsVisibility() {
            const pressureControls = document.querySelectorAll('.pressure-controls');
            const strokeWidthControl = document.querySelector('.stroke-width-control');
            
            if (pressureSensitivityEnabled) {
                // Pressure ON: Show pressure controls, hide stroke width
                pressureControls.forEach(control => control.classList.remove('hidden'));
                strokeWidthControl.classList.add('hidden');
            } else {
                // Pressure OFF: Hide pressure controls, show stroke width
                pressureControls.forEach(control => control.classList.add('hidden'));
                strokeWidthControl.classList.remove('hidden');
            }
        }
        
        // Pressure sensitivity toggle
        document.getElementById('pressureToggle').addEventListener('change', (e) => {
            pressureSensitivityEnabled = e.target.checked;
            const label = document.querySelector('.toggle-label');
            label.textContent = pressureSensitivityEnabled ? 'Enabled' : 'Disabled';
            
            updatePressureControlsVisibility();
            
            console.log(`Pressure sensitivity ${pressureSensitivityEnabled ? 'enabled' : 'disabled'}`);
        });
        
        // Color palette functionality
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', (e) => {
                // Remove selected class from all options
                document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                
                // Add selected class to clicked option
                e.target.classList.add('selected');
                
                const color = e.target.dataset.color;
                // Update current color for new strokes
                currentColor = color;
                
                // Update the CSS class for both stroke and fill (covers both drawing modes)
                const style = document.createElement('style');
                style.textContent = `.drawing-path { stroke: ${color}; fill: ${color}; }`;
                document.head.appendChild(style);
            });
        });
        
        // Close panel when clicking/touching outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('slidePanel');
            const menuButton = document.getElementById('menuButton');
            
            if (panelOpen && !panel.contains(e.target) && !menuButton.contains(e.target)) {
                togglePanel();
            }
        });
        
        // Swipe gesture variables
        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeStartTime = 0;
        let isSwipeGesture = false;
        
        // Close panel when touching outside (finger/stylus touch)
        document.addEventListener('touchstart', (e) => {
            const panel = document.getElementById('slidePanel');
            const menuButton = document.getElementById('menuButton');
            
            // Get touch target
            const touch = e.touches[0];
            const touchTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (panelOpen) {
                // Record swipe start position if touching inside panel
                if (panel.contains(touchTarget)) {
                    swipeStartX = touch.clientX;
                    swipeStartY = touch.clientY;
                    swipeStartTime = Date.now();
                    isSwipeGesture = true;
                } else if (!menuButton.contains(touchTarget)) {
                    // Close panel if touching outside panel and menu button
                    e.preventDefault(); // Prevent drawing when closing panel
                    togglePanel();
                }
            }
        });
        
        // Track swipe movement
        document.addEventListener('touchmove', (e) => {
            if (isSwipeGesture && panelOpen) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - swipeStartX;
                const deltaY = Math.abs(touch.clientY - swipeStartY);
                
                // If moving too much vertically, cancel swipe
                if (deltaY > 50) {
                    isSwipeGesture = false;
                }
            }
        });
        
        // Handle swipe end
        document.addEventListener('touchend', (e) => {
            if (isSwipeGesture && panelOpen) {
                const endTime = Date.now();
                const swipeTime = endTime - swipeStartTime;
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - swipeStartX;
                const deltaY = Math.abs(touch.clientY - swipeStartY);
                
                // Swipe left criteria: 
                // - Moved at least 100px to the left
                // - Less than 50px vertical movement
                // - Completed within 500ms
                if (deltaX < -100 && deltaY < 50 && swipeTime < 500) {
                    e.preventDefault();
                    togglePanel();
                }
                
                isSwipeGesture = false;
            }
        });
        
        // Initialize control visibility (pressure is enabled by default)
        updatePressureControlsVisibility();
        
        // Initialize Lucide icons
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
        
        // Add some basic info for users
        console.log('Vector Drawing Canvas');
        console.log('Ctrl+S: Export as SVG');
        console.log('Ctrl+Backspace: Clear canvas');
    </script>
</body>
</html>
