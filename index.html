<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MPP Stylus Drawing PWA</title>
    <meta name="description" content="A simple drawing app with MPP stylus support">
    <meta name="theme-color" content="#ffffff">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIk1QUCBTdHlsdXMgRHJhd2luZyBQV0EiLAogICJzaG9ydF9uYW1lIjogIkRyYXdpbmcgQXBwIiwKICAiZGVzY3JpcHRpb24iOiAiQSBzaW1wbGUgZHJhd2luZyBhcHAgd2l0aCBNUFAgc3R5bHVzIHN1cHBvcnQiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAiZnVsbHNjcmVlbiIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2ZmZmZmZiIsCiAgInRoZW1lX2NvbG9yIjogIiNmZmZmZmYiLAogICJvcmllbnRhdGlvbiI6ICJhbnkiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOVFlpSUdobGFXZG9kRDBpTWpVMklqNDhjbVZqZENCM2FXUjBhRDBpTWpVMklpQm9aV2xuYUhROU1qVTJJaUJtYVc5c1BTSjNhR2wwWlNJdlBqd3ZjM1puUGc9PSIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAic2l6ZXMiOiAiMjU2eDI1NiIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0k0TnpJaUlHaGxhV2RvZEQwaU9EY3lJajQ4Y21WamRDQjNhV1IwYUQwaU9EY3lJaUJvWldsbmFIUTlPRGN5SWlCbWFXeHNQU0ozYUdsMFpTSXZQand2YzNablBnPT0iLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInNpemVzIjogIjg3Mng4NzIiCiAgICB9CiAgXQp9">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9MjU2IiBmaWxsPSJ3aGl0ZSIvPjwvc3ZnPg==">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
            background: white;
            touch-action: none;
            user-select: none;
        }
        
        .app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .slide-panel {
            position: fixed;
            top: 0;
            left: -360px;
            width: 360px;
            height: 100vh;
            background: white;
            border-right: 0.5px solid #e0e0e0;
            z-index: 2000;
            transition: left 0.3s ease;
            overflow-y: auto;
            touch-action: auto;
            user-select: text;
        }
        
        .slide-panel.open {
            left: 0;
        }
        
        .panel-content {
            padding: 20px;
        }
        
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: white;
            cursor: crosshair;
            touch-action: none;
        }
        
        .controls-left {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 3000;
        }
        
        .controls-right {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            background: transparent;
            border: 0.5px solid black;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        
        .control-btn:hover {
            transform: scale(1.05);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-icon {
            width: 20px;
            height: 20px;
            stroke: black;
            stroke-width: 0.5;
            fill: none;
        }
        
        .panel-title {
            font-family: system-ui, sans-serif;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
            text-align: right;
            margin-right: 20px;
        }
        
        .section-title {
            font-family: system-ui, sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: #444;
            margin-bottom: 16px;
            margin-top: 24px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
        }
        
        .section-title:first-of-type {
            margin-top: 0;
        }
        
        .setting-group {
            margin-bottom: 18px;
        }
        
        .setting-label {
            font-family: system-ui, sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: #555;
            margin-bottom: 8px;
            display: block;
        }
        
        .slider-container {
            position: relative;
            margin-bottom: 6px;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            appearance: none;
            cursor: pointer;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #333;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #333;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-value {
            font-family: system-ui, sans-serif;
            font-size: 12px;
            color: #666;
            text-align: right;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .checkbox-label {
            font-family: system-ui, sans-serif;
            font-size: 14px;
            color: #555;
            cursor: pointer;
        }
        
        .curve-selector, .latency-mode-selector, .prediction-mode-selector {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        
        .curve-btn, .latency-btn, .prediction-btn {
            flex: 1;
            padding: 6px 8px;
            background: transparent;
            border: 0.5px solid #ccc;
            border-radius: 4px;
            font-family: system-ui, sans-serif;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .curve-btn.active, .latency-btn.active, .prediction-btn.active {
            background: #333;
            color: white;
            border-color: #333;
        }
        
        .curve-btn:hover, .latency-btn:hover, .prediction-btn:hover {
            border-color: #333;
        }
        
        .setting-description {
            font-family: system-ui, sans-serif;
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            line-height: 1.3;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="panel-overlay" id="panelOverlay"></div>
        
        <div class="slide-panel" id="slidePanel">
            <div class="panel-content">
                <h2 class="panel-title">Drawing Settings</h2>
                
                <div class="section-title">Pressure Settings</div>
                
                <div class="setting-group">
                    <label class="setting-label">Pressure Sensitivity</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="pressureSensitivity" min="0.1" max="3" step="0.1" value="1">
                    </div>
                    <div class="slider-value" id="pressureSensitivityValue">1.0x</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Minimum Width</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="minWidth" min="0.5" max="5" step="0.1" value="1">
                    </div>
                    <div class="slider-value" id="minWidthValue">1.0px</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Maximum Width</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="maxWidth" min="5" max="20" step="0.5" value="8">
                    </div>
                    <div class="slider-value" id="maxWidthValue">8.0px</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Pressure Curve</label>
                    <div class="curve-selector">
                        <button class="curve-btn active" data-curve="linear">Linear</button>
                        <button class="curve-btn" data-curve="ease">Ease</button>
                        <button class="curve-btn" data-curve="sharp">Sharp</button>
                    </div>
                </div>
                
                <div class="setting-group">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="enablePressure" checked>
                        <label class="checkbox-label" for="enablePressure">Enable Pressure</label>
                    </div>
                </div>
                
                <div class="section-title">Smoothing & Latency</div>
                
                <div class="setting-group">
                    <label class="setting-label">Line Smoothing</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="smoothing" min="0" max="10" step="1" value="3">
                    </div>
                    <div class="slider-value" id="smoothingValue">3</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Latency Reduction Mode</label>
                    <div class="latency-mode-selector">
                        <button class="latency-btn" data-mode="standard">Standard</button>
                        <button class="latency-btn active" data-mode="optimized">Optimized</button>
                        <button class="latency-btn" data-mode="ultra">Ultra</button>
                    </div>
                </div>
                
                <div class="section-title">Debouncing Settings</div>
                
                <div class="setting-group">
                    <label class="setting-label">Input Debouncing</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="debounceThreshold" min="0" max="20" step="1" value="5">
                    </div>
                    <div class="slider-value" id="debounceThresholdValue">5ms</div>
                    <div class="setting-description">Filters rapid input events to reduce noise</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Movement Threshold</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="movementThreshold" min="0" max="10" step="0.5" value="2">
                    </div>
                    <div class="slider-value" id="movementThresholdValue">2.0px</div>
                    <div class="setting-description">Minimum movement distance to register input</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Pressure Debouncing</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="pressureDebounce" min="0" max="10" step="1" value="3">
                    </div>
                    <div class="slider-value" id="pressureDebounceValue">3</div>
                    <div class="setting-description">Smooths pressure variations to reduce jitter</div>
                </div>
                
                <div class="setting-group">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="adaptiveDebouncing" checked>
                        <label class="checkbox-label" for="adaptiveDebouncing">Adaptive Debouncing</label>
                    </div>
                    <div class="setting-description">Automatically adjusts debouncing based on drawing speed</div>
                </div>
                
                <div class="section-title">Prediction Settings</div>
                
                <div class="setting-group">
                    <label class="setting-label">Prediction Strength</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="prediction" min="0" max="10" step="1" value="5">
                    </div>
                    <div class="slider-value" id="predictionValue">5</div>
                    <div class="setting-description">How far ahead to predict stylus movement</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Prediction Algorithm</label>
                    <div class="prediction-mode-selector">
                        <button class="prediction-btn active" data-mode="linear">Linear</button>
                        <button class="prediction-btn" data-mode="velocity">Velocity</button>
                        <button class="prediction-btn" data-mode="kalman">Kalman</button>
                    </div>
                    <div class="setting-description">Method used for calculating predicted positions</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Prediction Confidence</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="predictionConfidence" min="0" max="10" step="1" value="7">
                    </div>
                    <div class="slider-value" id="predictionConfidenceValue">7</div>
                    <div class="setting-description">How much to trust prediction vs actual input</div>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">Prediction Smoothing</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="predictionSmoothing" min="0" max="10" step="1" value="4">
                    </div>
                    <div class="slider-value" id="predictionSmoothingValue">4</div>
                    <div class="setting-description">Smooths predicted points to reduce artifacts</div>
                </div>
                
                <div class="setting-group">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="enablePrediction" checked>
                        <label class="checkbox-label" for="enablePrediction">Enable Prediction</label>
                    </div>
                </div>
                
                <div class="setting-group">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="correctionMode">
                        <label class="checkbox-label" for="correctionMode">Error Correction</label>
                    </div>
                    <div class="setting-description">Corrects prediction errors with actual input</div>
                </div>
                
                <div class="section-title">Performance</div>
                
                <div class="setting-group">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="frameRateBoost" checked>
                        <label class="checkbox-label" for="frameRateBoost">High Frame Rate Mode</label>
                    </div>
                </div>
                
                <div class="setting-group">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="directRendering" checked>
                        <label class="checkbox-label" for="directRendering">Direct Canvas Rendering</label>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <div class="controls-left">
                <button class="control-btn" id="panelToggle" title="Settings">
                    <svg class="control-icon" id="panelIcon" viewBox="0 0 24 24">
                        <rect width="18" height="18" x="3" y="3" rx="2"/>
                        <path d="M9 8h7"/>
                        <path d="M9 12h7"/>
                        <path d="M9 16h7"/>
                    </svg>
                </button>
            </div>
            
            <div class="controls-right">
                <button class="control-btn" id="clearCanvas" title="Clear canvas">
                    <svg class="control-icon" viewBox="0 0 24 24">
                        <path d="m3 6 18 0"/>
                        <path d="m19 6 0 14c0 1-1 2-2 2l-10 0c-1 0-2-1-2-2l0-14"/>
                        <path d="m8 6 0-2c0-1 1-2 2-2l4 0c0 1 1 2 1 2l0 2"/>
                        <line x1="10" x2="10" y1="11" y2="17"/>
                        <line x1="14" x2="14" y1="11" y2="17"/>
                    </svg>
                </button>
            </div>
            
            <canvas id="canvas"></canvas>
        </div>
    </div>
    
    <script>
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            const swCode = `
                const CACHE_NAME = 'drawing-pwa-v1';
                
                self.addEventListener('install', (event) => {
                    self.skipWaiting();
                });
                
                self.addEventListener('activate', (event) => {
                    event.waitUntil(self.clients.claim());
                });
                
                self.addEventListener('fetch', (event) => {
                    event.respondWith(
                        caches.match(event.request).then((response) => {
                            return response || fetch(event.request);
                        })
                    );
                });
            `;
            
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);
            
            navigator.serviceWorker.register(swUrl).then(() => {
                console.log('Service Worker registered');
            }).catch((error) => {
                console.log('Service Worker registration failed:', error);
            });
        }
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Panel elements
        const slidePanel = document.getElementById('slidePanel');
        const panelOverlay = document.getElementById('panelOverlay');
        const panelToggle = document.getElementById('panelToggle');
        const panelIcon = document.getElementById('panelIcon');
        
        // Icon SVG paths
        const menuIcon = `
            <rect width="18" height="18" x="3" y="3" rx="2"/>
            <path d="M9 8h7"/>
            <path d="M9 12h7"/>
            <path d="M9 16h7"/>
        `;
        
        const closeIcon = `
            <path d="m18 6-12 12"/>
            <path d="m6 6 12 12"/>
        `;
        
        // Panel functionality
        function togglePanel() {
            const isOpen = slidePanel.classList.contains('open');
            if (isOpen) {
                slidePanel.classList.remove('open');
                panelOverlay.classList.remove('active');
                panelIcon.innerHTML = menuIcon;
                panelToggle.setAttribute('title', 'Settings');
            } else {
                slidePanel.classList.add('open');
                panelOverlay.classList.add('active');
                panelIcon.innerHTML = closeIcon;
                panelToggle.setAttribute('title', 'Close');
            }
        }
        
        function closePanel() {
            slidePanel.classList.remove('open');
            panelOverlay.classList.remove('active');
            panelIcon.innerHTML = menuIcon;
            panelToggle.setAttribute('title', 'Settings');
        }
        
        // Panel event listeners
        panelToggle.addEventListener('click', togglePanel);
        panelOverlay.addEventListener('click', closePanel);
        
        // Drawing settings
        let drawingSettings = {
            // Pressure
            sensitivity: 1.0,
            minWidth: 1.0,
            maxWidth: 8.0,
            curve: 'linear',
            enabled: true,
            
            // Smoothing & Latency
            smoothing: 3,
            latencyMode: 'optimized',
            
            // Debouncing
            debounceThreshold: 5,
            movementThreshold: 2.0,
            pressureDebounce: 3,
            adaptiveDebouncing: true,
            
            // Prediction
            prediction: 5,
            predictionMode: 'linear',
            predictionConfidence: 7,
            predictionSmoothing: 4,
            enablePrediction: true,
            correctionMode: false,
            
            // Performance
            frameRateBoost: true,
            directRendering: true
        };
        
        // Buffers and state
        let smoothingBuffer = [];
        let predictionBuffer = [];
        let pressureBuffer = [];
        let velocityHistory = [];
        let maxBufferSize = 10;
        let lastTimestamp = 0;
        let lastProcessedTime = 0;
        let lastPosition = { x: 0, y: 0 };
        let frameRequestId = null;
        let pendingDrawCalls = [];
        
        // Kalman filter state for advanced prediction
        let kalmanState = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            initialized: false
        };
        
        // Set canvas size with proper pixel ratio handling
        function resizeCanvas() {
            const pixelRatio = drawingSettings.frameRateBoost ? 1 : window.devicePixelRatio;
            canvas.width = window.innerWidth * pixelRatio;
            canvas.height = window.innerHeight * pixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(pixelRatio, pixelRatio);
            
            if (drawingSettings.directRendering) {
                ctx.imageSmoothingEnabled = false;
                canvas.style.imageRendering = 'pixelated';
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Clear canvas function
        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Pressure curve functions
        function applePressureCurve(pressure, curve) {
            switch(curve) {
                case 'ease':
                    return Math.pow(pressure, 0.7);
                case 'sharp':
                    return Math.pow(pressure, 1.5);
                default:
                    return pressure;
            }
        }
        
        // Calculate line width from pressure
        function calculateLineWidth(pressure) {
            if (!drawingSettings.enabled || pressure === undefined) {
                return 2;
            }
            
            const adjustedPressure = applePressureCurve(pressure, drawingSettings.curve);
            const normalizedPressure = Math.max(0, Math.min(1, adjustedPressure * drawingSettings.sensitivity));
            
            return drawingSettings.minWidth + 
                   (normalizedPressure * (drawingSettings.maxWidth - drawingSettings.minWidth));
        }
        
        // Debouncing function
        function shouldProcessInput(x, y, timestamp) {
            // Time-based debouncing
            if (timestamp - lastProcessedTime < drawingSettings.debounceThreshold) {
                return false;
            }
            
            // Movement threshold debouncing
            const distance = Math.sqrt(
                Math.pow(x - lastPosition.x, 2) + 
                Math.pow(y - lastPosition.y, 2)
            );
            
            if (distance < drawingSettings.movementThreshold) {
                return false;
            }
            
            // Adaptive debouncing based on velocity
            if (drawingSettings.adaptiveDebouncing && velocityHistory.length > 2) {
                const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
                const adaptiveThreshold = Math.max(1, drawingSettings.debounceThreshold - (avgVelocity * 0.1));
                
                if (timestamp - lastProcessedTime < adaptiveThreshold) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Pressure debouncing
        function debouncePressure(pressure) {
            if (drawingSettings.pressureDebounce === 0) return pressure;
            
            pressureBuffer.push(pressure);
            if (pressureBuffer.length > drawingSettings.pressureDebounce + 1) {
                pressureBuffer.shift();
            }
            
            // Return weighted average of recent pressure values
            const weights = pressureBuffer.map((_, i) => i + 1);
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            
            return pressureBuffer.reduce((sum, p, i) => 
                sum + (p * weights[i] / totalWeight), 0
            );
        }
        
        // Advanced prediction algorithms
        function predictNextPoint(buffer, mode) {
            if (buffer.length < 2 || !drawingSettings.enablePrediction) return null;
            
            const strength = drawingSettings.prediction / 10;
            const confidence = drawingSettings.predictionConfidence / 10;
            
            switch (mode) {
                case 'linear':
                    return predictLinear(buffer, strength);
                case 'velocity':
                    return predictVelocity(buffer, strength, confidence);
                case 'kalman':
                    return predictKalman(buffer, strength, confidence);
                default:
                    return predictLinear(buffer, strength);
            }
        }
        
        function predictLinear(buffer, strength) {
            const recent = buffer.slice(-2);
            const last = recent[recent.length - 1];
            const prev = recent[recent.length - 2];
            
            const deltaX = last.x - prev.x;
            const deltaY = last.y - prev.y;
            
            return {
                x: last.x + (deltaX * strength),
                y: last.y + (deltaY * strength),
                pressure: last.pressure,
                isPredicted: true
            };
        }
        
        function predictVelocity(buffer, strength, confidence) {
            if (buffer.length < 3) return predictLinear(buffer, strength);
            
            const recent = buffer.slice(-3);
            const velocities = [];
            
            for (let i = 1; i < recent.length; i++) {
                const dt = recent[i].timestamp - recent[i-1].timestamp;
                if (dt > 0) {
                    velocities.push({
                        vx: (recent[i].x - recent[i-1].x) / dt,
                        vy: (recent[i].y - recent[i-1].y) / dt
                    });
                }
            }
            
            if (velocities.length === 0) return predictLinear(buffer, strength);
            
            // Average velocity with confidence weighting
            const avgVx = velocities.reduce((sum, v) => sum + v.vx, 0) / velocities.length;
            const avgVy = velocities.reduce((sum, v) => sum + v.vy, 0) / velocities.length;
            
            const last = recent[recent.length - 1];
            const predictTime = 16.67; // Assume 60fps
            
            return {
                x: last.x + (avgVx * predictTime * strength * confidence),
                y: last.y + (avgVy * predictTime * strength * confidence),
                pressure: last.pressure,
                isPredicted: true
            };
        }
        
        function predictKalman(buffer, strength, confidence) {
            const last = buffer[buffer.length - 1];
            
            if (!kalmanState.initialized) {
                kalmanState.x = last.x;
                kalmanState.y = last.y;
                kalmanState.vx = 0;
                kalmanState.vy = 0;
                kalmanState.initialized = true;
                return predictLinear(buffer, strength);
            }
            
            // Simple Kalman filter implementation
            const dt = 16.67; // Assume 60fps
            const processNoise = 0.1;
            const measurementNoise = 1.0;
            
            // Predict
            const predictedX = kalmanState.x + kalmanState.vx * dt;
            const predictedY = kalmanState.y + kalmanState.vy * dt;
            
            // Update
            const innovationX = last.x - predictedX;
            const innovationY = last.y - predictedY;
            
            const gain = measurementNoise / (measurementNoise + processNoise);
            
            kalmanState.x = predictedX + gain * innovationX;
            kalmanState.y = predictedY + gain * innovationY;
            kalmanState.vx = kalmanState.vx + (gain * innovationX / dt);
            kalmanState.vy = kalmanState.vy + (gain * innovationY / dt);
            
            return {
                x: kalmanState.x + (kalmanState.vx * dt * strength * confidence),
                y: kalmanState.y + (kalmanState.vy * dt * strength * confidence),
                pressure: last.pressure,
                isPredicted: true
            };
        }
        
        // Apply smoothing to coordinates
        function smoothPoint(x, y, pressure, timestamp) {
            const point = { x, y, pressure, timestamp };
            
            // Add to prediction buffer
            predictionBuffer.push(point);
            if (predictionBuffer.length > 5) {
                predictionBuffer.shift();
            }
            
            if (drawingSettings.smoothing === 0) {
                return point;
            }
            
            smoothingBuffer.push(point);
            
            const bufferSize = Math.min(drawingSettings.smoothing + 1, maxBufferSize);
            if (smoothingBuffer.length > bufferSize) {
                smoothingBuffer.shift();
            }
            
            // Apply latency-optimized smoothing
            if (drawingSettings.latencyMode === 'ultra') {
                return smoothingBuffer[smoothingBuffer.length - 1];
            } else if (drawingSettings.latencyMode === 'optimized') {
                const weights = smoothingBuffer.map((_, i) => Math.pow(i + 1, 1.5));
                const totalWeight = weights.reduce((a, b) => a + b, 0);
                
                let smoothX = 0, smoothY = 0, smoothPressure = 0;
                
                smoothingBuffer.forEach((point, i) => {
                    const weight = weights[i] / totalWeight;
                    smoothX += point.x * weight;
                    smoothY += point.y * weight;
                    smoothPressure += point.pressure * weight;
                });
                
                return { x: smoothX, y: smoothY, pressure: smoothPressure };
            } else {
                const totalWeight = smoothingBuffer.length;
                let smoothX = 0, smoothY = 0, smoothPressure = 0;
                
                smoothingBuffer.forEach(point => {
                    smoothX += point.x;
                    smoothY += point.y;
                    smoothPressure += point.pressure;
                });
                
                return {
                    x: smoothX / totalWeight,
                    y: smoothY / totalWeight,
                    pressure: smoothPressure / totalWeight
                };
            }
        }
        
        // Smooth predicted points
        function smoothPrediction(prediction) {
            if (!prediction || drawingSettings.predictionSmoothing === 0) return prediction;
            
            // Simple smoothing for predicted points
            const smoothingFactor = drawingSettings.predictionSmoothing / 10;
            if (predictionBuffer.length > 1) {
                const lastActual = predictionBuffer[predictionBuffer.length - 1];
                return {
                    x: prediction.x * (1 - smoothingFactor) + lastActual.x * smoothingFactor,
                    y: prediction.y * (1 - smoothingFactor) + lastActual.y * smoothingFactor,
                    pressure: prediction.pressure,
                    isPredicted: true
                };
            }
            
            return prediction;
        }
        
        // Optimized drawing function
        function executeDrawing() {
            if (pendingDrawCalls.length === 0) return;
            
            ctx.beginPath();
            
            pendingDrawCalls.forEach(drawCall => {
                ctx.moveTo(drawCall.fromX, drawCall.fromY);
                ctx.lineTo(drawCall.toX, drawCall.toY);
                ctx.lineWidth = drawCall.lineWidth;
            });
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = 'black';
            ctx.stroke();
            
            pendingDrawCalls = [];
            frameRequestId = null;
        }
        
        // Event handlers for all settings
        function setupEventHandlers() {
            // Pressure settings
            document.getElementById('pressureSensitivity').addEventListener('input', (e) => {
                drawingSettings.sensitivity = parseFloat(e.target.value);
                document.getElementById('pressureSensitivityValue').textContent = e.target.value + 'x';
            });
            
            document.getElementById('minWidth').addEventListener('input', (e) => {
                drawingSettings.minWidth = parseFloat(e.target.value);
                document.getElementById('minWidthValue').textContent = e.target.value + 'px';
            });
            
            document.getElementById('maxWidth').addEventListener('input', (e) => {
                drawingSettings.maxWidth = parseFloat(e.target.value);
                document.getElementById('maxWidthValue').textContent = e.target.value + 'px';
            });
            
            document.getElementById('smoothing').addEventListener('input', (e) => {
                drawingSettings.smoothing = parseInt(e.target.value);
                document.getElementById('smoothingValue').textContent = e.target.value;
                smoothingBuffer = [];
            });
            
            document.getElementById('enablePressure').addEventListener('change', (e) => {
                drawingSettings.enabled = e.target.checked;
            });
            
            // Debouncing settings
            document.getElementById('debounceThreshold').addEventListener('input', (e) => {
                drawingSettings.debounceThreshold = parseInt(e.target.value);
                document.getElementById('debounceThresholdValue').textContent = e.target.value + 'ms';
            });
            
            document.getElementById('movementThreshold').addEventListener('input', (e) => {
                drawingSettings.movementThreshold = parseFloat(e.target.value);
                document.getElementById('movementThresholdValue').textContent = e.target.value + 'px';
            });
            
            document.getElementById('pressureDebounce').addEventListener('input', (e) => {
                drawingSettings.pressureDebounce = parseInt(e.target.value);
                document.getElementById('pressureDebounceValue').textContent = e.target.value;
                pressureBuffer = [];
            });
            
            document.getElementById('adaptiveDebouncing').addEventListener('change', (e) => {
                drawingSettings.adaptiveDebouncing = e.target.checked;
            });
            
            // Prediction settings
            document.getElementById('prediction').addEventListener('input', (e) => {
                drawingSettings.prediction = parseInt(e.target.value);
                document.getElementById('predictionValue').textContent = e.target.value;
            });
            
            document.getElementById('predictionConfidence').addEventListener('input', (e) => {
                drawingSettings.predictionConfidence = parseInt(e.target.value);
                document.getElementById('predictionConfidenceValue').textContent = e.target.value;
            });
            
            document.getElementById('predictionSmoothing').addEventListener('input', (e) => {
                drawingSettings.predictionSmoothing = parseInt(e.target.value);
                document.getElementById('predictionSmoothingValue').textContent = e.target.value;
            });
            
            document.getElementById('enablePrediction').addEventListener('change', (e) => {
                drawingSettings.enablePrediction = e.target.checked;
            });
            
            document.getElementById('correctionMode').addEventListener('change', (e) => {
                drawingSettings.correctionMode = e.target.checked;
            });
            
            // Performance settings
            document.getElementById('frameRateBoost').addEventListener('change', (e) => {
                drawingSettings.frameRateBoost = e.target.checked;
                resizeCanvas();
            });
            
            document.getElementById('directRendering').addEventListener('change', (e) => {
                drawingSettings.directRendering = e.target.checked;
                resizeCanvas();
            });
            
            // Button selectors
            document.querySelectorAll('.curve-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.curve-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    drawingSettings.curve = btn.dataset.curve;
                });
            });
            
            document.querySelectorAll('.latency-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.latency-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    drawingSettings.latencyMode = btn.dataset.mode;
                    smoothingBuffer = [];
                });
            });
            
            document.querySelectorAll('.prediction-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.prediction-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    drawingSettings.predictionMode = btn.dataset.mode;
                    kalmanState.initialized = false;
                });
            });
        }
        
        setupEventHandlers();
        
        // Trash button event handler
        document.getElementById('clearCanvas').addEventListener('click', clearCanvas);
        
        // Prevent controls and panel from interfering with drawing
        document.querySelector('.slide-panel').addEventListener('pointerdown', (e) => {
            e.stopPropagation();
        });
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
            });
        });
        
        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Function to check if input is from stylus/pen
        function isStylusInput(e) {
            if (e.pointerType === 'pen') return true;
            if (e.type.includes('mouse')) return true;
            return false;
        }
        
        // Drawing functions
        function startDrawing(e) {
            if (e.target.closest('.slide-panel') || e.target.closest('.controls-left') || e.target.closest('.controls-right')) return;
            if (!isStylusInput(e)) return;
            
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            // Reset all buffers and state
            smoothingBuffer = [];
            predictionBuffer = [];
            pressureBuffer = [];
            velocityHistory = [];
            pendingDrawCalls = [];
            lastPosition = { x: lastX, y: lastY };
            lastProcessedTime = performance.now();
            kalmanState.initialized = false;
        }
        
        function draw(e) {
            if (!isDrawing) return;
            if (!isStylusInput(e)) return;
            
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const rawX = e.clientX - rect.left;
            const rawY = e.clientY - rect.top;
            const rawPressure = e.pressure || 0.5;
            const timestamp = performance.now();
            
            // Apply debouncing
            if (!shouldProcessInput(rawX, rawY, timestamp)) {
                return;
            }
            
            // Update velocity history
            if (velocityHistory.length > 0) {
                const dt = timestamp - lastTimestamp;
                if (dt > 0) {
                    const velocity = Math.sqrt(
                        Math.pow(rawX - lastPosition.x, 2) + 
                        Math.pow(rawY - lastPosition.y, 2)
                    ) / dt;
                    velocityHistory.push(velocity);
                    if (velocityHistory.length > 5) {
                        velocityHistory.shift();
                    }
                }
            } else {
                velocityHistory.push(0);
            }
            
            // Apply pressure debouncing
            const debouncedPressure = debouncePressure(rawPressure);
            
            // Apply smoothing
            const smoothed = smoothPoint(rawX, rawY, debouncedPressure, timestamp);
            
            // Add prediction if enabled
            if (drawingSettings.enablePrediction && drawingSettings.prediction > 0) {
                const predicted = predictNextPoint(predictionBuffer, drawingSettings.predictionMode);
                if (predicted) {
                    const smoothedPrediction = smoothPrediction(predicted);
                    
                    pendingDrawCalls.push({
                        fromX: lastX,
                        fromY: lastY,
                        toX: smoothedPrediction.x,
                        toY: smoothedPrediction.y,
                        lineWidth: calculateLineWidth(smoothedPrediction.pressure),
                        isPredicted: true
                    });
                }
            }
            
            // Add the actual smoothed point
            pendingDrawCalls.push({
                fromX: lastX,
                fromY: lastY,
                toX: smoothed.x,
                toY: smoothed.y,
                lineWidth: calculateLineWidth(smoothed.pressure),
                isPredicted: false
            });
            
            // Execute drawing based on latency mode
            if (drawingSettings.latencyMode === 'ultra' || !drawingSettings.frameRateBoost) {
                executeDrawing();
            } else if (!frameRequestId) {
                frameRequestId = requestAnimationFrame(executeDrawing);
            }
            
            // Update state
            lastX = smoothed.x;
            lastY = smoothed.y;
            lastPosition = { x: rawX, y: rawY };
            lastTimestamp = timestamp;
            lastProcessedTime = timestamp;
        }
        
        function stopDrawing(e) {
            if (!isStylusInput(e)) return;
            isDrawing = false;
            
            // Flush any remaining draw calls
            if (frameRequestId) {
                cancelAnimationFrame(frameRequestId);
                executeDrawing();
            }
            
            // Clear buffers
            smoothingBuffer = [];
            predictionBuffer = [];
            pressureBuffer = [];
            velocityHistory = [];
            pendingDrawCalls = [];
            kalmanState.initialized = false;
        }
        
        // Mouse events (for desktop testing)
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Pointer events (primary method for stylus detection)
        if (window.PointerEvent) {
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', draw);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointercancel', stopDrawing);
            canvas.addEventListener('pointerleave', stopDrawing);
        }
        
        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Prevent touch events for finger input
        document.addEventListener('touchstart', (e) => {
            if (!e.target.closest('.slide-panel') && !e.target.closest('.controls-left') && !e.target.closest('.controls-right')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!e.target.closest('.slide-panel') && !e.target.closest('.controls-left') && !e.target.closest('.controls-right')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Handle stylus hover
        canvas.addEventListener('pointermove', (e) => {
            if (e.pointerType === 'pen' && !isDrawing) {
                canvas.style.cursor = 'crosshair';
            }
        });
    </script>
</body>
</html>
