<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Presentation Web App</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
        #viewer {
            position: relative;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        #page-container {
            position: relative;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs" type="module"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/521/fabric.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@arch-inc/fabricjs-psbrush@latest/dist/index.js"></script>
</head>
<body>
    <div id="viewer">
        <div id="page-container"></div>
    </div>
    <script type="module">
        import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs';

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

        // Get PDF file from URL param ?file=yourpdf.pdf
        const urlParams = new URLSearchParams(window.location.search);
        const pdfUrl = urlParams.get('file') || 'https://example.com/your-pdf.pdf'; // Replace with default PDF if needed

        let pdfDoc = null;
        let currentPageNum = 1;
        let pageContainer = document.getElementById('page-container');
        let fabricCanvas = null;
        let pdfCanvas = null;
        let annotationCanvas = null;

        async function loadPDF() {
            pdfDoc = await pdfjsLib.getDocument(pdfUrl).promise;
            renderPage(currentPageNum);

            // Go full screen
            document.documentElement.requestFullscreen().catch(err => console.log('Fullscreen error:', err));
        }

        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);

            // Calculate scale to fit screen
            let viewport = page.getViewport({ scale: 1 });
            const scale = Math.min(window.innerWidth / viewport.width, window.innerHeight / viewport.height);
            viewport = page.getViewport({ scale });

            // Clear previous
            pageContainer.innerHTML = '';

            // PDF canvas
            pdfCanvas = document.createElement('canvas');
            pdfCanvas.height = viewport.height;
            pdfCanvas.width = viewport.width;
            pageContainer.appendChild(pdfCanvas);

            // Annotation canvas
            annotationCanvas = document.createElement('canvas');
            annotationCanvas.style.position = 'absolute';
            annotationCanvas.style.top = '0';
            annotationCanvas.style.left = '0';
            annotationCanvas.height = viewport.height;
            annotationCanvas.width = viewport.width;
            pageContainer.appendChild(annotationCanvas);

            // Render PDF
            const renderContext = {
                canvasContext: pdfCanvas.getContext('2d'),
                viewport: viewport
            };
            await page.render(renderContext).promise;

            // Setup Fabric.js for annotations
            fabricCanvas = new fabric.Canvas(annotationCanvas, {
                isDrawingMode: true,
                enablePointerEvents: true
            });
            const brush = new fabric.PSBrush(fabricCanvas);
            brush.width = 50; // Very big pressure sensitive
            brush.color = 'blue';
            fabricCanvas.freeDrawingBrush = brush;

            let eraseMode = false;

            fabricCanvas.on('mouse:down', (opt) => {
                const e = opt.e;
                // Detect eraser for Bamboo stylus (eraser or barrel button)
                if (e.pointerType === 'pen' && (e.buttons & 32 || e.buttons & 2 || e.button === 5 || e.button === 2)) {
                    eraseMode = true;
                    brush.color = 'rgba(255, 0, 0, 0.5)'; // Semi-transparent red for erase path visibility
                } else {
                    eraseMode = false;
                    brush.color = 'blue';
                }
            });

            fabricCanvas.on('path:created', (opt) => {
                const path = opt.path;
                if (eraseMode) {
                    const objects = fabricCanvas.getObjects().filter(o => o !== path);
                    objects.forEach((obj) => {
                        if (path.intersectsWithObject(obj, true, true)) {
                            fabricCanvas.remove(obj);
                        }
                    });
                    fabricCanvas.remove(path);
                    eraseMode = false;
                    brush.color = 'blue';
                }
                // Paths are rounded and smooth by default in Fabric.js with PencilBrush-like behavior
            });
        }

        // Navigation with arrow keys (hidden controls)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' && currentPageNum < pdfDoc.numPages) {
                currentPageNum++;
                renderPage(currentPageNum);
            } else if (e.key === 'ArrowLeft' && currentPageNum > 1) {
                currentPageNum--;
                renderPage(currentPageNum);
            }
        });

        loadPDF();
    </script>
</body>
</html>
