<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quarter Pie Menu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
    <style>
        .menu-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: move;
            z-index: 10;
            position: relative;
            background-color: rgba(255, 255, 255, 0.7) !important;
        }
        
        .dark .menu-item {
            background-color: rgba(55, 65, 81, 0.7) !important;
        }
        
        .menu-item:hover {
            transform: scale(1.1);
        }
        
        .menu-active .menu-item {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .menu-item {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }
        
        .menu-item.dragging {
            z-index: 1000;
            transition: none;
            transform: scale(1.2);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        
        .menu-item.selected {
            border-color: #3B82F6 !important;
            box-shadow: 0 0 0 2px #3B82F6;
        }
        
        #menuToggle.selected {
            box-shadow: 0 0 0 2px #3B82F6;
        }
        
        .selection-mode .menu-item {
            cursor: pointer;
        }
        
        .group-dragging {
            cursor: move !important;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(1.4);
                opacity: 0;
            }
        }
        
        .ripple {
            animation: ripple 0.6s ease-out;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 min-h-screen flex items-center justify-center p-4">
    
    <div class="relative">

        
        <!-- Menu Container -->
        <div id="pieMenu" class="relative w-80 h-80 mx-auto">
            
            <!-- Center Button -->
            <button id="menuToggle" class="absolute w-10 h-10 text-white rounded-full shadow-lg flex items-center justify-center text-sm font-bold transition-all duration-300 z-20" style="left: -442px; top: 401px; background-color: rgba(93, 92, 222, 0.7);">
                <span id="menuIcon">☰</span>
            </button>
            
            <!-- Menu Items arranged in quarter circle (90 degrees) -->
            <div id="menuItems" class="absolute inset-0">
                
                <!-- Item 1 - Home -->
                <button class="menu-item absolute w-10 h-10 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 rounded-full shadow-lg flex items-center justify-center border-2 border-gray-200 dark:border-gray-600 hover:border-primary dark:hover:border-primary" 
                        style="left: -456px; top: 287px;"
                        data-item="home">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/>
                    </svg>
                </button>
                
                <!-- Item 2 - Search -->
                <button class="menu-item absolute w-10 h-10 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 rounded-full shadow-lg flex items-center justify-center border-2 border-gray-200 dark:border-gray-600 hover:border-primary dark:hover:border-primary" 
                        style="left: -402px; top: 307px;"
                        data-item="search">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"/>
                    </svg>
                </button>
                
                <!-- Item 3 - Settings -->
                <button class="menu-item absolute w-10 h-10 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 rounded-full shadow-lg flex items-center justify-center border-2 border-gray-200 dark:border-gray-600 hover:border-primary dark:hover:border-primary" 
                        style="left: -356px; top: 345px;"
                        data-item="settings">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/>
                    </svg>
                </button>
                
                <!-- Item 4 - Profile -->
                <button class="menu-item absolute w-10 h-10 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 rounded-full shadow-lg flex items-center justify-center border-2 border-gray-200 dark:border-gray-600 hover:border-primary dark:hover:border-primary" 
                        style="left: -339px; top: 404px;"
                        data-item="profile">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                    </svg>
                </button>
                
                <!-- Item 5 - Help -->
                <button class="menu-item absolute w-10 h-10 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 rounded-full shadow-lg flex items-center justify-center border-2 border-gray-200 dark:border-gray-600 hover:border-primary dark:hover:border-primary" 
                        style="left: -358px; top: 461px;"
                        data-item="help">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                    </svg>
                </button>
                
            </div>
            
            <!-- Ripple Effect -->
            <div id="rippleEffect" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-16 h-16 bg-primary/20 rounded-full pointer-events-none opacity-0"></div>
            
            <!-- Draggable Ring -->
            <div id="dragRing" class="absolute pointer-events-none opacity-0 transition-opacity duration-300" style="width: 100px; height: 100px; border: 1px solid #ff6b6b; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: move; z-index: 1;">
                <!-- Center Cross -->
                <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none" style="width: 60px; height: 60px;">
                    <!-- Horizontal line -->
                    <div id="crossHorizontal" class="absolute top-1/2 left-0 w-full h-px transform -translate-y-1/2" style="background-color: #ff6b6b;"></div>
                    <!-- Vertical line -->
                    <div id="crossVertical" class="absolute top-0 left-1/2 w-px h-full transform -translate-x-1/2" style="background-color: #ff6b6b;"></div>
                </div>
            </div>
            
        </div>
        
        <!-- Undo/Redo Controls -->
        <div class="fixed top-4 left-1/2 transform -translate-x-1/2 z-50 flex space-x-2">
            <button id="undoBtn" class="w-10 h-10 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg shadow-lg flex items-center justify-center transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0L3 9.414 8.293 4.121a1 1 0 011.414 1.414L6.414 9H17a1 1 0 110 2H6.414l3.293 3.293a1 1 0 010 1.414z" clip-rule="evenodd"/>
                </svg>
            </button>
            <button id="redoBtn" class="w-10 h-10 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg shadow-lg flex items-center justify-center transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l5.293 5.293-5.293 5.293a1 1 0 01-1.414-1.414L13.586 11H3a1 1 0 110-2h10.586l-3.293-3.293a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
            </button>
        </div>

        <!-- Hamburger Menu Toggle -->
        <div class="fixed top-4 right-4 z-50">
            <button id="infoToggle" class="w-10 h-10 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg shadow-lg flex items-center justify-center transition-all duration-300">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"/>
                </svg>
            </button>
        </div>

        <!-- Position Data Panel (Hidden by default) -->
        <div id="positionPanel" class="fixed top-0 right-0 h-full w-80 bg-white dark:bg-gray-800 shadow-xl transform translate-x-full transition-transform duration-300 ease-in-out z-40 overflow-y-auto">
            <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-white">Icon Positions</h3>
                    <button id="closePanel" class="w-8 h-8 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg flex items-center justify-center transition-colors">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
                
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">Drag icons to reposition them in the menu</p>
                
                <!-- Ring Tool -->
                <div class="mb-6 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
                    <h4 class="text-sm font-semibold text-gray-800 dark:text-white mb-3">Guide Ring</h4>
                    <div class="space-y-3">
                        <button id="toggleRing" class="w-full px-3 py-2 bg-orange-500 hover:bg-orange-600 text-white text-sm rounded transition-colors">
                            Show Ring
                        </button>
                        <div class="space-y-2">
                            <label class="text-xs text-gray-600 dark:text-gray-400">Size: <span id="ringSize">100</span>px</label>
                            <input type="range" id="ringSizeSlider" min="24" max="800" value="100" class="w-full">
                        </div>
                        <div class="flex space-x-2">
                            <input type="color" id="ringColor" value="#ff6b6b" class="w-8 h-8 rounded border">
                            <button id="centerRing" class="flex-1 px-3 py-2 bg-gray-500 hover:bg-gray-600 text-white text-xs rounded transition-colors">
                                Center Ring
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Selection Tool -->
                <div class="mb-6 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
                    <h4 class="text-sm font-semibold text-gray-800 dark:text-white mb-3">Selection Tool</h4>
                    <div class="space-y-3">
                        <button id="toggleSelectionMode" class="w-full px-3 py-2 bg-blue-500 hover:bg-blue-600 text-white text-sm rounded transition-colors">
                            Enable Group Drag
                        </button>
                        <button id="selectAllItems" class="w-full px-3 py-2 bg-green-500 hover:bg-green-600 text-white text-sm rounded transition-colors" disabled>
                            Select All Items
                        </button>
                        <button id="clearSelection" class="w-full px-3 py-2 bg-gray-500 hover:bg-gray-600 text-white text-sm rounded transition-colors" disabled>
                            Clear Selection
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-2" id="selectionStatus">
                        Click "Enable Group Drag" to start
                    </p>
                </div>
                
                <div id="positionData" class="space-y-2 text-sm font-mono mb-6">
                    <!-- Position data will be populated here -->
                </div>
                
                <button id="copyPositions" class="w-full px-4 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors">
                    Copy All Positions
                </button>
            </div>
        </div>

        <!-- Overlay for mobile -->
        <div id="panelOverlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 opacity-0 pointer-events-none transition-opacity duration-300"></div>
        

        
    </div>

    <script>
        // Dark mode detection and handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Menu functionality
        let menuOpen = false;
        let menuDragging = false;
        let menuDragStartX, menuDragStartY;
        let clickStartTime = 0;
        const menuToggle = document.getElementById('menuToggle');
        const menuItems = document.getElementById('menuItems');
        const menuIcon = document.getElementById('menuIcon');
        const rippleEffect = document.getElementById('rippleEffect');
        const selectedText = document.getElementById('selectedText');

        // Toggle menu function
        function toggleMenu() {
            menuOpen = !menuOpen;
            
            if (menuOpen) {
                menuItems.classList.add('menu-active');
                menuIcon.textContent = '✕';
                const currentTransform = menuToggle.style.transform || '';
                menuToggle.style.transform = currentTransform + ' rotate(180deg)';
                
                // Synchronized animation for menu items
                const items = document.querySelectorAll('.menu-item');
                items.forEach((item) => {
                    item.style.transitionDelay = '0ms';
                });
            } else {
                menuItems.classList.remove('menu-active');
                menuIcon.textContent = '☰';
                const currentTransform = menuToggle.style.transform || '';
                menuToggle.style.transform = currentTransform.replace(' rotate(180deg)', '');
            }
        }

        // Menu trigger drag functionality
        menuToggle.addEventListener('mousedown', startMenuDrag);
        menuToggle.addEventListener('touchstart', startMenuDrag, { passive: false });

        function startMenuDrag(e) {
            clickStartTime = Date.now();
            menuDragging = false;
            
            // Handle group dragging if in selection mode and menu trigger is selected
            if (selectionMode && selectedItems.has(menuToggle)) {
                startGroupDrag(e, menuToggle);
                return;
            }
            
            // Open menu immediately on touch/mouse down (except for selection mode)
            if (!selectionMode && !menuOpen) {
                toggleMenu();
            }
            
            const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            
            const rect = menuToggle.getBoundingClientRect();
            menuDragStartX = clientX - rect.left - rect.width/2;
            menuDragStartY = clientY - rect.top - rect.height/2;
            
            // Add global event listeners
            document.addEventListener('mousemove', dragMenuTrigger);
            document.addEventListener('mouseup', endMenuDrag);
            document.addEventListener('touchmove', dragMenuTrigger, { passive: false });
            document.addEventListener('touchend', endMenuDrag);
        }

        function dragMenuTrigger(e) {
            e.preventDefault();
            
            const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
            
            // Check if this is actually a drag (moved more than 5px)
            const dragDistance = Math.sqrt(
                Math.pow(clientX - (menuToggle.getBoundingClientRect().left + menuToggle.getBoundingClientRect().width/2), 2) +
                Math.pow(clientY - (menuToggle.getBoundingClientRect().top + menuToggle.getBoundingClientRect().height/2), 2)
            );
            
            if (dragDistance > 5) {
                menuDragging = true;
                menuToggle.style.cursor = 'grabbing';
            }
            
            if (!menuDragging) return;
            
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            // Calculate new position relative to container
            let newX = clientX - containerRect.left - menuDragStartX;
            let newY = clientY - containerRect.top - menuDragStartY;
            
            // No boundary constraints - allow dragging anywhere
            
            // Update position
            menuToggle.style.left = newX + 'px';
            menuToggle.style.top = newY + 'px';
            menuToggle.style.transform = menuToggle.style.transform.replace('translate(-50%, -50%)', '');
            if (!menuToggle.style.transform.includes('translate(-50%, -50%)')) {
                menuToggle.style.transform = 'translate(-50%, -50%) ' + (menuToggle.style.transform || '');
            }
        }

        function endMenuDrag(e) {
            const clickDuration = Date.now() - clickStartTime;
            
            // Remove global event listeners
            document.removeEventListener('mousemove', dragMenuTrigger);
            document.removeEventListener('mouseup', endMenuDrag);
            document.removeEventListener('touchmove', dragMenuTrigger);
            document.removeEventListener('touchend', endMenuDrag);
            
            menuToggle.style.cursor = '';
            
            // If it was a quick click (not a drag)
            if (!menuDragging && clickDuration < 200) {
                // In selection mode, toggle selection instead of menu
                if (selectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleItemSelection(menuToggle);
                } else {
                    toggleMenu();
                }
            } else if (menuDragging) {
                // Save state after drag operation
                saveState();
            }
            
            menuDragging = false;
        }

        // Selection Tool functionality
        let selectionMode = false;
        let selectedItems = new Set();
        let groupDragOffsets = new Map();
        let isGroupDragging = false;

        const toggleSelectionModeBtn = document.getElementById('toggleSelectionMode');
        const selectAllItemsBtn = document.getElementById('selectAllItems');
        const clearSelectionBtn = document.getElementById('clearSelection');
        const selectionStatus = document.getElementById('selectionStatus');

        function updateSelectionUI() {
            const selectedCount = selectedItems.size;
            
            if (selectionMode) {
                toggleSelectionModeBtn.textContent = 'Disable Group Drag';
                toggleSelectionModeBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                toggleSelectionModeBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                
                selectAllItemsBtn.disabled = false;
                clearSelectionBtn.disabled = selectedCount === 0;
                
                if (selectedCount === 0) {
                    selectionStatus.textContent = 'Click items to select them';
                } else if (selectedCount === 1) {
                    selectionStatus.textContent = '1 item selected - drag to move all';
                } else {
                    selectionStatus.textContent = `${selectedCount} items selected - drag to move all`;
                }
                
                menuItems.classList.add('selection-mode');
            } else {
                toggleSelectionModeBtn.textContent = 'Enable Group Drag';
                toggleSelectionModeBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                toggleSelectionModeBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                
                selectAllItemsBtn.disabled = true;
                clearSelectionBtn.disabled = true;
                selectionStatus.textContent = 'Click "Enable Group Drag" to start';
                
                menuItems.classList.remove('selection-mode');
                // Clear selections without calling updateSelectionUI again
                selectedItems.clear();
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }
        }

        function clearSelection() {
            selectedItems.clear();
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('selected');
            });
            menuToggle.classList.remove('selected');
            updateSelectionUI();
        }

        function selectAllItems() {
            clearSelection();
            // Select all menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                selectedItems.add(item);
                item.classList.add('selected');
            });
            // Select the menu trigger
            selectedItems.add(menuToggle);
            menuToggle.classList.add('selected');
            updateSelectionUI();
        }

        function toggleItemSelection(item) {
            if (selectedItems.has(item)) {
                selectedItems.delete(item);
                item.classList.remove('selected');
            } else {
                selectedItems.add(item);
                item.classList.add('selected');
            }
            updateSelectionUI();
        }

        function startGroupDrag(e, triggerItem) {
            if (selectedItems.size === 0) return;
            
            e.preventDefault();
            isGroupDragging = true;
            
            const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            
            // Calculate offsets for all selected items relative to trigger item
            groupDragOffsets.clear();
            const triggerRect = triggerItem.getBoundingClientRect();
            
            selectedItems.forEach(item => {
                const itemRect = item.getBoundingClientRect();
                groupDragOffsets.set(item, {
                    x: itemRect.left - triggerRect.left,
                    y: itemRect.top - triggerRect.top
                });
                item.classList.add('dragging');
            });
            
            // Store initial mouse offset
            startX = clientX - triggerRect.left;
            startY = clientY - triggerRect.top;
            
            document.body.classList.add('group-dragging');
            
            // Add global event listeners
            document.addEventListener('mousemove', groupDrag);
            document.addEventListener('mouseup', endGroupDrag);
            document.addEventListener('touchmove', groupDrag, { passive: false });
            document.addEventListener('touchend', endGroupDrag);
        }

        function groupDrag(e) {
            if (!isGroupDragging) return;
            
            e.preventDefault();
            
            const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
            
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            // Calculate new position for trigger item
            let baseX = clientX - containerRect.left - startX;
            let baseY = clientY - containerRect.top - startY;
            
            // Move all selected items
            selectedItems.forEach(item => {
                const offset = groupDragOffsets.get(item);
                let newX = baseX + offset.x;
                let newY = baseY + offset.y;
                
                // No boundary constraints - allow dragging anywhere
                
                // Update position
                item.style.left = newX + 'px';
                item.style.top = newY + 'px';
                item.style.right = 'auto';
                item.style.transform = 'none';
            });
            
            // Update position display in real-time
            updatePositionDisplay();
        }

        function endGroupDrag(e) {
            if (!isGroupDragging) return;
            
            isGroupDragging = false;
            
            selectedItems.forEach(item => {
                item.classList.remove('dragging');
            });
            
            document.body.classList.remove('group-dragging');
            
            // Remove global event listeners
            document.removeEventListener('mousemove', groupDrag);
            document.removeEventListener('mouseup', endGroupDrag);
            document.removeEventListener('touchmove', groupDrag);
            document.removeEventListener('touchend', endGroupDrag);
            
            updatePositionDisplay();
            
            // Save state after group drag operation
            saveState();
        }

        // Event listeners for selection tool
        toggleSelectionModeBtn.addEventListener('click', () => {
            selectionMode = !selectionMode;
            updateSelectionUI();
        });

        selectAllItemsBtn.addEventListener('click', selectAllItems);
        clearSelectionBtn.addEventListener('click', clearSelection);

        // Handle menu item clicks with selection functionality
        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (selectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleItemSelection(item);
                    return;
                }
                
                // Original click functionality
                const itemName = e.currentTarget.getAttribute('data-item');
                selectedText.textContent = itemName.charAt(0).toUpperCase() + itemName.slice(1);
                
                // Add ripple effect
                rippleEffect.classList.remove('ripple');
                rippleEffect.style.opacity = '1';
                void rippleEffect.offsetWidth; // Trigger reflow
                rippleEffect.classList.add('ripple');
                
                setTimeout(() => {
                    rippleEffect.style.opacity = '0';
                }, 600);
                
                // Close menu after selection
                setTimeout(() => {
                    menuToggle.click();
                }, 200);
            });
            
            // Add hover effects for better feedback
            item.addEventListener('mouseenter', () => {
                if (menuOpen) {
                    item.style.transform += ' translateZ(10px)';
                }
            });
            
            item.addEventListener('mouseleave', () => {
                if (menuOpen) {
                    item.style.transform = item.style.transform.replace(' translateZ(10px)', '');
                }
            });
        });

        // Initialize selection UI
        updateSelectionUI();

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (menuOpen && !document.getElementById('pieMenu').contains(e.target)) {
                menuToggle.click();
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && menuOpen) {
                menuToggle.click();
            }
        });

        // Drag and Drop functionality
        let draggedElement = null;
        let startX, startY;
        let isDragging = false;

        function updatePositionDisplay() {
            const positionDataDiv = document.getElementById('positionData');
            const menuContainer = document.getElementById('pieMenu');
            const containerRect = menuContainer.getBoundingClientRect();
            
            let positionText = '';
            
            // Add menu trigger position first
            const triggerRect = menuToggle.getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            const triggerRelativeX = triggerRect.left - containerRect.left + triggerRect.width/2 - centerX;
            const triggerRelativeY = triggerRect.top - containerRect.top + triggerRect.height/2 - centerY;
            const triggerAbsoluteX = triggerRect.left - containerRect.left;
            const triggerAbsoluteY = triggerRect.top - containerRect.top;
            
            positionText += `
                <div class="bg-white dark:bg-gray-700 p-3 rounded border">
                    <strong class="text-primary">menuTrigger:</strong><br>
                    <span class="text-gray-600 dark:text-gray-300">Absolute: (${Math.round(triggerAbsoluteX)}, ${Math.round(triggerAbsoluteY)})</span><br>
                    <span class="text-gray-600 dark:text-gray-300">From Center: (${Math.round(triggerRelativeX)}, ${Math.round(triggerRelativeY)})</span>
                </div>
            `;
            
            // Add menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                const rect = item.getBoundingClientRect();
                
                // Calculate position relative to container center
                const relativeX = rect.left - containerRect.left + rect.width/2 - centerX;
                const relativeY = rect.top - containerRect.top + rect.height/2 - centerY;
                
                // Also show absolute position within container
                const absoluteX = rect.left - containerRect.left;
                const absoluteY = rect.top - containerRect.top;
                
                positionText += `
                    <div class="bg-white dark:bg-gray-700 p-3 rounded border">
                        <strong class="text-primary">${itemName}:</strong><br>
                        <span class="text-gray-600 dark:text-gray-300">Absolute: (${Math.round(absoluteX)}, ${Math.round(absoluteY)})</span><br>
                        <span class="text-gray-600 dark:text-gray-300">From Center: (${Math.round(relativeX)}, ${Math.round(relativeY)})</span>
                    </div>
                `;
            });
            
            positionDataDiv.innerHTML = positionText;
        }

        // Add drag event listeners to all menu items
        document.querySelectorAll('.menu-item').forEach(item => {
            // Mouse events
            item.addEventListener('mousedown', startDrag);
            
            // Touch events for mobile
            item.addEventListener('touchstart', startDrag, { passive: false });
        });

        function startDrag(e) {
            if (!menuOpen) return; // Only allow dragging when menu is open
            
            const item = e.target.closest('.menu-item');
            
            // Handle group dragging if in selection mode and item is selected
            if (selectionMode && selectedItems.has(item)) {
                startGroupDrag(e, item);
                return;
            }
            
            // Don't allow individual dragging in selection mode unless item is selected
            if (selectionMode) {
                return;
            }
            
            // Original individual drag functionality
            e.preventDefault();
            draggedElement = item;
            isDragging = true;
            
            draggedElement.classList.add('dragging');
            
            const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            
            const rect = draggedElement.getBoundingClientRect();
            startX = clientX - rect.left;
            startY = clientY - rect.top;
            
            // Add global event listeners
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function drag(e) {
            if (!isDragging || !draggedElement) return;
            
            e.preventDefault();
            
            const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
            
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            // Calculate new position relative to container
            let newX = clientX - containerRect.left - startX;
            let newY = clientY - containerRect.top - startY;
            
            // No boundary constraints - allow dragging anywhere
            
            // Update position
            draggedElement.style.left = newX + 'px';
            draggedElement.style.top = newY + 'px';
            draggedElement.style.right = 'auto';
            draggedElement.style.transform = 'none';
            
            // Update position display in real-time
            updatePositionDisplay();
        }

        function endDrag(e) {
            if (!isDragging) return;
            
            isDragging = false;
            
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
                draggedElement = null;
            }
            
            // Remove global event listeners
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', endDrag);
            
            updatePositionDisplay();
            
            // Save state after drag operation
            saveState();
        }

        // Copy positions functionality
        document.getElementById('copyPositions').addEventListener('click', () => {
            const menuContainer = document.getElementById('pieMenu');
            const containerRect = menuContainer.getBoundingClientRect();
            
            let positionsData = {};
            
            // Add menu trigger position first
            const triggerRect = menuToggle.getBoundingClientRect();
            const triggerAbsoluteX = triggerRect.left - containerRect.left;
            const triggerAbsoluteY = triggerRect.top - containerRect.top;
            
            positionsData.menuTrigger = {
                left: Math.round(triggerAbsoluteX),
                top: Math.round(triggerAbsoluteY)
            };
            
            // Add menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                const rect = item.getBoundingClientRect();
                
                const absoluteX = rect.left - containerRect.left;
                const absoluteY = rect.top - containerRect.top;
                
                positionsData[itemName] = {
                    left: Math.round(absoluteX),
                    top: Math.round(absoluteY)
                };
            });
            
            const jsonData = JSON.stringify(positionsData, null, 2);
            
            // Create a temporary textarea to copy the data
            const textarea = document.createElement('textarea');
            textarea.value = jsonData;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            
            // Show feedback
            const button = document.getElementById('copyPositions');
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.classList.add('bg-green-500');
            button.classList.remove('bg-primary');
            
            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('bg-green-500');
                button.classList.add('bg-primary');
            }, 2000);
        });

        // Initialize position display
        setTimeout(updatePositionDisplay, 100);

        // Info Panel functionality
        let panelOpen = false;
        const infoToggle = document.getElementById('infoToggle');
        const positionPanel = document.getElementById('positionPanel');
        const closePanel = document.getElementById('closePanel');
        const panelOverlay = document.getElementById('panelOverlay');

        function openPanel() {
            panelOpen = true;
            positionPanel.classList.remove('translate-x-full');
            positionPanel.classList.add('translate-x-0');
            panelOverlay.classList.remove('opacity-0', 'pointer-events-none');
            panelOverlay.classList.add('opacity-100');
        }

        function closePanelFunc() {
            panelOpen = false;
            positionPanel.classList.remove('translate-x-0');
            positionPanel.classList.add('translate-x-full');
            panelOverlay.classList.remove('opacity-100');
            panelOverlay.classList.add('opacity-0', 'pointer-events-none');
        }

        // Event listeners for panel
        infoToggle.addEventListener('click', () => {
            if (panelOpen) {
                closePanelFunc();
            } else {
                openPanel();
            }
        });

        closePanel.addEventListener('click', closePanelFunc);
        panelOverlay.addEventListener('click', closePanelFunc);

        // Close panel on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && panelOpen) {
                closePanelFunc();
            }
        });

        // Undo/Redo functionality
        let undoStack = [];
        let redoStack = [];
        let maxHistorySize = 50;
        let isUndoRedoOperation = false;

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // Save current state
        function saveState() {
            if (isUndoRedoOperation) return;
            
            const state = {
                menuItems: {},
                menuToggle: {
                    left: menuToggle.style.left || '',
                    top: menuToggle.style.top || '',
                    transform: menuToggle.style.transform || 'translate(-50%, -50%)'
                }
            };
            
            // Save menu item positions
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                state.menuItems[itemName] = {
                    left: item.style.left || '',
                    top: item.style.top || '',
                    transform: item.style.transform || ''
                };
            });
            
            // Add to undo stack
            undoStack.push(state);
            
            // Limit stack size
            if (undoStack.length > maxHistorySize) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            redoStack = [];
            
            updateUndoRedoButtons();
        }

        // Restore state
        function restoreState(state) {
            if (!state) return;
            
            isUndoRedoOperation = true;
            
            // Restore menu trigger position
            menuToggle.style.left = state.menuToggle.left;
            menuToggle.style.top = state.menuToggle.top;
            menuToggle.style.transform = state.menuToggle.transform;
            
            // Restore menu item positions
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                if (state.menuItems[itemName]) {
                    item.style.left = state.menuItems[itemName].left;
                    item.style.top = state.menuItems[itemName].top;
                    item.style.transform = state.menuItems[itemName].transform;
                }
            });
            
            updatePositionDisplay();
            isUndoRedoOperation = false;
        }

        // Undo operation
        function undo() {
            if (undoStack.length === 0) return;
            
            // Save current state to redo stack
            const currentState = {
                menuItems: {},
                menuToggle: {
                    left: menuToggle.style.left || '',
                    top: menuToggle.style.top || '',
                    transform: menuToggle.style.transform || 'translate(-50%, -50%)'
                }
            };
            
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                currentState.menuItems[itemName] = {
                    left: item.style.left || '',
                    top: item.style.top || '',
                    transform: item.style.transform || ''
                };
            });
            
            redoStack.push(currentState);
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(previousState);
            
            updateUndoRedoButtons();
        }

        // Redo operation
        function redo() {
            if (redoStack.length === 0) return;
            
            // Save current state to undo stack
            const currentState = {
                menuItems: {},
                menuToggle: {
                    left: menuToggle.style.left || '',
                    top: menuToggle.style.top || '',
                    transform: menuToggle.style.transform || 'translate(-50%, -50%)'
                }
            };
            
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                currentState.menuItems[itemName] = {
                    left: item.style.left || '',
                    top: item.style.top || '',
                    transform: item.style.transform || ''
                };
            });
            
            undoStack.push(currentState);
            
            // Restore next state
            const nextState = redoStack.pop();
            restoreState(nextState);
            
            updateUndoRedoButtons();
        }

        // Update button states
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }

        // Event listeners for undo/redo buttons
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        // Save initial state
        setTimeout(() => {
            saveState();
        }, 100);

        // Store original positions for restoration
        const originalPositions = {
            menuTrigger: { left: -442, top: 401 },
            home: { left: -456, top: 287 },
            search: { left: -402, top: 307 },
            settings: { left: -356, top: 345 },
            profile: { left: -339, top: 404 },
            help: { left: -358, top: 461 }
        };
        
        // Responsive positioning to keep menu in viewport
        let resizeTimeout;
        function adjustMenuPosition() {
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            // Get all menu elements (trigger + items)
            const allMenuElements = [menuToggle, ...document.querySelectorAll('.menu-item')];
            
            // First, try to restore original positions
            menuToggle.style.left = originalPositions.menuTrigger.left + 'px';
            menuToggle.style.top = originalPositions.menuTrigger.top + 'px';
            
            document.querySelectorAll('.menu-item').forEach(item => {
                const itemName = item.getAttribute('data-item');
                if (originalPositions[itemName]) {
                    item.style.left = originalPositions[itemName].left + 'px';
                    item.style.top = originalPositions[itemName].top + 'px';
                }
            });
            
            // Wait a frame for positions to update, then check if adjustments are needed
            requestAnimationFrame(() => {
                // Find the bounding box of all menu elements in viewport coordinates
                let minViewportX = Infinity, minViewportY = Infinity, maxViewportX = -Infinity, maxViewportY = -Infinity;
                
                allMenuElements.forEach(element => {
                    const rect = element.getBoundingClientRect();
                    
                    minViewportX = Math.min(minViewportX, rect.left);
                    minViewportY = Math.min(minViewportY, rect.top);
                    maxViewportX = Math.max(maxViewportX, rect.right);
                    maxViewportY = Math.max(maxViewportY, rect.bottom);
                });
                
                // Calculate needed adjustments to keep menu in viewport
                let adjustX = 0, adjustY = 0;
                const padding = 10; // 10px padding from viewport edges
                
                // Check if menu extends beyond left edge of viewport
                if (minViewportX < padding) {
                    adjustX = padding - minViewportX;
                }
                
                // Check if menu extends beyond top edge of viewport  
                if (minViewportY < padding) {
                    adjustY = padding - minViewportY;
                }
                
                // Check if menu extends beyond right edge of viewport
                const viewportWidth = window.innerWidth;
                if (maxViewportX > viewportWidth - padding) {
                    adjustX = viewportWidth - padding - maxViewportX;
                }
                
                // Check if menu extends beyond bottom edge of viewport
                const viewportHeight = window.innerHeight;
                if (maxViewportY > viewportHeight - padding) {
                    adjustY = viewportHeight - padding - maxViewportY;
                }
                
                // Apply adjustments if needed
                if (Math.abs(adjustX) > 2 || Math.abs(adjustY) > 2) {
                    allMenuElements.forEach(element => {
                        const currentLeft = parseInt(element.style.left) || 0;
                        const currentTop = parseInt(element.style.top) || 0;
                        
                        element.style.left = (currentLeft + adjustX) + 'px';
                        element.style.top = (currentTop + adjustY) + 'px';
                    });
                }
                
                // Update position display after adjustment
                updatePositionDisplay();
            });
        }

        // Debounced resize handler to prevent excessive adjustments
        function debouncedAdjustMenuPosition() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                adjustMenuPosition();
            }, 150); // Wait 150ms after resize stops
        }

        // Add resize event listener with debouncing
        window.addEventListener('resize', debouncedAdjustMenuPosition);
        
        // Initial adjustment on load (only once)
        setTimeout(() => {
            adjustMenuPosition();
        }, 200);

        // Ring functionality
        let ringVisible = false;
        let ringDragging = false;
        let ringStartX, ringStartY;

        const toggleRingBtn = document.getElementById('toggleRing');
        const ringSizeSlider = document.getElementById('ringSizeSlider');
        const ringSize = document.getElementById('ringSize');
        const ringColor = document.getElementById('ringColor');
        const centerRingBtn = document.getElementById('centerRing');
        const dragRing = document.getElementById('dragRing');

        // Toggle ring visibility
        toggleRingBtn.addEventListener('click', () => {
            ringVisible = !ringVisible;
            
            if (ringVisible) {
                dragRing.style.opacity = '1';
                dragRing.style.pointerEvents = 'auto';
                toggleRingBtn.textContent = 'Hide Ring';
                toggleRingBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                toggleRingBtn.classList.add('bg-red-500', 'hover:bg-red-600');
            } else {
                dragRing.style.opacity = '0';
                dragRing.style.pointerEvents = 'none';
                toggleRingBtn.textContent = 'Show Ring';
                toggleRingBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                toggleRingBtn.classList.add('bg-orange-500', 'hover:bg-orange-600');
            }
        });

        // Update ring size
        ringSizeSlider.addEventListener('input', (e) => {
            const size = e.target.value;
            ringSize.textContent = size;
            dragRing.style.width = size + 'px';
            dragRing.style.height = size + 'px';
        });

        // Update ring color
        ringColor.addEventListener('change', (e) => {
            const newColor = e.target.value;
            dragRing.style.borderColor = newColor;
            
            // Update cross color to match ring
            const crossHorizontal = document.getElementById('crossHorizontal');
            const crossVertical = document.getElementById('crossVertical');
            crossHorizontal.style.backgroundColor = newColor;
            crossVertical.style.backgroundColor = newColor;
        });

        // Center ring
        centerRingBtn.addEventListener('click', () => {
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            dragRing.style.top = '50%';
            dragRing.style.left = '50%';
            dragRing.style.transform = 'translate(-50%, -50%)';
        });

        // Ring drag functionality
        dragRing.addEventListener('mousedown', startRingDrag);
        dragRing.addEventListener('touchstart', startRingDrag, { passive: false });

        function startRingDrag(e) {
            if (!ringVisible) return;
            
            const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            
            const rect = dragRing.getBoundingClientRect();
            
            // Calculate distance from click point to ring center
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            const distanceFromCenter = Math.sqrt(
                Math.pow(clientX - centerX, 2) + Math.pow(clientY - centerY, 2)
            );
            
            // Get current ring size
            const currentSize = parseInt(dragRing.style.width) || 100;
            const radius = currentSize / 2;
            const borderThickness = 8; // 8px click area around the border
            
            // Only allow dragging if click is on the ring border (not inside)
            if (distanceFromCenter < radius - borderThickness || distanceFromCenter > radius + borderThickness) {
                return; // Click is not on the ring border
            }
            
            e.preventDefault();
            e.stopPropagation();
            ringDragging = true;
            
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            // Calculate offset from click point to ring's current position (center)
            ringStartX = clientX - (rect.left + rect.width/2);
            ringStartY = clientY - (rect.top + rect.height/2);
            
            dragRing.style.cursor = 'grabbing';
            
            // Add global event listeners
            document.addEventListener('mousemove', dragRingMove);
            document.addEventListener('mouseup', endRingDrag);
            document.addEventListener('touchmove', dragRingMove, { passive: false });
            document.addEventListener('touchend', endRingDrag);
        }

        function dragRingMove(e) {
            if (!ringDragging) return;
            
            e.preventDefault();
            
            const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
            
            const container = document.getElementById('pieMenu');
            const containerRect = container.getBoundingClientRect();
            
            // Calculate new center position relative to container
            let newCenterX = clientX - containerRect.left - ringStartX;
            let newCenterY = clientY - containerRect.top - ringStartY;
            
            // Update position (the ring uses center positioning)
            dragRing.style.left = newCenterX + 'px';
            dragRing.style.top = newCenterY + 'px';
            dragRing.style.transform = 'translate(-50%, -50%)';
        }

        function endRingDrag(e) {
            if (!ringDragging) return;
            
            ringDragging = false;
            dragRing.style.cursor = 'move';
            
            // Remove global event listeners
            document.removeEventListener('mousemove', dragRingMove);
            document.removeEventListener('mouseup', endRingDrag);
            document.removeEventListener('touchmove', dragRingMove);
            document.removeEventListener('touchend', endRingDrag);
        }
    </script>
</body>
</html>
