<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="utf-8">
    <meta name="color-scheme" content="dark light">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Multi-Screen Window Management API Demo</title>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                color: #fff;
                background-color: #000;
            }
        }
        body {
            font-family: system-ui, sans-serif;
            margin: 2em;
        }

        h1 {
            color: #373fff;
        }

        footer {
            position: absolute;
            bottom: 2em;
            font-size: 0.8rem;
        }

        a {
            color: red;
        }

        input {
            font-size: inherit;
            display: block;
            margin-top: 1rem;
        }

        input:after {
            content: attr(data-value);
            font-size: 1rem;
            position: relative;
            right: -1rem;
        }

        label {
            margin-left: 1rem;
        }

        button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        button img {
            border-radius: 8px;
            transition: transform 0.2s;
        }

        button img:hover {
            transform: scale(1.05);
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body>
    <h1>Multi-Screen Window Management API Demo üêò</h1>
    <ul>
        <li>
            Click <strong>Elmer</strong>, the patchwork elephant, to start the
            Elmer-inspired trading desk demo.
        </li>
        <li>
            You will see a permission prompt for
            <strong>window management</strong> and potentially another for
            <strong>popup</strong> windows. Grant both.
        </li>
        <li>Focus any of the windows and click again to toggle fullscreen.</li>
        <li>Plug or unplug an additional screen and see how the demo adapts.</li>
        <li>
            Play with the sliders below (closing one popup closes all other popups,
            too).
        </li>
    </ul>
    <button type="button" id="elmerBtn">
        <div style="width: 316px; height: 316px; background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3, #54a0ff); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 48px; color: white; font-weight: bold;">
            üêò ELMER
        </div>
    </button>
    <label><input type="range" min="1" max="5" id="rows" value="2"> Rows</label>
    <label><input type="range" min="1" max="5" id="cols" value="2"> Columns</label>
    <footer>
        Multi-Screen Window Management API Demo - 
        <a href="https://googlechrome.github.io/samples/window-management/">Original</a>
    </footer>

    <script>
        let ROWS;
        let COLS;
        const WINDOW_CHROME_Y = 51;
        const WINDOW_CHROME_X = 1;

        let popups = [];
        let popupMonitor = null;
        let cachedScreens = null;

        document.querySelectorAll("input").forEach(input => {
            const onInputChange = () => {
                input.dataset.value = input.value;
                if (input.id === "rows") {
                    ROWS = parseInt(input.value, 10);
                } else {
                    COLS = parseInt(input.value, 10);
                }
            };
            input.addEventListener("input", onInputChange);
            onInputChange();
        });

        const createPopup = (screenX, screenY, width, height) => {
            const features = [
                `left=${screenX}`,
                `top=${screenY}`,
                `width=${width}`,
                `height=${height}`,
                `menubar=no`,
                `toolbar=no`,
                `location=no`,
                `status=no`,
                `resizable=yes`,
                `scrollbars=no`
            ].join(",");
            
            console.log(`Creating popup with features: ${features}`);
            
            // Create popup with trading desk content
            const popup = window.open("", Math.random().toString(), features);
            
            if (popup) {
                // Add trading desk content to the popup
                const currency = Math.random()
                    .toString(36)
                    .replace(/[^a-z]+/g, "")
                    .substr(0, 3)
                    .toUpperCase();
                const price = new Intl.NumberFormat("en-US", {
                    style: "currency",
                    currency: "USD"
                }).format(Math.random() * 20000);
                const percent = new Intl.NumberFormat("en-US", {
                    style: "percent"
                }).format(Math.random() * 1000);
                
                const hue = Math.floor(Math.random() * 360);
                const color = `hsl(${hue}deg 100% 50%)`;
                const colorFill = `hsl(${hue}deg 100% 40%)`;
                const colorBackground = `hsl(${hue + 180}deg 100% 50%)`;
                
                popup.document.write(`
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="utf-8" />
                        <meta name="color-scheme" content="dark light" />
                        <meta name="viewport" content="width=device-width, initial-scale=1" />
                        <title>${currency}</title>
                        <style>
                            @media (prefers-color-scheme: dark) {
                                :root {
                                    color: #fff;
                                    background-color: #000;
                                }
                            }
                            * {
                                box-sizing: border-box;
                            }
                            html, body {
                                background-color: ${colorBackground};
                            }
                            body {
                                display: flex;
                                flex-direction: column;
                                font-family: system-ui, sans-serif;
                                font-size: 100%;
                                margin: 0;
                                padding: 1rem;
                                height: 100vh;
                                width: 100%;
                                overflow: hidden;
                            }
                            h1 {
                                color: #000;
                                background-color: rgba(255, 255, 255, 0.5);
                                padding: 1rem;
                                margin: 0 0 1rem 0;
                                border-radius: 8px;
                            }
                            div {
                                flex-grow: 1;
                                position: relative;
                            }
                            .sparkline {
                                stroke: ${color};
                                fill: ${colorFill};
                            }
                            .down, .up {
                                color: transparent;
                            }
                            .down {
                                text-shadow: 0 0 0 red;
                            }
                            .up {
                                text-shadow: 0 0 0 lime;
                            }
                            svg {
                                width: 100%;
                                height: 100%;
                            }
                        </style>
                    </head>
                    <body>
                        <h1>${currency} (üóì ${price} ${Math.random() < 0.5 ? "<span class=down>‚ñº</span>" : "<span class=up>‚ñ≤</span>"} ${percent})</h1>
                        <div id="chart"></div>
                        <script>
                            // Simple sparkline generator
                            const values = Array.from({ length: 25 }, () => Math.floor(Math.random() * 40));
                            const chart = document.getElementById('chart');
                            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            svg.setAttribute('class', 'sparkline');
                            svg.setAttribute('stroke-width', '3');
                            svg.setAttribute('width', '100%');
                            svg.setAttribute('height', '100%');
                            svg.setAttribute('viewBox', '0 0 100 40');
                            
                            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                            const points = values.map((value, index) => 
                                \`\${(index / (values.length - 1)) * 100},\${40 - value}\`
                            ).join(' ');
                            polyline.setAttribute('points', points);
                            polyline.setAttribute('fill', 'none');
                            
                            svg.appendChild(polyline);
                            chart.appendChild(svg);
                        <\/script>
                    </body>
                    </html>
                `);
                popup.document.close();
                
                // Log actual position after creation
                setTimeout(() => {
                    const actualX = popup.screenX || popup.screenLeft;
                    const actualY = popup.screenY || popup.screenTop;
                    console.log(`Popup actual position: x=${actualX}, y=${actualY}, intended: x=${screenX}, y=${screenY}`);
                }, 100);
            }
            
            return popup;
        };

        const getScreensInfo = async () => {
            if ("getScreenDetails" in window) {
                if (cachedScreens) {
                    return cachedScreens.screens;
                } else {
                    try {
                        cachedScreens = await window.getScreenDetails();
                        console.log('Screens detected:', cachedScreens.screens.map(s => ({
                            label: s.label,
                            availLeft: s.availLeft,
                            availTop: s.availTop,
                            availWidth: s.availWidth,
                            availHeight: s.availHeight,
                            isPrimary: s.isPrimary,
                            isInternal: s.isInternal
                        })));
                        
                        cachedScreens.addEventListener("screenschange", async e => {
                            console.log("screenschange", e);
                            closeAllPopups();
                            await elmerify();
                        });
                        cachedScreens.addEventListener("currentscreenchange", async e => {
                            console.log("currentscreenchange", e);
                        });
                        return cachedScreens.screens;
                    } catch (error) {
                        console.error('getScreenDetails failed:', error);
                        return [window.screen];
                    }
                }
            }
            console.log('Window Management API not available, using fallback');
            return [window.screen];
        };

        const onPopupClose = e => {
            e.preventDefault();
            closeAllPopups();
            return e.returnValue = "This string must be non-empty";
        };

        const closeAllPopups = () => {
            popups.forEach(popup => {
                popup.removeEventListener("beforeunload", onPopupClose);
                popup.close();
            });
            popups = [];  
            clearInterval(popupMonitor);
        };

        const checkPopupClose = () => {
            popups.forEach(popup => {
                if (popup.closed) {
                    closeAllPopups();
                    return;
                }
            });
        }

        const onPopupClick = async e => {
            const body = e.target.closest("body");
            popups.forEach(popup => {
                if (e.view === popup) {
                    return;
                }
                popup.document.exitFullscreen();
            });
            try {
                if (e.view.document.fullscreenElement) {
                    return await e.view.document.exitFullscreen();
                }
                const screensInterface = await e.view.getScreenDetails();
                let otherScreen = screensInterface.screens.filter(
                    screen => screen !== screensInterface.currentScreen
                )[0];
                if (!otherScreen) {
                    otherScreen = screensInterface.screens[0];
                }
                await body.requestFullscreen({
                    screen: otherScreen
                });
            } catch (err) {
                console.error(err.name, err.message);
            }
        };

        const elmerify = async () => {
            console.log('Starting elmerify...');
            
            // For now, don't run in an iframe, but pop out to a new window.
            if (window.self !== window.top) {
                window.open(location.href);
                return;
            }
            
            const screens = await getScreensInfo();
            console.log(`Using ${screens.length} screen(s)`);

            popups = [];
            screens.forEach((screen, numScreen) => {
                console.log(`Setting up screen ${numScreen}:`, {
                    label: screen.label || 'Unknown',
                    availLeft: screen.availLeft,
                    availTop: screen.availTop,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight
                });
                
                let width = Math.floor((screen.availWidth - COLS * WINDOW_CHROME_X) / COLS);
                let height = Math.floor((screen.availHeight - ROWS * WINDOW_CHROME_Y) / ROWS);
                
                loop: for (let i = 0; i < COLS; i++) {
                    for (let j = 0; j < ROWS; j++) {
                        let screenX = i * width + screen.availLeft + i * WINDOW_CHROME_X;
                        let screenY = j * height + screen.availTop + j * WINDOW_CHROME_Y;
                        
                        console.log(`Creating popup at: x=${screenX}, y=${screenY}, w=${width}, h=${height}`);
                        
                        const popup = createPopup(screenX, screenY, width, height);
                        if (!popup) {
                            popups.forEach(popup => popup.close());
                            alert("It looks like you are blocking popup windows. Please allow them as outlined at https://goo.gle/allow-popups.");
                            break loop;
                        }
                        popup.addEventListener("beforeunload", onPopupClose);
                        popup.addEventListener("click", onPopupClick);
                        popups.push(popup);
                    }
                }
            });
            
            // Workaround for beforeunload event listener not being called; see crbug.com/1153004.
            popupMonitor = setInterval(checkPopupClose, 500);
        };

        const init = async () => {
            console.log('Initializing Google Window Management Demo...');
            
            document.getElementById("elmerBtn").addEventListener("click", async () => {
                console.log('Elmer clicked!');
                closeAllPopups();
                await elmerify();
            });

            window.addEventListener("beforeunload", () => {
                closeAllPopups();
            });
            
            // Check if API is available on load
            if ("getScreenDetails" in window) {
                console.log('‚úÖ Window Management API is available');
            } else {
                console.log('‚ùå Window Management API is NOT available');
            }
            
            console.log('Current screen info:', {
                width: window.screen.width,
                height: window.screen.height,
                availWidth: window.screen.availWidth,
                availHeight: window.screen.availHeight,
                isExtended: window.screen.isExtended
            });
        };

        init();
    </script>


</body></html>
