<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ink Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            user-select: none;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #drawingArea {
            cursor: crosshair;
            background: white;
        }
        
        .icon-button {
            transition: all 0.2s ease;
        }
        
        .icon-button:hover {
            transform: scale(1.1);
        }
        
        .icon-button:active {
            transform: scale(0.95);
        }

        .menu-overlay {
            backdrop-filter: blur(8px);
        }

        /* Dark mode support - but keep drawing area white */
        @media (prefers-color-scheme: dark) {
            .bg-white { background-color: #181818; }
            .text-black { color: #ffffff; }
            .text-gray-600 { color: #a0a0a0; }
            .text-gray-800 { color: #e0e0e0; }
            .bg-gray-50 { background-color: #2a2a2a; }
            .border-gray-200 { border-color: #404040; }
        }
    </style>
</head>
<body class="bg-white">
    <!-- Menu Button -->
    <button id="menuButton" class="icon-button fixed top-4 left-4 z-50 p-3 bg-black text-white rounded-full shadow-lg">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>

    <!-- Clear Button -->
    <button id="clearButton" class="icon-button fixed top-4 right-4 z-50 p-3 bg-black text-white rounded-full shadow-lg">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3,6 5,6 21,6"></polyline>
            <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
        </svg>
    </button>

    <!-- Hidden Menu -->
    <div id="menuOverlay" class="menu-overlay fixed inset-0 bg-black bg-opacity-50 z-40 hidden">
        <div id="menuPanel" class="fixed top-0 left-0 h-full w-80 bg-gray-50 border-r border-gray-200 transform -translate-x-full transition-transform duration-300 flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-gray-200 flex-shrink-0">
                <h2 class="text-lg font-bold text-gray-800">Drawing Settings</h2>
                <button id="copySettings" class="icon-button p-2 text-gray-600 hover:text-gray-800" title="Copy all settings">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                    </svg>
                </button>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-5">
                <!-- Basic Stroke Properties -->
                <div>
                    <h3 class="text-xs font-bold text-gray-700 mb-3 uppercase tracking-wide">Stroke Properties</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Stroke Width</label>
                            <input type="range" id="strokeWidth" min="1" max="20" value="3" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="strokeWidthValue" class="text-xs text-gray-600">3px</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Controls the thickness of your pen strokes</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Stroke Color</label>
                            <div class="flex items-center space-x-2">
                                <input type="color" id="strokeColor" value="#373737" class="w-8 h-8 rounded border border-gray-300 cursor-pointer">
                                <span id="strokeColorValue" class="text-xs text-gray-600">#373737</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Color of the final rendered pen strokes</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Preview Ink Color</label>
                            <div class="flex items-center space-x-2">
                                <input type="color" id="previewColor" value="#373737" class="w-8 h-8 rounded border border-gray-300 cursor-pointer">
                                <span id="previewColorValue" class="text-xs text-gray-600">#373737</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Color of the real-time drawing preview (Ink API)</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Smoothing Method</label>
                            <select id="smoothingMethod" class="w-full text-sm border border-gray-300 rounded px-2 py-1">
                                <option value="none">Direct (No Smoothing)</option>
                                <option value="chaikin" selected>Chaikin Smoothing</option>
                            </select>
                            <p class="text-[10px] text-gray-500 mt-1">Algorithm used to smooth stroke curves</p>
                        </div>

                        <div id="chaikinSettings" class="space-y-3 pl-3 border-l-2 border-gray-300">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Smoothing Iterations</label>
                                <input type="range" id="smoothingIterations" min="1" max="5" value="2" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="smoothingIterationsValue" class="text-xs text-gray-600">2</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Number of smoothing passes (higher = smoother)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Smoothing Factor</label>
                                <input type="range" id="smoothingFactor" min="0.1" max="0.4" step="0.05" value="0.25" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="smoothingFactorValue" class="text-xs text-gray-600">0.25</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Smoothing intensity (lower = more aggressive smoothing)</p>
                            </div>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Opacity</label>
                            <input type="range" id="strokeOpacity" min="0.1" max="1" step="0.1" value="1" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="strokeOpacityValue" class="text-xs text-gray-600">100%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">How transparent or solid the strokes appear</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">
                                <input type="checkbox" id="enableShadow" checked class="mr-1"> Enable Drop Shadow
                            </label>
                            <p class="text-[10px] text-gray-500 mt-1">Adds a drop shadow effect to strokes</p>
                        </div>

                        <div id="shadowSettings" class="hidden space-y-3 pl-3 border-l-2 border-gray-300">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Offset X</label>
                                <input type="range" id="shadowOffsetX" min="-10" max="10" value="0" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowOffsetXValue" class="text-xs text-gray-600">0px</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Horizontal shadow distance (negative = left)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Offset Y</label>
                                <input type="range" id="shadowOffsetY" min="-10" max="10" value="0" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowOffsetYValue" class="text-xs text-gray-600">0px</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Vertical shadow distance (negative = up)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Blur</label>
                                <input type="range" id="shadowBlur" min="0" max="10" value="2" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowBlurValue" class="text-xs text-gray-600">2px</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Shadow blur radius (0 = sharp, higher = softer)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Color</label>
                                <div class="flex items-center space-x-2">
                                    <input type="color" id="shadowColor" value="#000000" class="w-8 h-8 rounded border border-gray-300 cursor-pointer">
                                    <span id="shadowColorValue" class="text-xs text-gray-600">#000000</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Color of the drop shadow</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Opacity</label>
                                <input type="range" id="shadowOpacity" min="0.1" max="1" step="0.1" value="0.4" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowOpacityValue" class="text-xs text-gray-600">40%</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">How transparent or solid the shadow appears</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Separator -->
                <div class="border-t border-gray-300"></div>

                <!-- Tapering Controls -->
                <div>
                    <h3 class="text-xs font-bold text-gray-700 mb-3 uppercase tracking-wide">Stroke Tapering</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">
                                <input type="checkbox" id="enableTapering" checked class="mr-1"> Enable Tapering
                            </label>
                            <p class="text-[10px] text-gray-500 mt-1">Creates natural pen-like tapered stroke endings</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Start Taper Amount</label>
                            <input type="range" id="startTaper" min="0" max="1" step="0.1" value="0.3" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="startTaperValue" class="text-xs text-gray-600">30%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">How much the stroke thins at the beginning</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">End Taper Amount</label>
                            <input type="range" id="endTaper" min="0" max="1" step="0.1" value="0.5" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="endTaperValue" class="text-xs text-gray-600">50%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">How much the stroke thins at the end (0% = no taper, 100% = sharp point)</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Taper Start Point</label>
                            <input type="range" id="taperStart" min="50" max="100" step="1" value="97" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="taperStartValue" class="text-xs text-gray-600">97%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Where along the stroke the end tapering begins (50% = early, 100% = late)</p>
                        </div>
                    </div>
                </div>

                <!-- Separator -->
                <div class="border-t border-gray-300"></div>

                <!-- System Information -->
                <div>
                    <h3 class="text-xs font-bold text-gray-700 mb-3 uppercase tracking-wide">System Info</h3>
                    <div>
                        <label class="block text-xs font-medium text-gray-800 mb-1">Ink API Status</label>
                        <p id="inkApiStatus" class="text-xs text-gray-600">Checking...</p>
                        <p class="text-[10px] text-gray-500 mt-1">Shows if low-latency stylus rendering is available in your browser</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Area -->
    <svg id="drawingArea" class="w-screen h-screen" xmlns="http://www.w3.org/2000/svg"></svg>



    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        class DrawingApp {
            constructor() {
                this.svg = document.getElementById('drawingArea');
                this.isDrawing = false;
                this.currentPath = null;
                this.currentPoints = [];
                this.strokeWidth = 3;
                this.strokeColor = '#373737';
                this.previewColor = '#373737';
                this.smoothingMethod = 'chaikin';
                this.smoothingIterations = 2;
                this.smoothingFactor = 0.25;
                this.strokeOpacity = 1;
                this.enableShadow = true;
                this.shadowOffsetX = 0;
                this.shadowOffsetY = 0;
                this.shadowBlur = 2;
                this.shadowColor = '#000000';
                this.shadowOpacity = 0.4;
                this.enableTapering = true;
                this.startTaper = 0.3; // How much the start tapers (0-1)
                this.endTaper = 0.5; // How much the end tapers (0-1)  
                this.taperStart = 0.97; // Where tapering begins (0-1)
                this.presenter = null;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupMenu();
                this.initInkAPI();
            }

            setupCanvas() {
                this.resizeCanvas();
                this.setupShadowFilter();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            setupShadowFilter() {
                // Create SVG defs section for filters
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                this.svg.appendChild(defs);
                
                // Create drop shadow filter
                this.shadowFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                this.shadowFilter.setAttribute('id', 'dropShadow');
                this.shadowFilter.setAttribute('x', '-50%');
                this.shadowFilter.setAttribute('y', '-50%');
                this.shadowFilter.setAttribute('width', '200%');
                this.shadowFilter.setAttribute('height', '200%');
                
                // Create flood element for shadow color
                this.shadowFlood = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
                this.shadowFlood.setAttribute('result', 'flood');
                
                // Create composite element
                const composite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
                composite.setAttribute('in', 'flood');
                composite.setAttribute('in2', 'SourceGraphic');
                composite.setAttribute('operator', 'in');
                composite.setAttribute('result', 'composite');
                
                // Create gaussian blur element
                this.shadowBlurFilter = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                this.shadowBlurFilter.setAttribute('in', 'composite');
                this.shadowBlurFilter.setAttribute('result', 'blur');
                
                // Create offset element
                this.shadowOffsetFilter = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
                this.shadowOffsetFilter.setAttribute('in', 'blur');
                this.shadowOffsetFilter.setAttribute('result', 'offset');
                
                // Create merge element
                const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                
                const mergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode1.setAttribute('in', 'offset');
                
                const mergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode2.setAttribute('in', 'SourceGraphic');
                
                merge.appendChild(mergeNode1);
                merge.appendChild(mergeNode2);
                
                // Add all elements to filter
                this.shadowFilter.appendChild(this.shadowFlood);
                this.shadowFilter.appendChild(composite);
                this.shadowFilter.appendChild(this.shadowBlurFilter);
                this.shadowFilter.appendChild(this.shadowOffsetFilter);
                this.shadowFilter.appendChild(merge);
                
                defs.appendChild(this.shadowFilter);
                
                this.updateShadowFilter();
            }

            updateShadowFilter() {
                if (!this.shadowFilter) return;
                
                // Convert shadow color to rgba with opacity
                const rgb = this.hexToRgb(this.shadowColor);
                const shadowColorRgba = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${this.shadowOpacity})`;
                
                this.shadowFlood.setAttribute('flood-color', this.shadowColor);
                this.shadowFlood.setAttribute('flood-opacity', this.shadowOpacity);
                this.shadowBlurFilter.setAttribute('stdDeviation', this.shadowBlur);
                this.shadowOffsetFilter.setAttribute('dx', this.shadowOffsetX);
                this.shadowOffsetFilter.setAttribute('dy', this.shadowOffsetY);
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            resizeCanvas() {
                this.svg.setAttribute('width', window.innerWidth);
                this.svg.setAttribute('height', window.innerHeight);
                this.svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
            }

            async initInkAPI() {
                try {
                    if ('ink' in navigator) {
                        // Create a canvas for ink API
                        const canvas = document.createElement('canvas');
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        canvas.style.position = 'absolute';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        canvas.style.pointerEvents = 'none';
                        canvas.style.zIndex = '5';
                        document.body.appendChild(canvas);
                        
                        this.presenter = await navigator.ink.requestPresenter({ 
                            presentationArea: canvas 
                        });
                        document.getElementById('inkApiStatus').textContent = '✅ Available';
                        console.log('Ink API initialized');
                    } else {
                        throw new Error('Not supported');
                    }
                } catch (error) {
                    document.getElementById('inkApiStatus').textContent = '❌ Not Available';
                    console.log('Ink API not available');
                }
            }

            setupEventListeners() {
                // Only stylus/pen input allowed
                this.svg.addEventListener('pointerdown', (e) => {
                    if (e.pointerType === 'pen') {
                        e.preventDefault();
                        this.startDrawing(e);
                    }
                });

                this.svg.addEventListener('pointermove', (e) => {
                    if (e.pointerType === 'pen' && this.isDrawing) {
                        e.preventDefault();
                        this.continueDrawing(e);
                    }
                });

                this.svg.addEventListener('pointerup', (e) => {
                    if (e.pointerType === 'pen') {
                        e.preventDefault();
                        this.stopDrawing(e);
                    }
                });

                this.svg.addEventListener('pointercancel', (e) => {
                    if (e.pointerType === 'pen' && this.isDrawing) {
                        this.stopDrawing(e);
                    }
                });

                // Prevent all touch and mouse interactions
                this.svg.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                });

                this.svg.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                });

                // Clear button
                document.getElementById('clearButton').addEventListener('click', () => {
                    this.clearCanvas();
                });

                // Prevent context menu
                this.svg.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            startDrawing(e) {
                this.isDrawing = true;
                this.currentPoints = [];
                
                const point = this.getPoint(e);
                this.currentPoints.push({ ...point, timestamp: Date.now() });
                
                // Create new path element for tapered stroke
                this.currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.currentPath.setAttribute('fill', this.strokeColor);
                this.currentPath.setAttribute('fill-opacity', this.strokeOpacity);
                this.currentPath.setAttribute('stroke', 'none');
                
                // Apply shadow filter if enabled
                if (this.enableShadow) {
                    this.updateShadowFilter();
                    this.currentPath.setAttribute('filter', 'url(#dropShadow)');
                }
                
                this.svg.appendChild(this.currentPath);
                
                // Update Ink API
                if (this.presenter && e.pointerId !== undefined) {
                    try {
                        this.presenter.updateInkTrailStartPoint(e, {
                            color: this.previewColor,
                            diameter: this.strokeWidth
                        });
                    } catch (error) {
                        console.log('Ink API error:', error);
                    }
                }
            }

            continueDrawing(e) {
                if (!this.isDrawing || !this.currentPath) return;
                
                const point = this.getPoint(e);
                this.currentPoints.push({ ...point, timestamp: Date.now() });
                
                // Update the tapered stroke path
                this.updateTaperedPath();
                
                // Update Ink API
                if (this.presenter && e.pointerId !== undefined) {
                    try {
                        this.presenter.updateInkTrailStartPoint(e, {
                            color: this.previewColor,
                            diameter: this.strokeWidth
                        });
                    } catch (error) {
                        console.log('Ink API error:', error);
                    }
                }
            }

            stopDrawing(e) {
                this.isDrawing = false;
                
                // Final update with taper at the end
                if (this.currentPath && this.currentPoints.length > 1) {
                    this.updateTaperedPath(true);
                }
                
                this.currentPath = null;
                this.currentPoints = [];
            }

            getPoint(e) {
                const rect = this.svg.getBoundingClientRect();
                return {
                    x: (e.clientX || e.pageX) - rect.left,
                    y: (e.clientY || e.pageY) - rect.top
                };
            }

            clearCanvas() {
                // Remove all paths
                const paths = this.svg.querySelectorAll('path');
                paths.forEach(path => path.remove());
            }



            setupMenu() {
                const menuButton = document.getElementById('menuButton');
                const menuOverlay = document.getElementById('menuOverlay');
                const menuPanel = document.getElementById('menuPanel');
                const copySettings = document.getElementById('copySettings');

                menuButton.addEventListener('click', () => {
                    menuOverlay.classList.remove('hidden');
                    menuButton.style.display = 'none'; // Hide menu button
                    setTimeout(() => {
                        menuPanel.style.transform = 'translateX(0)';
                    }, 10);
                });

                const closeMenuFunc = () => {
                    menuPanel.style.transform = 'translateX(-100%)';
                    setTimeout(() => {
                        menuOverlay.classList.add('hidden');
                        menuButton.style.display = 'block'; // Show menu button again
                    }, 300);
                };

                // Copy settings functionality
                copySettings.addEventListener('click', () => {
                    this.copyAllSettings();
                });

                menuOverlay.addEventListener('click', (e) => {
                    if (e.target === menuOverlay) {
                        closeMenuFunc();
                    }
                });

                // Stroke width control
                const strokeWidth = document.getElementById('strokeWidth');
                const strokeWidthValue = document.getElementById('strokeWidthValue');
                strokeWidth.addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    strokeWidthValue.textContent = `${this.strokeWidth}px`;
                });

                // Stroke color control
                const strokeColor = document.getElementById('strokeColor');
                const strokeColorValue = document.getElementById('strokeColorValue');
                strokeColor.addEventListener('input', (e) => {
                    this.strokeColor = e.target.value;
                    strokeColorValue.textContent = this.strokeColor.toUpperCase();
                });

                // Preview ink color control
                const previewColor = document.getElementById('previewColor');
                const previewColorValue = document.getElementById('previewColorValue');
                previewColor.addEventListener('input', (e) => {
                    this.previewColor = e.target.value;
                    previewColorValue.textContent = this.previewColor.toUpperCase();
                });

                // Smoothing method control
                const smoothingMethod = document.getElementById('smoothingMethod');
                const chaikinSettings = document.getElementById('chaikinSettings');
                smoothingMethod.addEventListener('change', (e) => {
                    this.smoothingMethod = e.target.value;
                    // Show/hide Chaikin settings based on selection
                    if (e.target.value === 'chaikin') {
                        chaikinSettings.classList.remove('hidden');
                    } else {
                        chaikinSettings.classList.add('hidden');
                    }
                });

                // Chaikin smoothing controls
                const smoothingIterations = document.getElementById('smoothingIterations');
                const smoothingIterationsValue = document.getElementById('smoothingIterationsValue');
                smoothingIterations.addEventListener('input', (e) => {
                    this.smoothingIterations = parseInt(e.target.value);
                    smoothingIterationsValue.textContent = this.smoothingIterations;
                });

                const smoothingFactor = document.getElementById('smoothingFactor');
                const smoothingFactorValue = document.getElementById('smoothingFactorValue');
                smoothingFactor.addEventListener('input', (e) => {
                    this.smoothingFactor = parseFloat(e.target.value);
                    smoothingFactorValue.textContent = this.smoothingFactor;
                });

                // Opacity control
                const strokeOpacity = document.getElementById('strokeOpacity');
                const strokeOpacityValue = document.getElementById('strokeOpacityValue');
                strokeOpacity.addEventListener('input', (e) => {
                    this.strokeOpacity = parseFloat(e.target.value);
                    strokeOpacityValue.textContent = `${Math.round(this.strokeOpacity * 100)}%`;
                });

                // Shadow controls
                const enableShadow = document.getElementById('enableShadow');
                const shadowSettings = document.getElementById('shadowSettings');
                enableShadow.addEventListener('change', (e) => {
                    this.enableShadow = e.target.checked;
                    if (e.target.checked) {
                        shadowSettings.classList.remove('hidden');
                    } else {
                        shadowSettings.classList.add('hidden');
                    }
                });

                const shadowOffsetX = document.getElementById('shadowOffsetX');
                const shadowOffsetXValue = document.getElementById('shadowOffsetXValue');
                shadowOffsetX.addEventListener('input', (e) => {
                    this.shadowOffsetX = parseInt(e.target.value);
                    shadowOffsetXValue.textContent = `${this.shadowOffsetX}px`;
                });

                const shadowOffsetY = document.getElementById('shadowOffsetY');
                const shadowOffsetYValue = document.getElementById('shadowOffsetYValue');
                shadowOffsetY.addEventListener('input', (e) => {
                    this.shadowOffsetY = parseInt(e.target.value);
                    shadowOffsetYValue.textContent = `${this.shadowOffsetY}px`;
                });

                const shadowBlur = document.getElementById('shadowBlur');
                const shadowBlurValue = document.getElementById('shadowBlurValue');
                shadowBlur.addEventListener('input', (e) => {
                    this.shadowBlur = parseInt(e.target.value);
                    shadowBlurValue.textContent = `${this.shadowBlur}px`;
                });

                const shadowColor = document.getElementById('shadowColor');
                const shadowColorValue = document.getElementById('shadowColorValue');
                shadowColor.addEventListener('input', (e) => {
                    this.shadowColor = e.target.value;
                    shadowColorValue.textContent = this.shadowColor.toUpperCase();
                });

                const shadowOpacity = document.getElementById('shadowOpacity');
                const shadowOpacityValue = document.getElementById('shadowOpacityValue');
                shadowOpacity.addEventListener('input', (e) => {
                    this.shadowOpacity = parseFloat(e.target.value);
                    shadowOpacityValue.textContent = `${Math.round(this.shadowOpacity * 100)}%`;
                });

                // Tapering controls
                const enableTapering = document.getElementById('enableTapering');
                enableTapering.addEventListener('change', (e) => {
                    this.enableTapering = e.target.checked;
                });

                const startTaper = document.getElementById('startTaper');
                const startTaperValue = document.getElementById('startTaperValue');
                startTaper.addEventListener('input', (e) => {
                    this.startTaper = parseFloat(e.target.value);
                    startTaperValue.textContent = `${Math.round(this.startTaper * 100)}%`;
                });

                const endTaper = document.getElementById('endTaper');
                const endTaperValue = document.getElementById('endTaperValue');
                endTaper.addEventListener('input', (e) => {
                    this.endTaper = parseFloat(e.target.value);
                    endTaperValue.textContent = `${Math.round(this.endTaper * 100)}%`;
                });

                const taperStart = document.getElementById('taperStart');
                const taperStartValue = document.getElementById('taperStartValue');
                taperStart.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.taperStart = value / 100; // Convert from 50-100 range to 0.5-1.0 range
                    taperStartValue.textContent = `${value}%`;
                });

            }

            updateTaperedPath(isEnding = false) {
                if (this.currentPoints.length < 2) return;

                const points = this.currentPoints;
                const path = [];
                
                // Start the path
                path.push(`M ${points[0].x} ${points[0].y}`);
                
                if (points.length === 2) {
                    // Simple line for two points
                    const startWidth = this.strokeWidth * 0.8;
                    const endWidth = isEnding ? this.strokeWidth * 0.2 : this.strokeWidth;
                    
                    const dx = points[1].x - points[0].x;
                    const dy = points[1].y - points[0].y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if (length > 0) {
                        const perpX = -dy / length;
                        const perpY = dx / length;
                        
                        // Create tapered stroke as filled path
                        const x1 = points[0].x + perpX * startWidth / 2;
                        const y1 = points[0].y + perpY * startWidth / 2;
                        const x2 = points[0].x - perpX * startWidth / 2;
                        const y2 = points[0].y - perpY * startWidth / 2;
                        const x3 = points[1].x - perpX * endWidth / 2;
                        const y3 = points[1].y - perpY * endWidth / 2;
                        const x4 = points[1].x + perpX * endWidth / 2;
                        const y4 = points[1].y + perpY * endWidth / 2;
                        
                        const pathData = `M ${x1} ${y1} L ${x4} ${y4} L ${x3} ${y3} L ${x2} ${y2} Z`;
                        this.currentPath.setAttribute('d', pathData);
                    }
                } else {
                    // Create smooth tapered path for multiple points
                    const pathData = this.createTaperedStrokePath(points, isEnding);
                    this.currentPath.setAttribute('d', pathData);
                }
            }

            applyChaikinSmoothing(points, iterations = 2) {
                if (points.length < 3) return points;
                
                let smoothedPoints = [...points];
                
                for (let iter = 0; iter < iterations; iter++) {
                    if (smoothedPoints.length < 3) break;
                    
                    const newPoints = [];
                    
                    // Keep the first point
                    newPoints.push(smoothedPoints[0]);
                    
                    // Apply Chaikin's corner cutting algorithm
                    for (let i = 0; i < smoothedPoints.length - 1; i++) {
                        const p1 = smoothedPoints[i];
                        const p2 = smoothedPoints[i + 1];
                        
                        // Create quarter points using configurable smoothing factor
                        const q1 = {
                            x: p1.x + (1 - this.smoothingFactor) * (p2.x - p1.x),
                            y: p1.y + (1 - this.smoothingFactor) * (p2.y - p1.y)
                        };
                        
                        const q2 = {
                            x: p1.x + this.smoothingFactor * (p2.x - p1.x),
                            y: p1.y + this.smoothingFactor * (p2.y - p1.y)
                        };
                        
                        newPoints.push(q2, q1);
                    }
                    
                    // Keep the last point
                    newPoints.push(smoothedPoints[smoothedPoints.length - 1]);
                    
                    smoothedPoints = newPoints;
                }
                
                return smoothedPoints;
            }

            createTaperedStrokePath(points, isEnding = false) {
                if (points.length < 2) return '';

                // Apply smoothing if selected
                let processedPoints = points;
                if (this.smoothingMethod === 'chaikin') {
                    processedPoints = this.applyChaikinSmoothing(points, this.smoothingIterations);
                }

                const leftPoints = [];
                const rightPoints = [];
                
                for (let i = 0; i < processedPoints.length; i++) {
                    const point = processedPoints[i];
                    const progress = i / (processedPoints.length - 1);
                    
                    // Calculate width with configurable tapering
                    let width = this.strokeWidth;
                    
                    if (this.enableTapering) {
                        if (isEnding && progress > this.taperStart) {
                            // Taper the end based on user settings
                            const taperProgress = (progress - this.taperStart) / (1 - this.taperStart);
                            width = this.strokeWidth * (1 - taperProgress * this.endTaper);
                        } else if (progress < 0.2) {
                            // Soft start with configurable amount
                            const startTaperAmount = this.startTaper;
                            width = this.strokeWidth * ((1 - startTaperAmount) + progress * startTaperAmount * 5);
                        }
                    }
                    
                    // Calculate perpendicular direction for width
                    let perpX = 0, perpY = 0;
                    
                    if (i === 0 && processedPoints.length > 1) {
                        const dx = processedPoints[1].x - processedPoints[0].x;
                        const dy = processedPoints[1].y - processedPoints[0].y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            perpX = -dy / length;
                            perpY = dx / length;
                        }
                    } else if (i === processedPoints.length - 1) {
                        const dx = processedPoints[i].x - processedPoints[i - 1].x;
                        const dy = processedPoints[i].y - processedPoints[i - 1].y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            perpX = -dy / length;
                            perpY = dx / length;
                        }
                    } else {
                        // Average of adjacent segments
                        const dx1 = processedPoints[i].x - processedPoints[i - 1].x;
                        const dy1 = processedPoints[i].y - processedPoints[i - 1].y;
                        const dx2 = processedPoints[i + 1].x - processedPoints[i].x;
                        const dy2 = processedPoints[i + 1].y - processedPoints[i].y;
                        
                        const avgDx = (dx1 + dx2) / 2;
                        const avgDy = (dy1 + dy2) / 2;
                        const length = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
                        
                        if (length > 0) {
                            perpX = -avgDy / length;
                            perpY = avgDx / length;
                        }
                    }
                    
                    leftPoints.push({
                        x: point.x + perpX * width / 2,
                        y: point.y + perpY * width / 2
                    });
                    
                    rightPoints.push({
                        x: point.x - perpX * width / 2,
                        y: point.y - perpY * width / 2
                    });
                }
                
                // Create the path
                let pathData = `M ${leftPoints[0].x} ${leftPoints[0].y}`;
                
                // Draw left side
                for (let i = 1; i < leftPoints.length; i++) {
                    pathData += ` L ${leftPoints[i].x} ${leftPoints[i].y}`;
                }
                
                // Draw right side (reversed)
                for (let i = rightPoints.length - 1; i >= 0; i--) {
                    pathData += ` L ${rightPoints[i].x} ${rightPoints[i].y}`;
                }
                
                pathData += ' Z';
                return pathData;
            }

            copyAllSettings() {
                // Gather all current settings from the menu
                const settings = {
                    strokeWidth: this.strokeWidth,
                    strokeOpacity: this.strokeOpacity,
                    enableTapering: this.enableTapering,
                    startTaper: this.startTaper,
                    endTaper: this.endTaper,
                    taperStart: Math.round(this.taperStart * 100) // Convert back to percentage for display
                };

                // Format the settings for easy sharing
                let settingsText = `Drawing App Settings:
═══════════════════════

📐 STROKE PROPERTIES:
• Stroke Width: ${settings.strokeWidth}px
• Stroke Color: ${this.strokeColor.toUpperCase()}
• Preview Ink Color: ${this.previewColor.toUpperCase()}
• Smoothing Method: ${this.smoothingMethod === 'none' ? 'Direct (No Smoothing)' : 'Chaikin Smoothing'}`;

                // Add Chaikin settings if enabled
                if (this.smoothingMethod === 'chaikin') {
                    settingsText += `
  ↳ Smoothing Iterations: ${this.smoothingIterations}
  ↳ Smoothing Factor: ${this.smoothingFactor}`;
                }

                settingsText += `
• Opacity: ${Math.round(settings.strokeOpacity * 100)}%
• Drop Shadow: ${this.enableShadow ? 'Enabled' : 'Disabled'}`;

                // Add shadow settings if enabled
                if (this.enableShadow) {
                    settingsText += `
  ↳ Shadow Offset X: ${this.shadowOffsetX}px
  ↳ Shadow Offset Y: ${this.shadowOffsetY}px
  ↳ Shadow Blur: ${this.shadowBlur}px
  ↳ Shadow Color: ${this.shadowColor.toUpperCase()}
  ↳ Shadow Opacity: ${Math.round(this.shadowOpacity * 100)}%`;
                }

                settingsText += `

🎨 STROKE TAPERING:
• Enable Tapering: ${settings.enableTapering ? 'Yes' : 'No'}
• Start Taper Amount: ${Math.round(settings.startTaper * 100)}%
• End Taper Amount: ${Math.round(settings.endTaper * 100)}%
• Taper Start Point: ${settings.taperStart}%

═══════════════════════
Copy this to share your current settings!`;

                // Copy to clipboard
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(settingsText).then(() => {
                        // Show brief feedback
                        const button = document.getElementById('copySettings');
                        const originalTitle = button.title;
                        button.title = 'Copied!';
                        button.style.color = '#10b981'; // Green color
                        
                        setTimeout(() => {
                            button.title = originalTitle;
                            button.style.color = '';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy settings:', err);
                        this.fallbackCopy(settingsText);
                    });
                } else {
                    this.fallbackCopy(settingsText);
                }
            }

            fallbackCopy(text) {
                // Fallback method for browsers without clipboard API
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    // Show feedback
                    const button = document.getElementById('copySettings');
                    button.title = 'Copied!';
                    button.style.color = '#10b981';
                    setTimeout(() => {
                        button.title = 'Copy all settings';
                        button.style.color = '';
                    }, 2000);
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                }
                
                document.body.removeChild(textArea);
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            new DrawingApp();
        });
    </script>
</body>
</html>
