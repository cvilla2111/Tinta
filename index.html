<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ink Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            user-select: none;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #drawingArea {
            cursor: crosshair;
            background: white;
        }
        
        .icon-button {
            transition: all 0.2s ease;
        }
        
        .icon-button:hover {
            transform: scale(1.1);
        }
        
        .icon-button:active {
            transform: scale(0.95);
        }

        .menu-overlay {
            backdrop-filter: blur(8px);
        }

        /* Dark mode support - but keep drawing area white */
        @media (prefers-color-scheme: dark) {
            .bg-white { background-color: #181818; }
            .text-black { color: #ffffff; }
            .text-gray-600 { color: #a0a0a0; }
            .text-gray-800 { color: #e0e0e0; }
            .bg-gray-50 { background-color: #2a2a2a; }
            .border-gray-200 { border-color: #404040; }
        }
    </style>
</head>
<body class="bg-white">
    <!-- Menu Button -->
    <button id="menuButton" class="icon-button fixed top-4 left-4 z-50 p-3 bg-black text-white rounded-full shadow-lg">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>

    <!-- Clear Button -->
    <button id="clearButton" class="icon-button fixed top-4 right-4 z-50 p-3 bg-black text-white rounded-full shadow-lg">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3,6 5,6 21,6"></polyline>
            <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
        </svg>
    </button>

    <!-- Hidden Menu -->
    <div id="menuOverlay" class="menu-overlay fixed inset-0 bg-black bg-opacity-50 z-40 hidden">
        <div id="menuPanel" class="fixed top-0 left-0 h-full w-80 bg-gray-50 border-r border-gray-200 transform -translate-x-full transition-transform duration-300 flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-gray-200 flex-shrink-0">
                <h2 class="text-lg font-bold text-gray-800">Drawing Settings</h2>
                <button id="copySettings" class="icon-button p-2 text-gray-600 hover:text-gray-800" title="Copy all settings">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                    </svg>
                </button>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-5">
                <!-- Basic Stroke Properties -->
                <div>
                    <h3 class="text-xs font-bold text-gray-700 mb-3 uppercase tracking-wide">Stroke Properties</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Stroke Width</label>
                            <input type="range" id="strokeWidth" min="1" max="20" value="3" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="strokeWidthValue" class="text-xs text-gray-600">3px</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Controls the thickness of your pen strokes</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Stroke Color</label>
                            <div class="flex items-center space-x-2">
                                <input type="color" id="strokeColor" value="#212121" class="w-8 h-8 rounded border border-gray-300 cursor-pointer">
                                <span id="strokeColorValue" class="text-xs text-gray-600">#212121</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Color of the final rendered pen strokes</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Preview Ink Color</label>
                            <div class="flex items-center space-x-2">
                                <input type="color" id="previewColor" value="#212121" class="w-8 h-8 rounded border border-gray-300 cursor-pointer">
                                <span id="previewColorValue" class="text-xs text-gray-600">#212121</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Color of the real-time drawing preview (Ink API)</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Smoothing Method</label>
                            <select id="smoothingMethod" class="w-full text-sm border border-gray-300 rounded px-2 py-1">
                                <option value="none">Direct (No Smoothing)</option>
                                <option value="chaikin" selected>Chaikin Smoothing</option>
                                <option value="catmullrom">Catmull-Rom Splines</option>
                                <option value="bezier">Bezier Smoothing</option>
                            </select>
                            <p class="text-[10px] text-gray-500 mt-1">Algorithm used to smooth stroke curves</p>
                        </div>

                        <div id="chaikinSettings" class="space-y-3 pl-3 border-l-2 border-gray-300">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Smoothing Iterations</label>
                                <input type="range" id="smoothingIterations" min="1" max="5" value="2" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="smoothingIterationsValue" class="text-xs text-gray-600">2</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Number of smoothing passes (higher = smoother)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Smoothing Factor</label>
                                <input type="range" id="smoothingFactor" min="0.1" max="0.4" step="0.05" value="0.25" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="smoothingFactorValue" class="text-xs text-gray-600">0.25</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Smoothing intensity (lower = more aggressive smoothing)</p>
                            </div>
                        </div>

                        <div id="catmullromSettings" class="hidden space-y-3 pl-3 border-l-2 border-gray-300">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Tension</label>
                                <input type="range" id="splineTension" min="0" max="1" step="0.1" value="0.5" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="splineTensionValue" class="text-xs text-gray-600">0.5</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Curve tension (0 = loose curves, 1 = tight curves)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Curve Segments</label>
                                <input type="range" id="curveSegments" min="4" max="20" value="10" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="curveSegmentsValue" class="text-xs text-gray-600">10</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Points per curve segment (higher = smoother)</p>
                            </div>
                        </div>

                        <div id="bezierSettings" class="hidden space-y-3 pl-3 border-l-2 border-gray-300">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Control Point Distance</label>
                                <input type="range" id="bezierDistance" min="0.1" max="0.8" step="0.1" value="0.3" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="bezierDistanceValue" class="text-xs text-gray-600">0.3</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">How far control points extend (higher = more curved)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Smoothness</label>
                                <input type="range" id="bezierSmoothness" min="0.1" max="1" step="0.1" value="0.5" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="bezierSmoothnessValue" class="text-xs text-gray-600">0.5</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Control point alignment (higher = smoother curves)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Resolution</label>
                                <input type="range" id="bezierResolution" min="8" max="32" value="16" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="bezierResolutionValue" class="text-xs text-gray-600">16</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Points per Bezier curve (higher = smoother but slower)</p>
                            </div>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Opacity</label>
                            <input type="range" id="strokeOpacity" min="0.1" max="1" step="0.1" value="1" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="strokeOpacityValue" class="text-xs text-gray-600">100%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">How transparent or solid the strokes appear</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">
                                <input type="checkbox" id="enableShadow" class="mr-1"> Enable Drop Shadow
                            </label>
                            <p class="text-[10px] text-gray-500 mt-1">Adds a drop shadow effect to strokes</p>
                        </div>

                        <div id="shadowSettings" class="hidden space-y-3 pl-3 border-l-2 border-gray-300">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Offset X</label>
                                <input type="range" id="shadowOffsetX" min="-10" max="10" value="0" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowOffsetXValue" class="text-xs text-gray-600">0px</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Horizontal shadow distance (negative = left)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Offset Y</label>
                                <input type="range" id="shadowOffsetY" min="-10" max="10" value="0" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowOffsetYValue" class="text-xs text-gray-600">0px</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Vertical shadow distance (negative = up)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Blur</label>
                                <input type="range" id="shadowBlur" min="0" max="5" step="0.1" value="1.0" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowBlurValue" class="text-xs text-gray-600">1.0px</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Shadow blur radius (0 = sharp, higher = softer)</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Color</label>
                                <div class="flex items-center space-x-2">
                                    <input type="color" id="shadowColor" value="#000000" class="w-8 h-8 rounded border border-gray-300 cursor-pointer">
                                    <span id="shadowColorValue" class="text-xs text-gray-600">#000000</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">Color of the drop shadow</p>
                            </div>

                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Shadow Opacity</label>
                                <input type="range" id="shadowOpacity" min="0.1" max="1" step="0.1" value="0.4" class="w-full text-sm">
                                <div class="flex justify-between items-center">
                                    <span id="shadowOpacityValue" class="text-xs text-gray-600">40%</span>
                                </div>
                                <p class="text-[10px] text-gray-400 mt-1">How transparent or solid the shadow appears</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Separator -->
                <div class="border-t border-gray-300"></div>

                <!-- Tapering Controls -->
                <div>
                    <h3 class="text-xs font-bold text-gray-700 mb-3 uppercase tracking-wide">Stroke Tapering</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">
                                <input type="checkbox" id="enableTapering" checked class="mr-1"> Enable Tapering
                            </label>
                            <p class="text-[10px] text-gray-500 mt-1">Creates natural pen-like tapered stroke endings</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Start Taper Amount</label>
                            <input type="range" id="startTaper" min="0" max="1" step="0.1" value="0.3" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="startTaperValue" class="text-xs text-gray-600">30%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">How much the stroke thins at the beginning</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">End Taper Amount</label>
                            <input type="range" id="endTaper" min="0" max="1" step="0.1" value="0.5" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="endTaperValue" class="text-xs text-gray-600">50%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">How much the stroke thins at the end (0% = no taper, 100% = sharp point)</p>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-gray-800 mb-1">Taper Start Point</label>
                            <input type="range" id="taperStart" min="50" max="100" step="1" value="97" class="w-full text-sm">
                            <div class="flex justify-between items-center">
                                <span id="taperStartValue" class="text-xs text-gray-600">97%</span>
                            </div>
                            <p class="text-[10px] text-gray-500 mt-1">Where along the stroke the end tapering begins (50% = early, 100% = late)</p>
                        </div>
                    </div>
                </div>

                <!-- Separator -->
                <div class="border-t border-gray-300"></div>

                <!-- System Information -->
                <div>
                    <h3 class="text-xs font-bold text-gray-700 mb-3 uppercase tracking-wide">System Info</h3>
                    <div>
                        <label class="block text-xs font-medium text-gray-800 mb-1">Ink API Status</label>
                        <p id="inkApiStatus" class="text-xs text-gray-600">Checking...</p>
                        <p class="text-[10px] text-gray-500 mt-1">Shows if low-latency stylus rendering is available in your browser</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Area -->
    <svg id="drawingArea" class="w-screen h-screen" xmlns="http://www.w3.org/2000/svg"></svg>



    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        class DrawingApp {
            constructor() {
                this.svg = document.getElementById('drawingArea');
                this.isDrawing = false;
                this.currentPath = null;
                this.currentPoints = [];
                this.strokeWidth = 3;
                this.strokeColor = '#212121';
                this.previewColor = '#212121';
                this.smoothingMethod = 'chaikin';
                this.smoothingIterations = 2;
                this.smoothingFactor = 0.25;
                this.splineTension = 0.5;
                this.curveSegments = 10;
                this.bezierDistance = 0.3;
                this.bezierSmoothness = 0.5;
                this.bezierResolution = 16;
                this.strokeOpacity = 1;
                this.enableShadow = false;
                this.shadowOffsetX = 0;
                this.shadowOffsetY = 0;
                this.shadowBlur = 1.0;
                this.shadowColor = '#000000';
                this.shadowOpacity = 0.4;
                this.enableTapering = true;
                this.startTaper = 0.3; // How much the start tapers (0-1)
                this.endTaper = 0.5; // How much the end tapers (0-1)  
                this.taperStart = 0.97; // Where tapering begins (0-1)
                this.presenter = null;
                
                // Performance optimizations
                this.animationFrame = null;
                this.needsUpdate = false;
                this.pointBuffer = []; // Reuse point arrays
                
                // Cache DOM elements for better performance
                this.cachedElements = {};
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupMenu();
                this.initInkAPI();
            }

            setupCanvas() {
                this.resizeCanvas();
                this.setupShadowFilter();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            setupShadowFilter() {
                // Create SVG defs section for filters
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                this.svg.appendChild(defs);
                
                // Create drop shadow filter
                this.shadowFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                this.shadowFilter.setAttribute('id', 'dropShadow');
                this.shadowFilter.setAttribute('x', '-50%');
                this.shadowFilter.setAttribute('y', '-50%');
                this.shadowFilter.setAttribute('width', '200%');
                this.shadowFilter.setAttribute('height', '200%');
                
                // Create flood element for shadow color
                this.shadowFlood = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
                this.shadowFlood.setAttribute('result', 'flood');
                
                // Create composite element
                const composite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
                composite.setAttribute('in', 'flood');
                composite.setAttribute('in2', 'SourceGraphic');
                composite.setAttribute('operator', 'in');
                composite.setAttribute('result', 'composite');
                
                // Create gaussian blur element
                this.shadowBlurFilter = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                this.shadowBlurFilter.setAttribute('in', 'composite');
                this.shadowBlurFilter.setAttribute('result', 'blur');
                
                // Create offset element
                this.shadowOffsetFilter = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
                this.shadowOffsetFilter.setAttribute('in', 'blur');
                this.shadowOffsetFilter.setAttribute('result', 'offset');
                
                // Create merge element
                const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                
                const mergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode1.setAttribute('in', 'offset');
                
                const mergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                mergeNode2.setAttribute('in', 'SourceGraphic');
                
                merge.appendChild(mergeNode1);
                merge.appendChild(mergeNode2);
                
                // Add all elements to filter
                this.shadowFilter.appendChild(this.shadowFlood);
                this.shadowFilter.appendChild(composite);
                this.shadowFilter.appendChild(this.shadowBlurFilter);
                this.shadowFilter.appendChild(this.shadowOffsetFilter);
                this.shadowFilter.appendChild(merge);
                
                defs.appendChild(this.shadowFilter);
                
                this.updateShadowFilter();
            }

            updateShadowFilter() {
                if (!this.shadowFilter) return;
                
                // Convert shadow color to rgba with opacity
                const rgb = this.hexToRgb(this.shadowColor);
                const shadowColorRgba = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${this.shadowOpacity})`;
                
                this.shadowFlood.setAttribute('flood-color', this.shadowColor);
                this.shadowFlood.setAttribute('flood-opacity', this.shadowOpacity);
                this.shadowBlurFilter.setAttribute('stdDeviation', this.shadowBlur);
                this.shadowOffsetFilter.setAttribute('dx', this.shadowOffsetX);
                this.shadowOffsetFilter.setAttribute('dy', this.shadowOffsetY);
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            resizeCanvas() {
                this.svg.setAttribute('width', window.innerWidth);
                this.svg.setAttribute('height', window.innerHeight);
                this.svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
            }

            async initInkAPI() {
                try {
                    if ('ink' in navigator) {
                        // Create a canvas for ink API
                        const canvas = document.createElement('canvas');
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        canvas.style.position = 'absolute';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        canvas.style.pointerEvents = 'none';
                        canvas.style.zIndex = '5';
                        document.body.appendChild(canvas);
                        
                        this.presenter = await navigator.ink.requestPresenter({ 
                            presentationArea: canvas 
                        });
                        document.getElementById('inkApiStatus').textContent = '✅ Available';
                        console.log('Ink API initialized');
                    } else {
                        throw new Error('Not supported');
                    }
                } catch (error) {
                    document.getElementById('inkApiStatus').textContent = '❌ Not Available';
                    console.log('Ink API not available');
                }
            }

            setupEventListeners() {
                // Only stylus/pen input allowed
                this.svg.addEventListener('pointerdown', (e) => {
                    if (e.pointerType === 'pen') {
                        e.preventDefault();
                        this.startDrawing(e);
                    }
                });

                this.svg.addEventListener('pointermove', (e) => {
                    if (e.pointerType === 'pen' && this.isDrawing) {
                        e.preventDefault();
                        this.continueDrawing(e);
                    }
                });

                this.svg.addEventListener('pointerup', (e) => {
                    if (e.pointerType === 'pen') {
                        e.preventDefault();
                        this.stopDrawing(e);
                    }
                });

                this.svg.addEventListener('pointercancel', (e) => {
                    if (e.pointerType === 'pen' && this.isDrawing) {
                        this.stopDrawing(e);
                    }
                });

                // Prevent all touch and mouse interactions
                this.svg.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                });

                this.svg.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                });

                // Clear button
                document.getElementById('clearButton').addEventListener('click', () => {
                    this.clearCanvas();
                });

                // Prevent context menu
                this.svg.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            startDrawing(e) {
                this.isDrawing = true;
                this.currentPoints = [];
                
                const point = this.getPoint(e);
                this.currentPoints.push({ ...point, timestamp: Date.now() });
                
                // Create new path element for tapered stroke
                this.currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.currentPath.setAttribute('fill', this.strokeColor);
                this.currentPath.setAttribute('fill-opacity', this.strokeOpacity);
                this.currentPath.setAttribute('stroke', 'none');
                
                // Apply shadow filter if enabled
                if (this.enableShadow) {
                    this.updateShadowFilter();
                    this.currentPath.setAttribute('filter', 'url(#dropShadow)');
                }
                
                this.svg.appendChild(this.currentPath);
                
                // Update Ink API
                if (this.presenter && e.pointerId !== undefined) {
                    try {
                        this.presenter.updateInkTrailStartPoint(e, {
                            color: this.previewColor,
                            diameter: this.strokeWidth
                        });
                    } catch (error) {
                        console.log('Ink API error:', error);
                    }
                }
            }

            continueDrawing(e) {
                if (!this.isDrawing || !this.currentPath) return;
                
                const point = this.getPoint(e);
                this.currentPoints.push({ ...point, timestamp: Date.now() });
                
                // Throttle updates using requestAnimationFrame for better performance
                if (!this.needsUpdate) {
                    this.needsUpdate = true;
                    this.animationFrame = requestAnimationFrame(() => {
                        this.updateTaperedPath();
                        this.needsUpdate = false;
                    });
                }
                
                // Update Ink API
                if (this.presenter && e.pointerId !== undefined) {
                    try {
                        this.presenter.updateInkTrailStartPoint(e, {
                            color: this.previewColor,
                            diameter: this.strokeWidth
                        });
                    } catch (error) {
                        console.log('Ink API error:', error);
                    }
                }
            }

            stopDrawing(e) {
                this.isDrawing = false;
                
                // Final update with taper at the end
                if (this.currentPath && this.currentPoints.length > 1) {
                    this.updateTaperedPath(true);
                }
                
                this.currentPath = null;
                this.currentPoints = [];
            }

            getPoint(e) {
                const rect = this.svg.getBoundingClientRect();
                return {
                    x: (e.clientX || e.pageX) - rect.left,
                    y: (e.clientY || e.pageY) - rect.top
                };
            }

            clearCanvas() {
                // Remove all paths
                const paths = this.svg.querySelectorAll('path');
                paths.forEach(path => path.remove());
            }



            setupMenu() {
                const menuButton = document.getElementById('menuButton');
                const menuOverlay = document.getElementById('menuOverlay');
                const menuPanel = document.getElementById('menuPanel');
                const copySettings = document.getElementById('copySettings');

                menuButton.addEventListener('click', () => {
                    menuOverlay.classList.remove('hidden');
                    menuButton.style.display = 'none'; // Hide menu button
                    setTimeout(() => {
                        menuPanel.style.transform = 'translateX(0)';
                    }, 10);
                });

                const closeMenuFunc = () => {
                    menuPanel.style.transform = 'translateX(-100%)';
                    setTimeout(() => {
                        menuOverlay.classList.add('hidden');
                        menuButton.style.display = 'block'; // Show menu button again
                    }, 300);
                };

                // Copy settings functionality
                copySettings.addEventListener('click', () => {
                    this.copyAllSettings();
                });

                menuOverlay.addEventListener('click', (e) => {
                    if (e.target === menuOverlay) {
                        closeMenuFunc();
                    }
                });

                // Stroke width control
                const strokeWidth = document.getElementById('strokeWidth');
                const strokeWidthValue = document.getElementById('strokeWidthValue');
                strokeWidth.addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    strokeWidthValue.textContent = `${this.strokeWidth}px`;
                });

                // Stroke color control
                const strokeColor = document.getElementById('strokeColor');
                const strokeColorValue = document.getElementById('strokeColorValue');
                strokeColor.addEventListener('input', (e) => {
                    this.strokeColor = e.target.value;
                    strokeColorValue.textContent = this.strokeColor.toUpperCase();
                });

                // Preview ink color control
                const previewColor = document.getElementById('previewColor');
                const previewColorValue = document.getElementById('previewColorValue');
                previewColor.addEventListener('input', (e) => {
                    this.previewColor = e.target.value;
                    previewColorValue.textContent = this.previewColor.toUpperCase();
                });

                // Smoothing method control
                const smoothingMethod = document.getElementById('smoothingMethod');
                const chaikinSettings = document.getElementById('chaikinSettings');
                const catmullromSettings = document.getElementById('catmullromSettings');
                const bezierSettings = document.getElementById('bezierSettings');
                smoothingMethod.addEventListener('change', (e) => {
                    this.smoothingMethod = e.target.value;
                    // Show/hide settings based on selection
                    if (e.target.value === 'chaikin') {
                        chaikinSettings.classList.remove('hidden');
                        catmullromSettings.classList.add('hidden');
                        bezierSettings.classList.add('hidden');
                    } else if (e.target.value === 'catmullrom') {
                        chaikinSettings.classList.add('hidden');
                        catmullromSettings.classList.remove('hidden');
                        bezierSettings.classList.add('hidden');
                    } else if (e.target.value === 'bezier') {
                        chaikinSettings.classList.add('hidden');
                        catmullromSettings.classList.add('hidden');
                        bezierSettings.classList.remove('hidden');
                    } else {
                        chaikinSettings.classList.add('hidden');
                        catmullromSettings.classList.add('hidden');
                        bezierSettings.classList.add('hidden');
                    }
                });

                // Chaikin smoothing controls
                const smoothingIterations = document.getElementById('smoothingIterations');
                const smoothingIterationsValue = document.getElementById('smoothingIterationsValue');
                smoothingIterations.addEventListener('input', (e) => {
                    this.smoothingIterations = parseInt(e.target.value);
                    smoothingIterationsValue.textContent = this.smoothingIterations;
                });

                const smoothingFactor = document.getElementById('smoothingFactor');
                const smoothingFactorValue = document.getElementById('smoothingFactorValue');
                smoothingFactor.addEventListener('input', (e) => {
                    this.smoothingFactor = parseFloat(e.target.value);
                    smoothingFactorValue.textContent = this.smoothingFactor;
                });

                // Catmull-Rom spline controls
                const splineTension = document.getElementById('splineTension');
                const splineTensionValue = document.getElementById('splineTensionValue');
                splineTension.addEventListener('input', (e) => {
                    this.splineTension = parseFloat(e.target.value);
                    splineTensionValue.textContent = this.splineTension;
                });

                const curveSegments = document.getElementById('curveSegments');
                const curveSegmentsValue = document.getElementById('curveSegmentsValue');
                curveSegments.addEventListener('input', (e) => {
                    this.curveSegments = parseInt(e.target.value);
                    curveSegmentsValue.textContent = this.curveSegments;
                });

                // Bezier smoothing controls
                const bezierDistance = document.getElementById('bezierDistance');
                const bezierDistanceValue = document.getElementById('bezierDistanceValue');
                bezierDistance.addEventListener('input', (e) => {
                    this.bezierDistance = parseFloat(e.target.value);
                    bezierDistanceValue.textContent = this.bezierDistance;
                });

                const bezierSmoothness = document.getElementById('bezierSmoothness');
                const bezierSmoothnessValue = document.getElementById('bezierSmoothnessValue');
                bezierSmoothness.addEventListener('input', (e) => {
                    this.bezierSmoothness = parseFloat(e.target.value);
                    bezierSmoothnessValue.textContent = this.bezierSmoothness;
                });

                const bezierResolution = document.getElementById('bezierResolution');
                const bezierResolutionValue = document.getElementById('bezierResolutionValue');
                bezierResolution.addEventListener('input', (e) => {
                    this.bezierResolution = parseInt(e.target.value);
                    bezierResolutionValue.textContent = this.bezierResolution;
                });

                // Opacity control
                const strokeOpacity = document.getElementById('strokeOpacity');
                const strokeOpacityValue = document.getElementById('strokeOpacityValue');
                strokeOpacity.addEventListener('input', (e) => {
                    this.strokeOpacity = parseFloat(e.target.value);
                    strokeOpacityValue.textContent = `${Math.round(this.strokeOpacity * 100)}%`;
                });

                // Shadow controls
                const enableShadow = document.getElementById('enableShadow');
                const shadowSettings = document.getElementById('shadowSettings');
                enableShadow.addEventListener('change', (e) => {
                    this.enableShadow = e.target.checked;
                    if (e.target.checked) {
                        shadowSettings.classList.remove('hidden');
                    } else {
                        shadowSettings.classList.add('hidden');
                    }
                });

                const shadowOffsetX = document.getElementById('shadowOffsetX');
                const shadowOffsetXValue = document.getElementById('shadowOffsetXValue');
                shadowOffsetX.addEventListener('input', (e) => {
                    this.shadowOffsetX = parseInt(e.target.value);
                    shadowOffsetXValue.textContent = `${this.shadowOffsetX}px`;
                });

                const shadowOffsetY = document.getElementById('shadowOffsetY');
                const shadowOffsetYValue = document.getElementById('shadowOffsetYValue');
                shadowOffsetY.addEventListener('input', (e) => {
                    this.shadowOffsetY = parseInt(e.target.value);
                    shadowOffsetYValue.textContent = `${this.shadowOffsetY}px`;
                });

                const shadowBlur = document.getElementById('shadowBlur');
                const shadowBlurValue = document.getElementById('shadowBlurValue');
                shadowBlur.addEventListener('input', (e) => {
                    this.shadowBlur = parseFloat(e.target.value);
                    shadowBlurValue.textContent = `${this.shadowBlur}px`;
                });

                const shadowColor = document.getElementById('shadowColor');
                const shadowColorValue = document.getElementById('shadowColorValue');
                shadowColor.addEventListener('input', (e) => {
                    this.shadowColor = e.target.value;
                    shadowColorValue.textContent = this.shadowColor.toUpperCase();
                });

                const shadowOpacity = document.getElementById('shadowOpacity');
                const shadowOpacityValue = document.getElementById('shadowOpacityValue');
                shadowOpacity.addEventListener('input', (e) => {
                    this.shadowOpacity = parseFloat(e.target.value);
                    shadowOpacityValue.textContent = `${Math.round(this.shadowOpacity * 100)}%`;
                });

                // Tapering controls
                const enableTapering = document.getElementById('enableTapering');
                enableTapering.addEventListener('change', (e) => {
                    this.enableTapering = e.target.checked;
                });

                const startTaper = document.getElementById('startTaper');
                const startTaperValue = document.getElementById('startTaperValue');
                startTaper.addEventListener('input', (e) => {
                    this.startTaper = parseFloat(e.target.value);
                    startTaperValue.textContent = `${Math.round(this.startTaper * 100)}%`;
                });

                const endTaper = document.getElementById('endTaper');
                const endTaperValue = document.getElementById('endTaperValue');
                endTaper.addEventListener('input', (e) => {
                    this.endTaper = parseFloat(e.target.value);
                    endTaperValue.textContent = `${Math.round(this.endTaper * 100)}%`;
                });

                const taperStart = document.getElementById('taperStart');
                const taperStartValue = document.getElementById('taperStartValue');
                taperStart.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.taperStart = value / 100; // Convert from 50-100 range to 0.5-1.0 range
                    taperStartValue.textContent = `${value}%`;
                });

            }

            updateTaperedPath(isEnding = false) {
                if (this.currentPoints.length < 2) return;

                const points = this.currentPoints;
                const path = [];
                
                // Start the path
                path.push(`M ${points[0].x} ${points[0].y}`);
                
                if (points.length === 2) {
                    // Simple line for two points
                    const startWidth = this.strokeWidth * 0.8;
                    const endWidth = isEnding ? this.strokeWidth * 0.2 : this.strokeWidth;
                    
                    const dx = points[1].x - points[0].x;
                    const dy = points[1].y - points[0].y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if (length > 0) {
                        const perpX = -dy / length;
                        const perpY = dx / length;
                        
                        // Create tapered stroke as filled path
                        const x1 = points[0].x + perpX * startWidth / 2;
                        const y1 = points[0].y + perpY * startWidth / 2;
                        const x2 = points[0].x - perpX * startWidth / 2;
                        const y2 = points[0].y - perpY * startWidth / 2;
                        const x3 = points[1].x - perpX * endWidth / 2;
                        const y3 = points[1].y - perpY * endWidth / 2;
                        const x4 = points[1].x + perpX * endWidth / 2;
                        const y4 = points[1].y + perpY * endWidth / 2;
                        
                        const pathData = `M ${x1} ${y1} L ${x4} ${y4} L ${x3} ${y3} L ${x2} ${y2} Z`;
                        this.currentPath.setAttribute('d', pathData);
                    }
                } else {
                    // Create smooth tapered path for multiple points
                    const pathData = this.createTaperedStrokePath(points, isEnding);
                    this.currentPath.setAttribute('d', pathData);
                }
            }

            applyChaikinSmoothing(points, iterations = 2) {
                if (points.length < 3) return points;
                
                let smoothedPoints = [...points];
                
                for (let iter = 0; iter < iterations; iter++) {
                    if (smoothedPoints.length < 3) break;
                    
                    const newPoints = [];
                    
                    // Keep the first point
                    newPoints.push(smoothedPoints[0]);
                    
                    // Apply Chaikin's corner cutting algorithm
                    for (let i = 0; i < smoothedPoints.length - 1; i++) {
                        const p1 = smoothedPoints[i];
                        const p2 = smoothedPoints[i + 1];
                        
                        // Create quarter points using configurable smoothing factor
                        const q1 = {
                            x: p1.x + (1 - this.smoothingFactor) * (p2.x - p1.x),
                            y: p1.y + (1 - this.smoothingFactor) * (p2.y - p1.y)
                        };
                        
                        const q2 = {
                            x: p1.x + this.smoothingFactor * (p2.x - p1.x),
                            y: p1.y + this.smoothingFactor * (p2.y - p1.y)
                        };
                        
                        newPoints.push(q2, q1);
                    }
                    
                    // Keep the last point
                    newPoints.push(smoothedPoints[smoothedPoints.length - 1]);
                    
                    smoothedPoints = newPoints;
                }
                
                return smoothedPoints;
            }

            applyCatmullRomSmoothing(points) {
                if (points.length < 4) return points;
                
                const smoothedPoints = [];
                const tension = this.splineTension;
                const segments = this.curveSegments;
                
                // Add the first point
                smoothedPoints.push(points[0]);
                
                // Process each curve segment
                for (let i = 0; i < points.length - 1; i++) {
                    // Get the four control points for the spline
                    const p0 = i === 0 ? points[0] : points[i - 1];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = i === points.length - 2 ? points[points.length - 1] : points[i + 2];
                    
                    // Generate interpolated points along the curve
                    for (let t = 0; t < 1; t += 1 / segments) {
                        if (t === 0 && i > 0) continue; // Skip duplicate points
                        
                        const tt = t * t;
                        const ttt = tt * t;
                        
                        // Catmull-Rom basis functions
                        const q0 = -tension * ttt + 2 * tension * tt - tension * t;
                        const q1 = (2 - tension) * ttt + (tension - 3) * tt + 1;
                        const q2 = (tension - 2) * ttt + (3 - 2 * tension) * tt + tension * t;
                        const q3 = tension * ttt - tension * tt;
                        
                        const x = p0.x * q0 + p1.x * q1 + p2.x * q2 + p3.x * q3;
                        const y = p0.y * q0 + p1.y * q1 + p2.y * q2 + p3.y * q3;
                        
                        smoothedPoints.push({ x, y });
                    }
                }
                
                // Add the last point
                smoothedPoints.push(points[points.length - 1]);
                
                return smoothedPoints;
            }

            applyBezierSmoothing(points) {
                if (points.length < 3) return points;
                
                const smoothedPoints = [];
                const distance = this.bezierDistance;
                const smoothness = this.bezierSmoothness;
                const resolution = this.bezierResolution;
                
                // Add the first point
                smoothedPoints.push(points[0]);
                
                // Process each segment
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = points[i];
                    const p1 = points[i + 1];
                    
                    // Calculate segment length for control point scaling
                    const segmentLength = Math.sqrt((p1.x - p0.x) ** 2 + (p1.y - p0.y) ** 2);
                    if (segmentLength < 1) continue; // Skip very short segments
                    
                    // Calculate control points with improved stability
                    let cp1, cp2;
                    
                    // Get tangent directions at each point
                    let tangent1X, tangent1Y, tangent2X, tangent2Y;
                    
                    if (i === 0) {
                        // First point: use direction to next point
                        tangent1X = p1.x - p0.x;
                        tangent1Y = p1.y - p0.y;
                    } else {
                        // Calculate smooth tangent based on previous and next points
                        const prevPoint = points[i - 1];
                        const dx1 = p0.x - prevPoint.x;
                        const dy1 = p0.y - prevPoint.y;
                        const dx2 = p1.x - p0.x;
                        const dy2 = p1.y - p0.y;
                        
                        // Blend the directions with smoothness factor
                        tangent1X = dx2 * (1 - smoothness) + dx1 * smoothness;
                        tangent1Y = dy2 * (1 - smoothness) + dy1 * smoothness;
                    }
                    
                    if (i === points.length - 2) {
                        // Last point: use direction from previous point
                        tangent2X = p1.x - p0.x;
                        tangent2Y = p1.y - p0.y;
                    } else {
                        // Calculate smooth tangent based on current and next points
                        const nextPoint = points[i + 2];
                        const dx1 = p1.x - p0.x;
                        const dy1 = p1.y - p0.y;
                        const dx2 = nextPoint.x - p1.x;
                        const dy2 = nextPoint.y - p1.y;
                        
                        // Blend the directions with smoothness factor
                        tangent2X = dx1 * (1 - smoothness) + dx2 * smoothness;
                        tangent2Y = dy1 * (1 - smoothness) + dy2 * smoothness;
                    }
                    
                    // Normalize tangents
                    const len1 = Math.sqrt(tangent1X * tangent1X + tangent1Y * tangent1Y);
                    const len2 = Math.sqrt(tangent2X * tangent2X + tangent2Y * tangent2Y);
                    
                    if (len1 > 0) {
                        tangent1X /= len1;
                        tangent1Y /= len1;
                    }
                    if (len2 > 0) {
                        tangent2X /= len2;
                        tangent2Y /= len2;
                    }
                    
                    // Calculate control points with limited extension
                    const controlDistance = segmentLength * distance * 0.5; // Limit control point distance
                    
                    cp1 = {
                        x: p0.x + tangent1X * controlDistance,
                        y: p0.y + tangent1Y * controlDistance
                    };
                    
                    cp2 = {
                        x: p1.x - tangent2X * controlDistance,
                        y: p1.y - tangent2Y * controlDistance
                    };
                    
                    // Generate Bezier curve points
                    for (let t = 0; t < 1; t += 1 / resolution) {
                        if (t === 0 && i > 0) continue; // Skip duplicate points
                        
                        const mt = 1 - t;
                        const mt2 = mt * mt;
                        const mt3 = mt2 * mt;
                        const t2 = t * t;
                        const t3 = t2 * t;
                        
                        const x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p1.x;
                        const y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p1.y;
                        
                        smoothedPoints.push({ x, y });
                    }
                }
                
                // Add the last point
                smoothedPoints.push(points[points.length - 1]);
                
                return smoothedPoints;
            }

            createTaperedStrokePath(points, isEnding = false) {
                if (points.length < 2) return '';

                // Apply smoothing if selected
                let processedPoints = points;
                if (this.smoothingMethod === 'chaikin') {
                    processedPoints = this.applyChaikinSmoothing(points, this.smoothingIterations);
                } else if (this.smoothingMethod === 'catmullrom') {
                    processedPoints = this.applyCatmullRomSmoothing(points);
                } else if (this.smoothingMethod === 'bezier') {
                    processedPoints = this.applyBezierSmoothing(points);
                }

                const leftPoints = [];
                const rightPoints = [];
                
                for (let i = 0; i < processedPoints.length; i++) {
                    const point = processedPoints[i];
                    const progress = i / (processedPoints.length - 1);
                    
                    // Calculate width with configurable tapering
                    let width = this.strokeWidth;
                    
                    if (this.enableTapering) {
                        if (isEnding && progress > this.taperStart) {
                            // Taper the end based on user settings
                            const taperProgress = (progress - this.taperStart) / (1 - this.taperStart);
                            width = this.strokeWidth * (1 - taperProgress * this.endTaper);
                        } else if (progress < 0.2) {
                            // Soft start with configurable amount
                            const startTaperAmount = this.startTaper;
                            width = this.strokeWidth * ((1 - startTaperAmount) + progress * startTaperAmount * 5);
                        }
                    }
                    
                    // Calculate perpendicular direction for width
                    let perpX = 0, perpY = 0;
                    
                    if (i === 0 && processedPoints.length > 1) {
                        const dx = processedPoints[1].x - processedPoints[0].x;
                        const dy = processedPoints[1].y - processedPoints[0].y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            perpX = -dy / length;
                            perpY = dx / length;
                        }
                    } else if (i === processedPoints.length - 1) {
                        const dx = processedPoints[i].x - processedPoints[i - 1].x;
                        const dy = processedPoints[i].y - processedPoints[i - 1].y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            perpX = -dy / length;
                            perpY = dx / length;
                        }
                    } else {
                        // Average of adjacent segments
                        const dx1 = processedPoints[i].x - processedPoints[i - 1].x;
                        const dy1 = processedPoints[i].y - processedPoints[i - 1].y;
                        const dx2 = processedPoints[i + 1].x - processedPoints[i].x;
                        const dy2 = processedPoints[i + 1].y - processedPoints[i].y;
                        
                        const avgDx = (dx1 + dx2) / 2;
                        const avgDy = (dy1 + dy2) / 2;
                        const length = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
                        
                        if (length > 0) {
                            perpX = -avgDy / length;
                            perpY = avgDx / length;
                        }
                    }
                    
                    leftPoints.push({
                        x: point.x + perpX * width / 2,
                        y: point.y + perpY * width / 2
                    });
                    
                    rightPoints.push({
                        x: point.x - perpX * width / 2,
                        y: point.y - perpY * width / 2
                    });
                }
                
                // Create the path
                let pathData = `M ${leftPoints[0].x} ${leftPoints[0].y}`;
                
                // Draw left side
                for (let i = 1; i < leftPoints.length; i++) {
                    pathData += ` L ${leftPoints[i].x} ${leftPoints[i].y}`;
                }
                
                // Draw right side (reversed)
                for (let i = rightPoints.length - 1; i >= 0; i--) {
                    pathData += ` L ${rightPoints[i].x} ${rightPoints[i].y}`;
                }
                
                pathData += ' Z';
                return pathData;
            }

            copyAllSettings() {
                // Read ALL settings from the UI regardless of visibility/state
                const strokeWidth = document.getElementById('strokeWidth').value;
                const strokeColor = document.getElementById('strokeColor').value;
                const previewColor = document.getElementById('previewColor').value;
                const smoothingMethod = document.getElementById('smoothingMethod').value;
                const strokeOpacity = document.getElementById('strokeOpacity').value;
                const enableShadow = document.getElementById('enableShadow').checked;
                const enableTapering = document.getElementById('enableTapering').checked;

                // Get smoothing method display name
                const smoothingOptions = {
                    'none': 'Direct (No Smoothing)',
                    'chaikin': 'Chaikin Smoothing',
                    'catmullrom': 'Catmull-Rom Splines',
                    'bezier': 'Bezier Smoothing'
                };

                // Read ALL smoothing algorithm settings (regardless of which is active)
                const chaikinIterations = document.getElementById('smoothingIterations').value;
                const chaikinFactor = document.getElementById('smoothingFactor').value;
                const catmullTension = document.getElementById('splineTension').value;
                const catmullSegments = document.getElementById('curveSegments').value;
                const bezierDistance = document.getElementById('bezierDistance').value;
                const bezierSmoothness = document.getElementById('bezierSmoothness').value;
                const bezierResolution = document.getElementById('bezierResolution').value;

                // Read ALL shadow settings (regardless of enabled state)
                const shadowOffsetX = document.getElementById('shadowOffsetX').value;
                const shadowOffsetY = document.getElementById('shadowOffsetY').value;
                const shadowBlur = document.getElementById('shadowBlur').value;
                const shadowColor = document.getElementById('shadowColor').value;
                const shadowOpacity = document.getElementById('shadowOpacity').value;

                // Read ALL tapering settings (regardless of enabled state)
                const startTaper = document.getElementById('startTaper').value;
                const endTaper = document.getElementById('endTaper').value;
                const taperStart = document.getElementById('taperStart').value;

                // Build complete settings text with ALL parameters
                let settingsText = `Drawing App Settings:
═══════════════════════

📐 STROKE PROPERTIES:
• Stroke Width: ${strokeWidth}px
• Stroke Color: ${strokeColor.toUpperCase()}
• Preview Ink Color: ${previewColor.toUpperCase()}
• Smoothing Method: ${smoothingOptions[smoothingMethod] || smoothingMethod}
• Opacity: ${Math.round(strokeOpacity * 100)}%
• Drop Shadow: ${enableShadow ? 'Enabled' : 'Disabled'}

🎛️ SMOOTHING ALGORITHMS:
• Chaikin Smoothing:
  ↳ Smoothing Iterations: ${chaikinIterations}
  ↳ Smoothing Factor: ${chaikinFactor}
• Catmull-Rom Splines:
  ↳ Tension: ${catmullTension}
  ↳ Curve Segments: ${catmullSegments}
• Bezier Smoothing:
  ↳ Control Point Distance: ${bezierDistance}
  ↳ Smoothness: ${bezierSmoothness}
  ↳ Resolution: ${bezierResolution}

🌫️ DROP SHADOW SETTINGS:
• Shadow Offset X: ${shadowOffsetX}px
• Shadow Offset Y: ${shadowOffsetY}px
• Shadow Blur: ${shadowBlur}px
• Shadow Color: ${shadowColor.toUpperCase()}
• Shadow Opacity: ${Math.round(shadowOpacity * 100)}%

🎨 STROKE TAPERING:
• Enable Tapering: ${enableTapering ? 'Yes' : 'No'}
• Start Taper Amount: ${Math.round(startTaper * 100)}%
• End Taper Amount: ${Math.round(endTaper * 100)}%
• Taper Start Point: ${taperStart}%

═══════════════════════
Complete settings snapshot for establishing defaults`;

                // Copy to clipboard
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(settingsText).then(() => {
                        // Show brief feedback
                        const button = document.getElementById('copySettings');
                        const originalTitle = button.title;
                        button.title = 'Copied!';
                        button.style.color = '#10b981'; // Green color
                        
                        setTimeout(() => {
                            button.title = originalTitle;
                            button.style.color = '';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy settings:', err);
                        this.fallbackCopy(settingsText);
                    });
                } else {
                    this.fallbackCopy(settingsText);
                }
            }

            fallbackCopy(text) {
                // Fallback method for browsers without clipboard API
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    // Show feedback
                    const button = document.getElementById('copySettings');
                    button.title = 'Copied!';
                    button.style.color = '#10b981';
                    setTimeout(() => {
                        button.title = 'Copy all settings';
                        button.style.color = '';
                    }, 2000);
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                }
                
                document.body.removeChild(textArea);
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            new DrawingApp();
        });
    </script>
</body>
</html>
