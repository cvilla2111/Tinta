<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing App - Hybrid Worker</title>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Monaco, Inconsolata, "Roboto Mono", monospace;
            background: #ffffff;
            color: #000000;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 3rem;
            background: white;
            border-bottom: 1px solid #d1d5db;
            z-index: 20;
            display: flex;
            align-items: center;
            padding: 0 1rem;
        }

        .header-title {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Worker notification */
        .worker-notification {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #0c4a6e;
            margin-right: 0.75rem;
            transition: opacity 0.3s ease;
        }

        .worker-indicator {
            width: 0.5rem;
            height: 0.5rem;
            background: #0ea5e9;
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .worker-text {
            font-weight: 500;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        /* Hamburger menu */
        .hamburger {
            padding: 0.5rem;
            margin-right: 0.75rem;
            background: none;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }

        .hamburger:hover {
            background: #f3f4f6;
        }

        .hamburger.open {
            transform: rotate(90deg);
        }

        .hamburger-line {
            width: 1.25rem;
            height: 0.125rem;
            background: black;
            margin-bottom: 0.25rem;
        }

        .hamburger-line:last-child {
            margin-bottom: 0;
        }

        /* Side menu */
        .side-menu {
            position: fixed;
            left: 0;
            top: 3rem;
            bottom: 0;
            width: 16rem;
            background: white;
            border-right: 1px solid #d1d5db;
            z-index: 10;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform 0.2s ease;
            will-change: transform;
        }

        .side-menu.open {
            transform: translateX(0);
        }

        .menu-content {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-section h3 {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .section-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Tool buttons */
        .tool-btn {
            width: 100%;
            text-align: left;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.25rem;
            border: 1px solid #e5e7eb;
            background: white;
            cursor: pointer;
            transition: background-color 0.1s ease;
        }

        .tool-btn:hover {
            background-color: #f5f5f5;
        }

        .tool-btn.active {
            background-color: #e5e5e5;
        }

        /* Range input */
        .range-container {
            display: flex;
            flex-direction: column;
        }

        .range-input {
            width: 100%;
            height: 0.25rem;
            background: #d1d5db;
            border-radius: 0.5rem;
            appearance: none;
            cursor: pointer;
            outline: none;
        }

        .range-input::-webkit-slider-thumb {
            appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        .range-input::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }

        .range-value {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        /* Status indicators */
        .status-text {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .input-details {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-indicator {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background: #9ca3af;
        }

        .input-info {
            font-size: 0.75rem;
            color: #6b7280;
            font-family: ui-monospace, monospace;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .device-type {
            color: #6b7280;
        }

        .button-state {
            color: #9ca3af;
        }

        /* Canvas area */
        .canvas-container {
            position: fixed;
            top: 3rem;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #drawingCanvas {
            border: 1px solid #e5e7eb;
            cursor: crosshair;
            touch-action: none;
        }

        /* Lightweight eraser indicator */
        .eraser-indicator {
            position: fixed;
            border: 1px solid #ef4444;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.1);
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.1s ease;
            transform: translate(-50%, -50%);
        }

        .eraser-indicator.visible {
            opacity: 1;
        }

        /* Filter status */
        .filter-status {
            font-size: 0.75rem;
            color: #6b7280;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Color variants for indicators */
        .bg-red-500 { background: #ef4444; }
        .bg-blue-500 { background: #3b82f6; }
        .bg-green-500 { background: #10b981; }
        .bg-orange-500 { background: #f59e0b; }
        .bg-gray-400 { background: #9ca3af; }

        .hidden {
            display: none;
        }

        /* DPR Info */
        .dpr-info {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.5rem;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .side-menu {
                width: 20rem;
            }
            
            .header {
                padding: 0 0.5rem;
            }
            
            .header-title {
                font-size: 0.75rem;
            }
            
            .input-info {
                display: none;
            }
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body>
    <!-- Header -->
    <div class="header">
        <button id="menuToggle" class="hamburger">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </button>
        <span class="header-title">Drawing App - Hybrid Worker</span>
        <div class="header-right">
            <div id="workerNotification" class="worker-notification hidden">
                <div class="worker-indicator"></div>
                <span class="worker-text">Worker Active</span>
            </div>
            <span id="statusText" class="status-text">Ready</span>
            <div id="inputDetails" class="input-details">
                <div id="inputIndicator" class="input-indicator bg-gray-400"></div>
                <div id="inputInfo" class="input-info">
                    <div id="deviceType" class="device-type">-</div>
                    <div id="buttonState" class="button-state">-</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="sideMenu" class="side-menu">
        <div class="menu-content">
            <!-- Tools -->
            <div class="menu-section">
                <h3>Tools</h3>
                <div class="section-content">
                    <button id="penTool" class="tool-btn active">Pen</button>
                    <button id="eraserTool" class="tool-btn">Eraser</button>
                </div>
            </div>

            <!-- Stroke Width -->
            <div class="menu-section">
                <h3>Stroke Width</h3>
                <div class="range-container">
                    <input type="range" id="strokeWidth" min="1" max="20" value="2" class="range-input">
                    <div class="range-value">
                        <span id="strokeWidthValue">2</span>px
                    </div>
                </div>
            </div>

            <!-- Eraser Size (only shown when eraser is selected) -->
            <div id="eraserSizeSection" class="menu-section hidden">
                <h3>Eraser Size</h3>
                <div class="range-container">
                    <input type="range" id="eraserSize" min="5" max="50" value="10" class="range-input">
                    <div class="range-value">
                        <span id="eraserSizeValue">10</span>px
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="menu-section">
                <h3>Actions</h3>
                <div class="section-content">
                    <button id="clearBtn" class="tool-btn">Clear All</button>
                    <button id="undoBtn" class="tool-btn">Undo</button>
                    <button id="testWorkerBtn" class="tool-btn">Test Worker</button>
                    <button id="switchWorkerBtn" class="tool-btn">Switch Worker Type</button>
                </div>
            </div>

            <!-- Input Filter Status -->
            <div class="menu-section">
                <h3>Input Filter</h3>
                <div class="filter-status">
                    <div>âœ“ Pen Enabled</div>
                    <div>âœ“ Mouse Enabled</div>
                    <div>âœ— Touch Disabled</div>
                </div>
            </div>

            <!-- DPR Info -->
            <div class="menu-section">
                <h3>System Info</h3>
                <div class="dpr-info">
                    <div>DPR: <span id="dprValue">-</span></div>
                    <div>Canvas: <span id="canvasSize">-</span></div>
                    <div>Worker: <span id="workerStatus">-</span></div>
                    <div>Environment: <span id="envType">-</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div id="canvasContainer" class="canvas-container">
        <canvas id="drawingCanvas"></canvas>
        <div id="eraserIndicator" class="eraser-indicator"></div>
    </div>

    <script>
        // Drawing App with Hybrid Worker Support
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isDrawing = false;
                this.currentTool = 'pen';
                this.strokeWidth = 2;
                this.eraserSize = 10;
                this.lastX = 0;
                this.lastY = 0;
                this.undoStack = [];
                this.maxUndoSteps = 50;
                
                // Smooth drawing with quadratic curves
                this.points = [];
                this.minDistance = 2;
                
                // Worker properties
                this.worker = null;
                this.workerType = null; // 'external' or 'inline'
                this.workerStartTime = 0;
                this.workerData = {};
                
                // DPR detection
                this.dpr = window.devicePixelRatio || 1;
                
                // Initialize
                this.detectEnvironment();
                this.setupCanvas();
                this.setupEventListeners();
                this.updateUI();
                this.saveState();
                this.initializeWorker();
            }

            detectEnvironment() {
                const isLocalhost = window.location.hostname === 'localhost' || 
                                   window.location.hostname === '127.0.0.1';
                const isPoeIframe = window.parent !== window;
                
                let envType = 'Unknown';
                if (isLocalhost) envType = 'Localhost';
                else if (isPoeIframe) envType = 'Poe Iframe';
                else envType = 'Remote';
                
                document.getElementById('envType').textContent = envType;
                
                this.environment = { isLocalhost, isPoeIframe, envType };
                console.log('ðŸ” Environment detected:', this.environment);
            }

            async initializeWorker() {
                console.log('ðŸš€ Initializing hybrid worker system...');
                
                // Try external worker first (for local development)
                if (await this.tryExternalWorker()) {
                    return;
                }
                
                // Fall back to inline worker
                this.createInlineWorker();
            }

            async tryExternalWorker() {
                const workerFiles = [
                    'drawing-worker.js',
                    'worker.js', 
                    'js/drawing-worker.js',
                    'workers/drawing-worker.js'
                ];
                
                for (const workerFile of workerFiles) {
                    try {
                        console.log(`ðŸ”„ Trying external worker: ${workerFile}`);
                        
                        // Test if file exists
                        const response = await fetch(workerFile, { method: 'HEAD' });
                        if (!response.ok) {
                            console.log(`âŒ Worker file not found: ${workerFile} (${response.status})`);
                            continue;
                        }
                        
                        // Try to create worker from file
                        this.worker = new Worker(workerFile);
                        this.worker.onmessage = (e) => this.handleWorkerResult(e.data);
                        this.worker.onerror = (e) => {
                            console.log(`âŒ External worker error (${workerFile}):`, e);
                            this.worker.terminate();
                            this.worker = null;
                            return false;
                        };
                        
                        // Test the worker works
                        const testResult = await this.testWorkerConnection();
                        if (testResult) {
                            console.log(`âœ… External worker initialized: ${workerFile}`);
                            document.getElementById('workerStatus').textContent = `External (${workerFile})`;
                            this.workerType = 'external';
                            setTimeout(() => this.testWorker(), 2000);
                            return true;
                        } else {
                            this.worker.terminate();
                            this.worker = null;
                        }
                        
                    } catch (error) {
                        console.log(`âŒ Failed to load external worker ${workerFile}:`, error);
                        if (this.worker) {
                            this.worker.terminate();
                            this.worker = null;
                        }
                    }
                }
                
                console.log('âŒ All external worker attempts failed');
                return false;
            }

            testWorkerConnection() {
                return new Promise((resolve) => {
                    if (!this.worker) {
                        resolve(false);
                        return;
                    }
                    
                    const testId = 'connection-test-' + Date.now();
                    const timeout = setTimeout(() => {
                        console.log('âŒ Worker connection test timeout');
                        resolve(false);
                    }, 2000);
                    
                    const testHandler = (e) => {
                        if (e.data.id === testId && e.data.operation === 'connectionTest') {
                            console.log('âœ… Worker connection test passed');
                            clearTimeout(timeout);
                            this.worker.removeEventListener('message', testHandler);
                            resolve(true);
                        }
                    };
                    
                    this.worker.addEventListener('message', testHandler);
                    this.worker.postMessage({ 
                        operation: 'connectionTest', 
                        data: {}, 
                        id: testId 
                    });
                });
            }

            createInlineWorker() {
                console.log('ðŸ”„ Creating inline worker...');
                
                const workerCode = `
                    console.log('ðŸ“¦ Inline worker started');
                    
                    self.onmessage = function(e) {
                        const { operation, data, id } = e.data;
                        
                        // Handle connection test
                        if (operation === 'connectionTest') {
                            self.postMessage({ operation, id, result: 'connected' });
                            return;
                        }
                        
                        switch(operation) {
                            case 'optimizePath':
                                const optimized = optimizePath(data.points);
                                self.postMessage({ operation, result: optimized, id, timestamp: Date.now() });
                                break;
                                
                            case 'analyzePath':
                                const analysis = analyzePath(data.points);
                                self.postMessage({ operation, result: analysis, id, timestamp: Date.now() });
                                break;
                                
                            case 'smoothPath':
                                const smoothed = smoothPath(data.points, data.intensity || 0.5);
                                self.postMessage({ operation, result: smoothed, id, timestamp: Date.now() });
                                break;
                        }
                    };
                    
                    function optimizePath(points) {
                        if (points.length < 3) return points;
                        const optimized = [points[0]];
                        const tolerance = 3;
                        
                        for (let i = 1; i < points.length - 1; i++) {
                            const prev = points[i - 1];
                            const curr = points[i];
                            const next = points[i + 1];
                            
                            const d1 = Math.sqrt((next.x - prev.x) ** 2 + (next.y - prev.y) ** 2);
                            const d2 = Math.sqrt((curr.x - prev.x) ** 2 + (curr.y - prev.y) ** 2);
                            const d3 = Math.sqrt((next.x - curr.x) ** 2 + (next.y - curr.y) ** 2);
                            
                            if (Math.abs(d2 + d3 - d1) > tolerance) {
                                optimized.push(curr);
                            }
                        }
                        
                        optimized.push(points[points.length - 1]);
                        return optimized;
                    }
                    
                    function analyzePath(points) {
                        if (points.length < 2) return { length: 0, complexity: 0, points: 0 };
                        
                        let totalLength = 0;
                        let totalCurvature = 0;
                        
                        for (let i = 1; i < points.length; i++) {
                            const dist = Math.sqrt(
                                (points[i].x - points[i-1].x) ** 2 + 
                                (points[i].y - points[i-1].y) ** 2
                            );
                            totalLength += dist;
                            
                            if (i > 1) {
                                const a1 = Math.atan2(points[i-1].y - points[i-2].y, points[i-1].x - points[i-2].x);
                                const a2 = Math.atan2(points[i].y - points[i-1].y, points[i].x - points[i-1].x);
                                const curvature = Math.abs(a2 - a1);
                                totalCurvature += curvature;
                            }
                        }
                        
                        return {
                            length: Math.round(totalLength),
                            complexity: Math.round(totalCurvature * 100) / 100,
                            points: points.length
                        };
                    }
                    
                    function smoothPath(points, intensity) {
                        if (points.length < 3) return points;
                        
                        const smoothed = [points[0]];
                        
                        for (let i = 1; i < points.length - 1; i++) {
                            const prev = points[i - 1];
                            const curr = points[i];
                            const next = points[i + 1];
                            
                            const smoothX = curr.x + (prev.x + next.x - 2 * curr.x) * intensity;
                            const smoothY = curr.y + (prev.y + next.y - 2 * curr.y) * intensity;
                            
                            smoothed.push({ x: smoothX, y: smoothY });
                        }
                        
                        smoothed.push(points[points.length - 1]);
                        return smoothed;
                    }
                `;

                try {
                    this.worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
                    this.worker.onmessage = (e) => this.handleWorkerResult(e.data);
                    this.worker.onerror = (e) => {
                        console.log('âŒ Inline worker error:', e);
                        this.worker = null;
                        document.getElementById('workerStatus').textContent = 'Failed';
                    };
                    
                    console.log('âœ… Inline worker initialized');
                    document.getElementById('workerStatus').textContent = 'Inline';
                    this.workerType = 'inline';
                    
                    // Test worker automatically after 2 seconds
                    setTimeout(() => this.testWorker(), 2000);
                    
                } catch (error) {
                    console.log('âŒ Inline worker initialization failed:', error);
                    this.worker = null;
                    document.getElementById('workerStatus').textContent = 'Unavailable';
                }
            }

            switchWorkerType() {
                if (this.worker) {
                    this.worker.terminate();
                    this.worker = null;
                }
                
                if (this.workerType === 'inline') {
                    console.log('ðŸ”„ Switching to external worker...');
                    this.tryExternalWorker().then(success => {
                        if (!success) {
                            console.log('âŒ External worker failed, reverting to inline');
                            this.createInlineWorker();
                        }
                    });
                } else {
                    console.log('ðŸ”„ Switching to inline worker...');
                    this.createInlineWorker();
                }
            }

            showWorkerNotification(text = 'Worker Active') {
                const notification = document.getElementById('workerNotification');
                if (notification) {
                    notification.querySelector('.worker-text').textContent = text;
                    notification.classList.remove('hidden');
                }
            }

            hideWorkerNotification() {
                const notification = document.getElementById('workerNotification');
                if (notification) {
                    setTimeout(() => notification.classList.add('hidden'), 800);
                }
            }

            handleWorkerResult(data) {
                const { operation, result } = data;
                const processingTime = Date.now() - this.workerStartTime;
                
                console.log(`âœ… Worker (${this.workerType}) completed ${operation} in ${processingTime}ms`);
                
                switch(operation) {
                    case 'optimizePath':
                        this.updateStatus(`Optimized: ${this.workerData.originalPoints} â†’ ${result.length} points`);
                        break;
                    case 'analyzePath':
                        this.updateStatus(`Analysis: ${result.length}px, complexity ${result.complexity}`);
                        break;
                    case 'smoothPath':
                        this.updateStatus(`Smoothed ${result.length} points`);
                        break;
                }
                
                this.hideWorkerNotification();
                setTimeout(() => this.updateStatus('Ready'), 3000);
            }

            useWorker(operation, data) {
                if (!this.worker) {
                    console.log('Worker not available');
                    this.updateStatus('Worker unavailable');
                    return false;
                }
                
                this.workerStartTime = Date.now();
                this.workerData = { originalPoints: data.points ? data.points.length : 0 };
                
                this.showWorkerNotification(`Processing ${operation}...`);
                this.worker.postMessage({ operation, data, id: Date.now() });
                
                return true;
            }

            testWorker() {
                // Generate sample path data
                const samplePoints = [];
                for (let i = 0; i < 100; i++) {
                    samplePoints.push({
                        x: 100 + i * 2 + Math.sin(i * 0.1) * 20,
                        y: 100 + Math.cos(i * 0.05) * 30
                    });
                }
                
                console.log(`ðŸ§ª Testing ${this.workerType} worker with sample data...`);
                this.useWorker('analyzePath', { points: samplePoints });
            }

            setupCanvas() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();
                
                const width = Math.min(rect.width - 40, 1200);
                const height = Math.min(rect.height - 40, 800);
                
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                
                this.canvas.width = width * this.dpr;
                this.canvas.height = height * this.dpr;
                
                this.ctx.scale(this.dpr, this.dpr);
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, width, height);
                
                document.getElementById('dprValue').textContent = this.dpr.toFixed(2);
                document.getElementById('canvasSize').textContent = `${width}x${height}`;
            }

            setupEventListeners() {
                document.getElementById('menuToggle').addEventListener('click', () => this.toggleMenu());
                document.getElementById('penTool').addEventListener('click', () => this.setTool('pen'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('strokeWidth').addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    document.getElementById('strokeWidthValue').textContent = this.strokeWidth;
                    this.updateStatus(`Stroke width: ${this.strokeWidth}px`);
                });
                document.getElementById('eraserSize').addEventListener('input', (e) => {
                    this.eraserSize = parseInt(e.target.value);
                    document.getElementById('eraserSizeValue').textContent = this.eraserSize;
                    this.updateEraserIndicatorSize();
                    this.updateStatus(`Eraser size: ${this.eraserSize}px`);
                });
                document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('testWorkerBtn').addEventListener('click', () => this.testWorker());
                document.getElementById('switchWorkerBtn').addEventListener('click', () => this.switchWorkerType());

                this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('pointerleave', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Lightweight eraser indicator events
                this.canvas.addEventListener('pointerenter', (e) => this.showEraserIndicator(e));
                this.canvas.addEventListener('pointerleave', () => this.hideEraserIndicator());
                document.addEventListener('pointermove', (e) => this.updateEraserIndicator(e));

                document.addEventListener('click', (e) => {
                    const sideMenu = document.getElementById('sideMenu');
                    const menuToggle = document.getElementById('menuToggle');
                    if (!sideMenu.contains(e.target) && !menuToggle.contains(e.target)) {
                        if (sideMenu.classList.contains('open')) {
                            sideMenu.classList.remove('open');
                            menuToggle.classList.remove('open');
                            this.updateStatus('Ready');
                        }
                    }
                });

                window.addEventListener('resize', () => this.setupCanvas());
            }

            isAllowedInput(e) {
                return e.pointerType === 'mouse' || e.pointerType === 'pen';
            }

            updateInputIndicator(e) {
                const indicator = document.getElementById('inputIndicator');
                const deviceType = document.getElementById('deviceType');
                const buttonState = document.getElementById('buttonState');

                if (e.pointerType === 'mouse') {
                    indicator.className = 'input-indicator bg-green-500';
                    deviceType.textContent = 'MOUSE';
                    buttonState.textContent = e.pressure > 0 ? `L:${Math.round(e.pressure * 100)}%` : 'HOVER';
                } else if (e.pointerType === 'pen') {
                    indicator.className = 'input-indicator bg-blue-500';
                    deviceType.textContent = 'PEN';
                    buttonState.textContent = e.pressure > 0 ? `TIP P:${Math.round(e.pressure * 100)}%` : 'HOVER';
                } else if (e.pointerType === 'touch') {
                    indicator.className = 'input-indicator bg-red-500';
                    deviceType.textContent = 'TOUCH';
                    buttonState.textContent = 'BLOCKED';
                } else {
                    indicator.className = 'input-indicator bg-orange-500';
                    deviceType.textContent = 'OTHER';
                    buttonState.textContent = 'UNKNOWN';
                }
            }

            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }

            handlePointerDown(e) {
                this.updateInputIndicator(e);
                
                if (!this.isAllowedInput(e)) {
                    e.preventDefault();
                    this.updateStatus('Input blocked: Touch not allowed');
                    return;
                }

                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.points = [{ x, y }];
                this.lastX = x;
                this.lastY = y;

                if (this.currentTool === 'pen') {
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = this.strokeWidth;
                } else if (this.currentTool === 'eraser') {
                    this.ctx.globalCompositeOperation = 'destination-out';
                    this.ctx.lineWidth = this.eraserSize;
                }

                this.ctx.beginPath();
                this.ctx.arc(x, y, this.strokeWidth / 2, 0, 2 * Math.PI);
                this.ctx.fill();

                this.updateStatus(`Drawing with ${e.pointerType}`);
                e.preventDefault();
            }

            handlePointerMove(e) {
                this.updateInputIndicator(e);
                
                if (!this.isAllowedInput(e)) {
                    e.preventDefault();
                    return;
                }

                if (!this.isDrawing) return;

                const rect = this.canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                const distance = this.distance({ x: currentX, y: currentY }, { x: this.lastX, y: this.lastY });
                if (distance >= this.minDistance) {
                    this.points.push({ x: currentX, y: currentY });
                    
                    if (this.points.length >= 3) {
                        this.drawSmoothSegment();
                    } else if (this.points.length === 2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.points[0].x, this.points[0].y);
                        this.ctx.lineTo(this.points[1].x, this.points[1].y);
                        this.ctx.stroke();
                    }
                    
                    this.lastX = currentX;
                    this.lastY = currentY;
                }

                e.preventDefault();
            }

            drawSmoothSegment() {
                const len = this.points.length;
                if (len < 3) return;

                const p1 = this.points[len - 3];
                const p2 = this.points[len - 2];
                const p3 = this.points[len - 1];

                const midPoint1 = {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
                const midPoint2 = {
                    x: (p2.x + p3.x) / 2,
                    y: (p2.y + p3.y) / 2
                };

                this.ctx.beginPath();
                
                if (len === 3) {
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.quadraticCurveTo(p2.x, p2.y, midPoint2.x, midPoint2.y);
                } else {
                    const prevP1 = this.points[len - 4];
                    const prevP2 = this.points[len - 3];
                    const prevMidPoint = {
                        x: (prevP1.x + prevP2.x) / 2,
                        y: (prevP1.y + prevP2.y) / 2
                    };
                    
                    this.ctx.moveTo(prevMidPoint.x, prevMidPoint.y);
                    this.ctx.quadraticCurveTo(p1.x, p1.y, midPoint1.x, midPoint1.y);
                    this.ctx.quadraticCurveTo(p2.x, p2.y, midPoint2.x, midPoint2.y);
                }

                this.ctx.stroke();
            }

            handlePointerUp(e) {
                if (!this.isAllowedInput(e) && this.isDrawing) {
                    this.isDrawing = false;
                    return;
                }

                if (this.isDrawing) {
                    this.isDrawing = false;
                    
                    // Use worker to analyze completed stroke if it's long enough
                    if (this.points.length > 10 && this.worker) {
                        this.useWorker('optimizePath', { points: this.points });
                    }
                    
                    this.saveState();
                    this.updateStatus('Ready');
                }

                setTimeout(() => {
                    const indicator = document.getElementById('inputIndicator');
                    const deviceType = document.getElementById('deviceType');
                    const buttonState = document.getElementById('buttonState');
                    
                    indicator.className = 'input-indicator bg-gray-400';
                    deviceType.textContent = '-';
                    buttonState.textContent = '-';
                }, 500);

                e.preventDefault();
            }

            setTool(tool) {
                this.currentTool = tool;
                
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                // Show/hide eraser size control
                const eraserSizeSection = document.getElementById('eraserSizeSection');
                if (tool === 'eraser') {
                    eraserSizeSection.classList.remove('hidden');
                    this.canvas.style.cursor = 'grab';
                } else {
                    eraserSizeSection.classList.add('hidden');
                    this.canvas.style.cursor = 'crosshair';
                }
                
                this.updateStatus(`${tool.charAt(0).toUpperCase() + tool.slice(1)} selected`);
            }

            clearCanvas() {
                const width = this.canvas.style.width.replace('px', '');
                const height = this.canvas.style.height.replace('px', '');
                
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, width, height);
                
                this.saveState();
                this.updateStatus('Canvas cleared');
                setTimeout(() => this.updateStatus('Ready'), 2000);
            }

            saveState() {
                if (this.undoStack.length >= this.maxUndoSteps) {
                    this.undoStack.shift();
                }
                this.undoStack.push(this.canvas.toDataURL());
            }

            undo() {
                if (this.undoStack.length > 1) {
                    this.undoStack.pop();
                    const previousState = this.undoStack[this.undoStack.length - 1];
                    
                    const img = new Image();
                    img.onload = () => {
                        const width = parseInt(this.canvas.style.width);
                        const height = parseInt(this.canvas.style.height);
                        this.ctx.clearRect(0, 0, width, height);
                        this.ctx.drawImage(img, 0, 0, width, height);
                    };
                    img.src = previousState;
                    
                    this.updateStatus('Undone');
                    setTimeout(() => this.updateStatus('Ready'), 2000);
                } else {
                    this.updateStatus('Nothing to undo');
                    setTimeout(() => this.updateStatus('Ready'), 2000);
                }
            }

            toggleMenu() {
                const sideMenu = document.getElementById('sideMenu');
                const menuToggle = document.getElementById('menuToggle');
                
                const isOpen = sideMenu.classList.toggle('open');
                menuToggle.classList.toggle('open', isOpen);
                
                this.updateStatus(isOpen ? 'Menu opened' : 'Ready');
            }

            updateStatus(message) {
                document.getElementById('statusText').textContent = message;
            }

            updateUI() {
                document.getElementById('strokeWidthValue').textContent = this.strokeWidth;
                document.getElementById('eraserSizeValue').textContent = this.eraserSize;
                this.updateEraserIndicatorSize();
                this.updateStatus('Ready');
            }

            // Lightweight eraser indicator methods
            updateEraserIndicatorSize() {
                const indicator = document.getElementById('eraserIndicator');
                indicator.style.width = this.eraserSize + 'px';
                indicator.style.height = this.eraserSize + 'px';
            }

            showEraserIndicator(e) {
                if (this.currentTool === 'eraser' && this.isAllowedInput(e)) {
                    const indicator = document.getElementById('eraserIndicator');
                    indicator.classList.add('visible');
                    this.updateEraserIndicator(e);
                }
            }

            hideEraserIndicator() {
                const indicator = document.getElementById('eraserIndicator');
                indicator.classList.remove('visible');
            }

            updateEraserIndicator(e) {
                if (this.currentTool === 'eraser') {
                    const indicator = document.getElementById('eraserIndicator');
                    if (indicator.classList.contains('visible')) {
                        indicator.style.left = e.clientX + 'px';
                        indicator.style.top = e.clientY + 'px';
                    }
                }
            }
        }

        // Initialize the drawing app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.drawingApp = new DrawingApp();
        });
    </script>


</body></html>
