<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotation App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#000000',
                        secondary: '#666666',
                        accent: '#999999'
                    }
                }
            }
        }
    </script>
    <style>
        /* Performance optimizations */
        * {
            box-sizing: border-box;
        }
        
        body {
            background: #ffffff;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #canvas {
            touch-action: none;
            cursor: crosshair;
        }
        
        .hamburger {
            transition: transform 0.2s ease;
        }
        
        .hamburger.open {
            transform: rotate(90deg);
        }
        
        .menu-panel {
            transform: translateX(-100%);
            transition: transform 0.2s ease;
            will-change: transform;
        }
        
        .menu-panel.open {
            transform: translateX(0);
        }
        
        /* SVG optimization */
        svg {
            shape-rendering: auto;
            text-rendering: auto;
        }
        
        .tool-btn {
            transition: background-color 0.1s ease;
        }
        
        .tool-btn:hover {
            background-color: #f5f5f5;
        }
        
        .tool-btn.active {
            background-color: #e5e5e5;
        }
    </style>
</head>
<body class="bg-white text-black font-mono">
    <!-- Header -->
    <div class="fixed top-0 left-0 right-0 bg-white border-b border-gray-300 z-20 h-12 flex items-center px-4">
        <button id="menuToggle" class="hamburger p-2 mr-3 hover:bg-gray-100 rounded">
            <div class="w-5 h-0.5 bg-black mb-1"></div>
            <div class="w-5 h-0.5 bg-black mb-1"></div>
            <div class="w-5 h-0.5 bg-black"></div>
        </button>
        <span class="text-sm font-medium">Annotation Tool</span>
        <div class="ml-auto flex items-center space-x-3">
            <span id="statusText" class="text-xs text-gray-600">Ready</span>
            <div id="inputDetails" class="flex items-center space-x-2">
                <div id="inputIndicator" class="w-2 h-2 bg-gray-400 rounded-full"></div>
                <div id="inputInfo" class="text-xs text-gray-600 font-mono min-w-0">
                    <div id="deviceType">-</div>
                    <div id="buttonState" class="text-gray-500">-</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="sideMenu" class="menu-panel fixed left-0 top-12 bottom-0 w-64 bg-white border-r border-gray-300 z-10 overflow-y-auto">
        <div class="p-4 space-y-4">
            <!-- Tools -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Tools</h3>
                <div class="space-y-1">
                    <button id="penTool" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200 active">
                        Pen
                    </button>
                    <button id="eraserTool" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200">
                        Eraser
                    </button>
                </div>
            </div>

            <!-- Stroke Width -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Stroke Width</h3>
                <input type="range" id="strokeWidth" min="1" max="20" value="2" 
                       class="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                <div class="text-xs text-gray-600 mt-1">
                    <span id="strokeWidthValue">2</span>px
                </div>
            </div>

            <!-- Actions -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Actions</h3>
                <div class="space-y-1">
                    <button id="clearBtn" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200">
                        Clear All
                    </button>
                    <button id="undoBtn" class="tool-btn w-full text-left px-3 py-2 text-sm rounded border border-gray-200">
                        Undo
                    </button>
                </div>
            </div>

            <!-- Input Filter Status -->
            <div>
                <h3 class="text-xs font-semibold text-gray-600 mb-2 uppercase tracking-wide">Input Filter</h3>
                <div class="text-xs text-gray-600 space-y-1">
                    <div>✓ Pen Enabled</div>
                    <div>✓ Mouse Enabled</div>
                    <div>✗ Touch Disabled</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div id="canvasContainer" class="fixed top-12 left-0 right-0 bottom-0 bg-white overflow-hidden">
        <svg id="canvas" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style>
                    .stroke {
                        fill: none;
                        stroke: #000000;
                        stroke-linecap: round;
                        stroke-linejoin: round;
                    }
                </style>
            </defs>
        </svg>
    </div>

    <script>
        class AnnotationApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.menuToggle = document.getElementById('menuToggle');
                this.sideMenu = document.getElementById('sideMenu');
                this.statusText = document.getElementById('statusText');
                this.inputIndicator = document.getElementById('inputIndicator');
                
                this.isDrawing = false;
                this.currentPath = null;
                this.currentTool = 'pen';
                this.strokeWidth = 2;
                this.strokes = [];
                this.undoStack = [];
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.updateCanvasSize();
                window.addEventListener('resize', () => this.updateCanvasSize());
            }
            
            setupEventListeners() {
                // Menu toggle
                this.menuToggle.addEventListener('click', () => this.toggleMenu());
                
                // Tool selection
                document.getElementById('penTool').addEventListener('click', () => this.setTool('pen'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                
                // Stroke width
                const strokeWidthSlider = document.getElementById('strokeWidth');
                strokeWidthSlider.addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    document.getElementById('strokeWidthValue').textContent = this.strokeWidth;
                });
                
                // Actions
                document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                
                // Canvas drawing events - using pointer events for better performance
                this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('pointercancel', (e) => this.handlePointerUp(e));
                
                // Add hover detection for pen
                this.canvas.addEventListener('pointerenter', (e) => this.handlePointerHover(e));
                this.canvas.addEventListener('pointerleave', (e) => this.resetInputIndicator());
                
                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            updateCanvasSize() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();
                this.canvas.setAttribute('width', rect.width);
                this.canvas.setAttribute('height', rect.height);
            }
            
            toggleMenu() {
                const isOpen = this.sideMenu.classList.toggle('open');
                this.menuToggle.classList.toggle('open', isOpen);
            }
            
            setTool(tool) {
                this.currentTool = tool;
                
                // Update UI
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                // Update cursor
                this.canvas.style.cursor = tool === 'pen' ? 'crosshair' : 'grab';
                
                this.updateStatus(`${tool.charAt(0).toUpperCase() + tool.slice(1)} selected`);
            }
            
            handlePointerDown(e) {
                // Filter input: only allow pen and mouse, block touch
                if (e.pointerType === 'touch') {
                    e.preventDefault();
                    this.updateStatus('Touch input disabled');
                    this.updateInputIndicator('touch', e);
                    setTimeout(() => {
                        this.resetInputIndicator();
                    }, 1000);
                    return;
                }
                
                // Update detailed input indicator
                this.updateInputIndicator(e.pointerType, e);
                
                e.preventDefault();
                this.canvas.setPointerCapture(e.pointerId);
                
                const point = this.getCanvasPoint(e);
                this.isDrawing = true;
                
                if (this.currentTool === 'pen') {
                    this.startStroke(point);
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(point);
                }
            }
            
            handlePointerMove(e) {
                // Update input indicator even when not drawing (for hover detection)
                if (e.pointerType === 'pen' && !this.isDrawing) {
                    this.updateInputIndicator(e.pointerType, e);
                }
                
                if (!this.isDrawing || e.pointerType === 'touch') return;
                
                e.preventDefault();
                const point = this.getCanvasPoint(e);
                
                if (this.currentTool === 'pen') {
                    this.addPointToStroke(point);
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(point);
                }
            }
            
            handlePointerHover(e) {
                // Handle pen hover when entering canvas area
                if (e.pointerType === 'pen') {
                    this.updateInputIndicator(e.pointerType, e);
                }
            }
            
            handlePointerUp(e) {
                if (e.pointerType === 'touch') return;
                
                e.preventDefault();
                this.canvas.releasePointerCapture(e.pointerId);
                
                if (this.isDrawing && this.currentTool === 'pen') {
                    this.finishStroke();
                }
                
                this.isDrawing = false;
                this.resetInputIndicator();
                this.updateStatus('Ready');
            }
            
            updateInputIndicator(pointerType, event) {
                const deviceType = document.getElementById('deviceType');
                const buttonState = document.getElementById('buttonState');
                const indicator = this.inputIndicator;
                
                if (pointerType === 'touch') {
                    indicator.className = 'w-2 h-2 bg-red-500 rounded-full';
                    deviceType.textContent = 'TOUCH';
                    buttonState.textContent = 'BLOCKED';
                    this.updateStatus('Touch input disabled');
                    return;
                }
                
                if (pointerType === 'pen') {
                    indicator.className = 'w-2 h-2 bg-blue-500 rounded-full';
                    deviceType.textContent = 'PEN';
                    
                    // Detect pen button states
                    const buttons = this.getPenButtonState(event);
                    const pressure = Math.round((event.pressure || 0) * 100);
                    const tilt = event.tiltX !== undefined ? `T:${Math.round(event.tiltX)}°,${Math.round(event.tiltY)}°` : '';
                    
                    buttonState.textContent = `${buttons} P:${pressure}% ${tilt}`.trim();
                    
                    this.updateStatus(`Pen: ${buttons} Pressure: ${pressure}%`);
                    
                } else if (pointerType === 'mouse') {
                    indicator.className = 'w-2 h-2 bg-green-500 rounded-full';
                    deviceType.textContent = 'MOUSE';
                    
                    // Detect mouse button states
                    const buttons = this.getMouseButtonState(event);
                    buttonState.textContent = buttons;
                    
                    this.updateStatus(`Mouse: ${buttons}`);
                } else {
                    indicator.className = 'w-2 h-2 bg-orange-500 rounded-full';
                    deviceType.textContent = pointerType.toUpperCase();
                    buttonState.textContent = 'Unknown';
                    this.updateStatus(`${pointerType} input detected`);
                }
            }
            
            getPenButtonState(event) {
                const buttons = event.buttons || 0;
                const pressure = event.pressure || 0;
                const parts = [];
                
                // Check for eraser detection first (button 32 is commonly eraser, but also check button 5)
                // Different pens report eraser differently
                if (buttons & 32 || buttons & 4 || (buttons === 0 && pressure > 0 && event.pointerType === 'pen' && this.isEraserEnd(event))) {
                    parts.push('ERASER-TIP');
                }
                // Primary button (pen tip) - only if not eraser
                else if (buttons & 1) {
                    parts.push('TIP');
                }
                
                // Secondary button (barrel button)
                if (buttons & 2) parts.push('BARREL');
                
                // Additional barrel button or eraser button
                if ((buttons & 4) && !(buttons & 32)) parts.push('AUX');
                
                // Additional buttons for advanced styluses
                if (buttons & 8) parts.push('BTN4');
                if (buttons & 16) parts.push('BTN5');
                
                // Check for specific Microsoft Pen 1776 characteristics
                if (event.tangentialPressure !== undefined && Math.abs(event.tangentialPressure) > 0.01) {
                    parts.push(`ROT:${Math.round(event.tangentialPressure * 360)}°`);
                }
                
                // Determine hover vs contact state
                if (parts.length === 0) {
                    if (pressure > 0) {
                        // Has pressure but no buttons - might be eraser
                        return 'CONTACT';
                    } else {
                        // No pressure, no buttons - hovering
                        return 'HOVER';
                    }
                }
                
                return parts.join('+');
            }
            
            isEraserEnd(event) {
                // Heuristic to detect eraser end:
                // - Some pens report buttons=0 when using eraser tip but have pressure
                // - Check for specific pen characteristics that might indicate eraser
                // - Tilt might be inverted or specific values when using eraser end
                
                if (event.twist !== undefined && Math.abs(event.twist) > 90) {
                    return true; // Pen might be flipped
                }
                
                // Some pens report different tilt ranges when flipped
                if (event.tiltX !== undefined && event.tiltY !== undefined) {
                    const tiltMagnitude = Math.sqrt(event.tiltX * event.tiltX + event.tiltY * event.tiltY);
                    if (tiltMagnitude > 60) {
                        return true; // Pen is at extreme angle (possibly flipped)
                    }
                }
                
                return false;
            }
            
            getMouseButtonState(event) {
                const buttons = event.buttons || 0;
                const parts = [];
                
                if (buttons & 1) parts.push('L'); // Left button
                if (buttons & 2) parts.push('R'); // Right button  
                if (buttons & 4) parts.push('M'); // Middle button
                if (buttons & 8) parts.push('X1'); // Back button
                if (buttons & 16) parts.push('X2'); // Forward button
                
                return parts.length > 0 ? parts.join('+') : 'HOVER';
            }
            
            resetInputIndicator() {
                this.inputIndicator.className = 'w-2 h-2 bg-gray-400 rounded-full';
                document.getElementById('deviceType').textContent = '-';
                document.getElementById('buttonState').textContent = '-';
            }
            
            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            startStroke(point) {
                // Save state for undo
                this.saveState();
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('stroke');
                path.setAttribute('stroke-width', this.strokeWidth);
                path.setAttribute('d', `M ${point.x} ${point.y}`);
                
                this.canvas.appendChild(path);
                this.currentPath = path;
                this.strokes.push(path);
                
                // Initialize points array for quadratic interpolation
                this.currentPoints = [point];
                this.pathData = `M ${point.x} ${point.y}`;
            }
            
            addPointToStroke(point) {
                if (!this.currentPath) return;
                
                this.currentPoints.push(point);
                
                // Apply quadratic midpoint interpolation
                if (this.currentPoints.length >= 3) {
                    this.updatePathWithQuadratic();
                } else if (this.currentPoints.length === 2) {
                    // For the second point, draw a line to start the stroke
                    this.pathData += ` L ${point.x} ${point.y}`;
                    this.currentPath.setAttribute('d', this.pathData);
                }
            }
            
            updatePathWithQuadratic() {
                const len = this.currentPoints.length;
                const p0 = this.currentPoints[len - 3]; // Previous point
                const p1 = this.currentPoints[len - 2]; // Current control point
                const p2 = this.currentPoints[len - 1]; // New point
                
                // Calculate midpoints for smooth interpolation
                const mid1 = this.getMidpoint(p0, p1);
                const mid2 = this.getMidpoint(p1, p2);
                
                // Remove the last line segment and replace with quadratic curve
                if (len === 3) {
                    // First quadratic curve - start from the first point to mid2
                    this.pathData = `M ${this.currentPoints[0].x} ${this.currentPoints[0].y} Q ${p1.x} ${p1.y} ${mid2.x} ${mid2.y}`;
                } else {
                    // Continue with smooth quadratic curves
                    this.pathData += ` Q ${p1.x} ${p1.y} ${mid2.x} ${mid2.y}`;
                }
                
                this.currentPath.setAttribute('d', this.pathData);
            }
            
            getMidpoint(p1, p2) {
                return {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
            }
            
            finishStroke() {
                // Complete the final curve to the last point if we have points
                if (this.currentPoints && this.currentPoints.length >= 2) {
                    const lastPoint = this.currentPoints[this.currentPoints.length - 1];
                    this.pathData += ` L ${lastPoint.x} ${lastPoint.y}`;
                    this.currentPath.setAttribute('d', this.pathData);
                }
                
                this.currentPath = null;
                this.currentPoints = null;
                this.pathData = null;
            }
            
            eraseAtPoint(point) {
                const eraseRadius = this.strokeWidth * 3;
                
                // Check for strokes to erase
                this.strokes = this.strokes.filter(stroke => {
                    if (this.isPointNearStroke(point, stroke, eraseRadius)) {
                        stroke.remove();
                        return false;
                    }
                    return true;
                });
            }
            
            isPointNearStroke(point, stroke, radius) {
                // Simple collision detection - check if point is near stroke
                const pathLength = stroke.getTotalLength();
                for (let i = 0; i <= pathLength; i += 5) {
                    const pathPoint = stroke.getPointAtLength(i);
                    const distance = Math.sqrt(
                        Math.pow(point.x - pathPoint.x, 2) + 
                        Math.pow(point.y - pathPoint.y, 2)
                    );
                    if (distance < radius) {
                        return true;
                    }
                }
                return false;
            }
            
            clearCanvas() {
                this.saveState();
                this.strokes.forEach(stroke => stroke.remove());
                this.strokes = [];
                this.updateStatus('Canvas cleared');
            }
            
            saveState() {
                // Simple undo system - save canvas state
                const state = this.strokes.map(stroke => stroke.cloneNode(true));
                this.undoStack.push(state);
                
                // Limit undo stack size for performance
                if (this.undoStack.length > 20) {
                    this.undoStack.shift();
                }
            }
            
            undo() {
                if (this.undoStack.length === 0) {
                    this.updateStatus('Nothing to undo');
                    return;
                }
                
                // Clear current strokes
                this.strokes.forEach(stroke => stroke.remove());
                
                // Restore previous state
                const previousState = this.undoStack.pop();
                this.strokes = [];
                
                previousState.forEach(stroke => {
                    const newStroke = stroke.cloneNode(true);
                    this.canvas.appendChild(newStroke);
                    this.strokes.push(newStroke);
                });
                
                this.updateStatus('Undone');
            }
            
            updateStatus(message) {
                this.statusText.textContent = message;
            }
        }
        
        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new AnnotationApp();
        });
    </script>
</body>
</html>
