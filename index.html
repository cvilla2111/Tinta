<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            color: black;
            overflow: hidden;
        }

        .homescreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }

        .load-button {
            padding: 16px 32px;
            font-size: 18px;
            background: black;
            color: white;
            border: none;
            cursor: pointer;
            font-family: inherit;
            margin-bottom: 20px;
        }

        .load-button:hover {
            background: #333;
        }

        .file-input {
            display: none;
        }

        .pdf-viewer {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .pdf-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: white;
        }

        .ink-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            touch-action: none;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: black;
            font-size: 14px;
            z-index: 1000;
        }

        .clear-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: black;
            color: white;
            border: none;
            padding: 8px;
            cursor: pointer;
            font-family: inherit;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .clear-button:hover {
            background: #333;
        }

        .eraser-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 1px dashed black;
            border-radius: 50%;
            background-color: rgba(128, 128, 128, 0.2);
            pointer-events: none;
            z-index: 1001;
            display: none;
            transform: translate(-50%, -50%);
        }

        .menu-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: black;
            color: white;
            border: none;
            padding: 8px;
            cursor: pointer;
            font-family: inherit;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .menu-button:hover {
            background: #333;
        }

        .drawer {
            position: fixed;
            top: 0;
            left: -300px;
            width: 300px;
            height: 100vh;
            background: white;
            border-right: 2px solid black;
            z-index: 2000;
            transition: left 0.3s ease;
            padding: 80px 20px 20px 20px;
        }

        .drawer.open {
            left: 0;
        }

        .drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }

        .drawer-overlay.visible {
            display: block;
        }

        .stroke-control {
            margin-bottom: 30px;
        }

        .stroke-control h3 {
            font-size: 16px;
            font-weight: normal;
            margin-bottom: 15px;
            color: black;
        }

        .stepper {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .stepper-button {
            width: 40px;
            height: 40px;
            background: black;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stepper-button:hover {
            background: #333;
        }

        .stepper-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .stepper-value {
            font-size: 18px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }

        .size-reference {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .size-dot {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dot {
            background-color: rgba(128, 128, 128, 0.3);
            border: 1px dashed black;
            border-radius: 50%;
        }

        .dot-label {
            font-size: 12px;
            color: black;
            font-weight: bold;
        }

        .dot-10 { width: 10px; height: 10px; }
        .dot-20 { width: 20px; height: 20px; }
        .dot-30 { width: 30px; height: 30px; }
        .dot-50 { width: 50px; height: 50px; }
        .dot-90 { width: 90px; height: 90px; }
    </style>
</head>
<body>
    <div class="homescreen" id="homescreen">
        <h1 style="margin-bottom: 40px; font-weight: normal;">PDF Annotator</h1>
        <button class="load-button" onclick="document.getElementById('fileInput').click()">
            Load PDF
        </button>
        <input type="file" id="fileInput" class="file-input" accept=".pdf" onchange="loadPDF(event)">
        <p style="margin-top: 20px; color: #666; font-size: 14px;">Select a PDF file to start annotating</p>
    </div>

    <div class="pdf-viewer" id="pdfViewer">
        <button class="menu-button" onclick="toggleDrawer()" title="Settings">
            <i data-lucide="menu"></i>
        </button>
        <button class="clear-button" onclick="clearAnnotations()" title="Clear annotations">
            <i data-lucide="trash-2"></i>
        </button>
        <div class="instructions">Use arrow keys to navigate • Surface Pen to annotate • Barrel button to erase</div>
        
        <div class="size-reference">
            <div class="size-dot">
                <div class="dot dot-10"></div>
                <span class="dot-label">10px</span>
            </div>
            <div class="size-dot">
                <div class="dot dot-20"></div>
                <span class="dot-label">20px</span>
            </div>
            <div class="size-dot">
                <div class="dot dot-30"></div>
                <span class="dot-label">30px</span>
            </div>
            <div class="size-dot">
                <div class="dot dot-50"></div>
                <span class="dot-label">50px</span>
            </div>
            <div class="size-dot">
                <div class="dot dot-90"></div>
                <span class="dot-label">90px</span>
            </div>
        </div>
        
        <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
        <canvas id="inkCanvas" class="ink-canvas"></canvas>
        <div id="eraserIndicator" class="eraser-indicator"></div>
    </div>

    <div class="drawer-overlay" id="drawerOverlay" onclick="closeDrawer()"></div>
    <div class="drawer" id="drawer">
        <div class="stroke-control">
            <h3>Stroke Size</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseStrokeSize()" id="decreaseBtn">-</button>
                <div class="stepper-value" id="strokeSizeValue">2</div>
                <button class="stepper-button" onclick="increaseStrokeSize()" id="increaseBtn">+</button>
            </div>
        </div>
        
        <div class="stroke-control">
            <h3>Eraser Threshold</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseThreshold()" id="decreaseThresholdBtn">-</button>
                <div class="stepper-value" id="thresholdValue">10</div>
                <button class="stepper-button" onclick="increaseThreshold()" id="increaseThresholdBtn">+</button>
            </div>
            <button class="stepper-button" onclick="resetThreshold()" id="resetThresholdBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
        
        <div class="stroke-control">
            <h3>Eraser Sensitivity</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseSensitivity()" id="decreaseSensitivityBtn">-</button>
                <div class="stepper-value" id="sensitivityValue">5</div>
                <button class="stepper-button" onclick="increaseSensitivity()" id="increaseSensitivityBtn">+</button>
            </div>
            <button class="stepper-button" onclick="resetSensitivity()" id="resetSensitivityBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
    </div>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDocument = null;
        let currentPage = 1;
        let totalPages = 0;
        let pageAnnotations = new Map(); // Store annotations per page
        let isDrawing = false;
        let lastPoint = null;
        let isErasing = false;
        let inkPresenter = null;
        let lastTimestamp = 0;
        let currentSpeed = 0;
        let currentEraserSize = 20; // Default eraser size
        const minEraserSize = 10;
        const maxEraserSize = 130;
        let speedThreshold = 10; // Threshold before size starts increasing (adjustable)
        const defaultSpeedThreshold = 10; // Default threshold value
        let eraserSensitivity = 5; // How quickly eraser grows (1-10 scale)
        const defaultEraserSensitivity = 5; // Default sensitivity value
        let eraserDecreaseTimer = null;
        
        // Stroke size settings
        let currentStrokeSize = 2;
        const minStrokeSize = 1;
        const maxStrokeSize = 20;

        const pdfCanvas = document.getElementById('pdfCanvas');
        const inkCanvas = document.getElementById('inkCanvas');
        const eraserIndicator = document.getElementById('eraserIndicator');
        const pdfCtx = pdfCanvas.getContext('2d');
        const inkCtx = inkCanvas.getContext('2d');

        // Ink canvas setup
        inkCtx.strokeStyle = 'black';
        inkCtx.lineWidth = 2;
        inkCtx.lineCap = 'round';
        inkCtx.lineJoin = 'round';

        function resizeCanvases() {
            const rect = document.getElementById('pdfViewer').getBoundingClientRect();
            pdfCanvas.width = rect.width;
            pdfCanvas.height = rect.height;
            inkCanvas.width = rect.width;
            inkCanvas.height = rect.height;
        }

        async function loadPDF(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDocument = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = pdfDocument.numPages;
                currentPage = 1;
                
                document.getElementById('homescreen').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                resizeCanvases();
                renderPage(currentPage);
                setupInkEvents();
                
                // Initialize Lucide icons
                lucide.createIcons();
            } catch (error) {
                console.error('Error loading PDF:', error);
            }
        }

        async function renderPage(pageNum) {
            if (!pdfDocument) return;

            const page = await pdfDocument.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1 });
            
            // Calculate scale to fit the page to screen
            const scaleX = pdfCanvas.width / viewport.width;
            const scaleY = pdfCanvas.height / viewport.height;
            const scale = Math.min(scaleX, scaleY);
            
            const scaledViewport = page.getViewport({ scale });
            
            // Center the page
            const offsetX = (pdfCanvas.width - scaledViewport.width) / 2;
            const offsetY = (pdfCanvas.height - scaledViewport.height) / 2;
            
            // Clear and render PDF
            pdfCtx.fillStyle = 'white';
            pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            
            pdfCtx.save();
            pdfCtx.translate(offsetX, offsetY);
            
            await page.render({
                canvasContext: pdfCtx,
                viewport: scaledViewport
            }).promise;
            
            pdfCtx.restore();
            
            // Restore annotations for this page
            restorePageAnnotations(pageNum);
        }

        function savePageAnnotations(pageNum) {
            const imageData = inkCtx.getImageData(0, 0, inkCanvas.width, inkCanvas.height);
            pageAnnotations.set(pageNum, imageData);
        }

        function restorePageAnnotations(pageNum) {
            // Clear ink canvas
            inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
            
            // Restore annotations if they exist
            const annotations = pageAnnotations.get(pageNum);
            if (annotations) {
                inkCtx.putImageData(annotations, 0, 0);
            }
        }

        async function initWebInkAPI() {
            // Initialize Web Ink API if available
            if ('ink' in navigator) {
                try {
                    inkPresenter = await navigator.ink.requestPresenter({ 
                        presentationArea: inkCanvas 
                    });
                    console.log('Web Ink API initialized successfully');
                } catch (error) {
                    console.log('Web Ink API not available, falling back to canvas rendering:', error);
                    inkPresenter = null;
                }
            } else {
                console.log('Web Ink API not supported, using canvas fallback');
                inkPresenter = null;
            }
        }

        function setupInkEvents() {
            // Initialize Web Ink API
            initWebInkAPI();
            
            // Disable context menu
            inkCanvas.addEventListener('contextmenu', e => e.preventDefault());
            
            // Pointer events for Surface Pen
            inkCanvas.addEventListener('pointerdown', startDrawing);
            inkCanvas.addEventListener('pointermove', draw);
            inkCanvas.addEventListener('pointerup', stopDrawing);
            inkCanvas.addEventListener('pointerout', stopDrawing);
        }

        function calculateSpeed(currentPoint, currentTime) {
            if (!lastPoint || !lastTimestamp) {
                lastTimestamp = currentTime;
                return 0;
            }
            
            const distance = Math.sqrt(
                Math.pow(currentPoint.x - lastPoint.x, 2) + 
                Math.pow(currentPoint.y - lastPoint.y, 2)
            );
            
            const timeDelta = currentTime - lastTimestamp;
            const speed = timeDelta > 0 ? distance / (timeDelta / 16.67) : 0; // Pixels per frame (~60fps)
            
            lastTimestamp = currentTime;
            
            // Debug logging to see actual speed values
            console.log('Speed:', speed.toFixed(2), 'Distance:', distance.toFixed(2), 'TimeDelta:', timeDelta.toFixed(2));
            
            return speed;
        }

        function calculateEraserSize(speed) {
            // Much more responsive thresholds
            if (speed <= speedThreshold) {
                return minEraserSize;
            }
            
            // Map speed above threshold to size range
            const speedRange = Math.max(speed - speedThreshold, 0);
            const maxSpeedForMapping = 50; // Much lower max speed for easier triggering
            const normalizedSpeed = Math.min(speedRange / maxSpeedForMapping, 1);
            
            const size = minEraserSize + (normalizedSpeed * (maxEraserSize - minEraserSize));
            console.log('Calculated size:', size.toFixed(2), 'from speed:', speed.toFixed(2));
            
            return size;
        }

        function updateEraserSize(speed) {
            const targetSize = calculateEraserSize(speed);
            
            // Calculate sensitivity-based growth rate
            // Sensitivity 1 = 30% new size, Sensitivity 10 = 90% new size
            const sensitivityFactor = 0.2 + (eraserSensitivity / 10) * 0.7; // Maps 1-10 to 0.3-0.9
            
            // Asymmetric smoothing: adjustable increase, slow decrease when moving
            if (targetSize > currentEraserSize) {
                // Sensitivity-based response when size should increase
                currentEraserSize = currentEraserSize * (1 - sensitivityFactor) + targetSize * sensitivityFactor;
            } else if (speed > 1) {
                // Very slow response when size should decrease while moving
                currentEraserSize = currentEraserSize * 0.99 + targetSize * 0.01;
            } else {
                // Faster decrease when pen is stopped (speed near zero)
                currentEraserSize = currentEraserSize * 0.95 + minEraserSize * 0.05;
            }
            
            // Always update canvas line width immediately during erasing
            if (isErasing) {
                inkCtx.lineWidth = currentEraserSize;
            }
            
            // Update visual indicator to match the exact eraser area
            // For canvas strokes with round lineCap, the effective diameter is lineWidth
            const exactSize = Math.round(currentEraserSize);
            eraserIndicator.style.width = exactSize + 'px';
            eraserIndicator.style.height = exactSize + 'px';
            eraserIndicator.style.borderRadius = '50%';
            
            console.log('Current eraser size:', currentEraserSize.toFixed(2), 'Speed:', speed.toFixed(2), 'Sensitivity:', eraserSensitivity, 'Factor:', sensitivityFactor.toFixed(2), 'Canvas lineWidth:', inkCtx.lineWidth, 'Visual indicator:', exactSize);
        }

        function showEraserIndicator(x, y) {
            eraserIndicator.style.left = x + 'px';
            eraserIndicator.style.top = y + 'px';
            eraserIndicator.style.display = 'block';
        }

        function hideEraserIndicator() {
            eraserIndicator.style.display = 'none';
        }

        function updateEraserIndicator(e) {
            if (e.pointerType !== 'pen') return;
            
            const isBarrelPressed = (e.buttons & 32) !== 0;
            
            if (isBarrelPressed) {
                const rect = inkCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left + rect.left;
                const y = e.clientY - rect.top + rect.top;
                showEraserIndicator(x, y);
            } else {
                hideEraserIndicator();
            }
        }

        function startDrawing(e) {
            // Only allow pen input, disable finger/mouse
            if (e.pointerType !== 'pen') return;
            
            e.preventDefault();
            isDrawing = true;
            
            // Check if barrel button is pressed (button 32 = bit 5)
            isErasing = (e.buttons & 32) !== 0;
            
            const rect = inkCanvas.getBoundingClientRect();
            lastPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            // Reset speed tracking for new stroke
            lastTimestamp = performance.now();
            currentSpeed = 0;
            
            // Set up drawing context based on mode
            if (isErasing) {
                inkCtx.globalCompositeOperation = 'destination-out';
                currentEraserSize = minEraserSize; // Start with minimum size
                inkCtx.lineWidth = currentEraserSize;
                showEraserIndicator(e.clientX, e.clientY);
                updateEraserSize(0); // Initialize size
            } else {
                inkCtx.globalCompositeOperation = 'source-over';
                inkCtx.strokeStyle = 'black';
                inkCtx.lineWidth = currentStrokeSize;
            }
            
            inkCtx.beginPath();
            inkCtx.moveTo(lastPoint.x, lastPoint.y);
        }

        function draw(e) {
            if (!isDrawing || e.pointerType !== 'pen') return;
            
            e.preventDefault();
            
            const rect = inkCanvas.getBoundingClientRect();
            const currentPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            // Calculate speed and update eraser size if in eraser mode
            if (isErasing) {
                const currentTime = performance.now();
                currentSpeed = calculateSpeed(currentPoint, currentTime);
                updateEraserSize(currentSpeed);
                showEraserIndicator(e.clientX, e.clientY);
                
                // End current path and start new one with updated line width
                inkCtx.stroke();
                inkCtx.beginPath();
                inkCtx.moveTo(lastPoint.x, lastPoint.y);
            }
            
            inkCtx.lineTo(currentPoint.x, currentPoint.y);
            inkCtx.stroke();
            
            lastPoint = currentPoint;
        }

        function continueEraserDecrease() {
            if (currentEraserSize > minEraserSize + 0.5) {
                // Continue decreasing size more aggressively when stopped
                currentEraserSize = currentEraserSize * 0.95;
                
                // Update visual indicator
                const exactSize = Math.round(currentEraserSize);
                eraserIndicator.style.width = exactSize + 'px';
                eraserIndicator.style.height = exactSize + 'px';
                
                // Continue the animation
                eraserDecreaseTimer = requestAnimationFrame(continueEraserDecrease);
            } else {
                // Reached minimum size, hide indicator
                currentEraserSize = minEraserSize;
                hideEraserIndicator();
                eraserDecreaseTimer = null;
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            
            isDrawing = false;
            lastPoint = null;
            
            // Hide eraser indicator immediately when pen is lifted
            hideEraserIndicator();
            
            // Save annotations for current page
            savePageAnnotations(currentPage);
        }

        function nextPage() {
            if (currentPage < totalPages) {
                savePageAnnotations(currentPage);
                currentPage++;
                renderPage(currentPage);
            }
        }

        function prevPage() {
            if (currentPage > 1) {
                savePageAnnotations(currentPage);
                currentPage--;
                renderPage(currentPage);
            }
        }

        function clearAnnotations() {
            // Clear annotations for current page
            inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
            // Remove from stored annotations
            pageAnnotations.delete(currentPage);
        }

        function goHome() {
            document.getElementById('pdfViewer').style.display = 'none';
            document.getElementById('homescreen').style.display = 'flex';
            
            // Reset
            pdfDocument = null;
            currentPage = 1;
            totalPages = 0;
            pageAnnotations.clear();
            document.getElementById('fileInput').value = '';
        }

        // Drawer functions
        function toggleDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawerOverlay');
            
            if (drawer.classList.contains('open')) {
                closeDrawer();
            } else {
                openDrawer();
            }
        }

        function openDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawerOverlay');
            
            drawer.classList.add('open');
            overlay.classList.add('visible');
        }

        function closeDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawerOverlay');
            
            drawer.classList.remove('open');
            overlay.classList.remove('visible');
        }

        // Stroke size functions
        function increaseStrokeSize() {
            if (currentStrokeSize < maxStrokeSize) {
                currentStrokeSize++;
                updateStrokeSize();
            }
        }

        function decreaseStrokeSize() {
            if (currentStrokeSize > minStrokeSize) {
                currentStrokeSize--;
                updateStrokeSize();
            }
        }

        function updateStrokeSize() {
            // Update the display
            document.getElementById('strokeSizeValue').textContent = currentStrokeSize;
            
            // Update button states
            document.getElementById('decreaseBtn').disabled = currentStrokeSize <= minStrokeSize;
            document.getElementById('increaseBtn').disabled = currentStrokeSize >= maxStrokeSize;
            
            // Apply the new stroke size to drawing (not erasing)
            if (!isErasing && inkCtx) {
                inkCtx.lineWidth = currentStrokeSize;
            }
        }

        // Eraser threshold functions
        function increaseThreshold() {
            if (speedThreshold < 50) { // Max threshold of 50
                speedThreshold++;
                updateThreshold();
            }
        }

        function decreaseThreshold() {
            if (speedThreshold > 1) { // Min threshold of 1
                speedThreshold--;
                updateThreshold();
            }
        }

        function resetThreshold() {
            speedThreshold = defaultSpeedThreshold;
            updateThreshold();
        }

        function updateThreshold() {
            // Update the display
            document.getElementById('thresholdValue').textContent = speedThreshold;
            
            // Update button states
            document.getElementById('decreaseThresholdBtn').disabled = speedThreshold <= 1;
            document.getElementById('increaseThresholdBtn').disabled = speedThreshold >= 50;
        }

        // Eraser sensitivity functions
        function increaseSensitivity() {
            if (eraserSensitivity < 10) { // Max sensitivity of 10
                eraserSensitivity++;
                updateSensitivity();
            }
        }

        function decreaseSensitivity() {
            if (eraserSensitivity > 1) { // Min sensitivity of 1
                eraserSensitivity--;
                updateSensitivity();
            }
        }

        function resetSensitivity() {
            eraserSensitivity = defaultEraserSensitivity;
            updateSensitivity();
        }

        function updateSensitivity() {
            // Update the display
            document.getElementById('sensitivityValue').textContent = eraserSensitivity;
            
            // Update button states
            document.getElementById('decreaseSensitivityBtn').disabled = eraserSensitivity <= 1;
            document.getElementById('increaseSensitivityBtn').disabled = eraserSensitivity >= 10;
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('pdfViewer').style.display === 'block') {
                switch(e.key) {
                    case 'ArrowRight':
                    case 'ArrowDown':
                        e.preventDefault();
                        nextPage();
                        break;
                    case 'ArrowLeft':
                    case 'ArrowUp':
                        e.preventDefault();
                        prevPage();
                        break;
                    case 'Escape':
                        goHome();
                        break;
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (pdfDocument && document.getElementById('pdfViewer').style.display === 'block') {
                resizeCanvases();
                renderPage(currentPage);
            }
        });
    </script>
</body>
</html>
