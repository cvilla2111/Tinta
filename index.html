<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Drawing App - Stylus Only</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 10;
            touch-action: none; /* Prevent default touch behaviors */
        }
        .pdf-page-container {
            position: relative;
            margin: 0 auto;
        }
        .tool-active {
            background-color: #E5E7EB !important;
            color: #374151 !important;
        }
        .dark .tool-active {
            background-color: #4B5563 !important;
            color: #F3F4F6 !important;
        }
        .selected-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-size {
            background-color: #4B5563 !important;
        }
        .selected-eraser-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-eraser-size {
            background-color: #4B5563 !important;
        }


    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 min-h-screen">


    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
                <h1 class="text-2xl font-bold text-gray-900 dark:text-white">PDF Drawing App</h1>
                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">Stylus input only - Microsoft Pen Protocol required</p>
            </div>
            
            <!-- File Upload and Theme Toggle -->
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                <!-- Theme Toggle -->
                <div class="flex items-center gap-2">
                    <i data-lucide="sun" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="themeToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-gray-600"></div>
                    </label>
                    <i data-lucide="moon" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                </div>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 hidden sm:block"></div>
                
                <input type="file" id="pdfUpload" accept=".pdf" class="hidden">
                <button onclick="document.getElementById('pdfUpload').click()" 
                        class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-base">
                    Upload PDF
                </button>
                <button id="downloadBtn" onclick="downloadPDF()" 
                        class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-base" 
                        disabled>
                    Download
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div id="mainContent" class="max-w-7xl mx-auto">
        <!-- Initial Upload Area -->
        <div id="uploadArea" class="p-4">
            <div class="text-center">
                <div class="bg-gray-50 dark:bg-gray-800 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-12">
                    <div class="text-gray-400 dark:text-gray-500">
                        <svg class="mx-auto h-12 w-12 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                        </svg>
                        <p class="text-lg font-medium">No PDF loaded</p>
                        <p class="text-sm mt-2">Upload a PDF file to start drawing with your stylus</p>
                        <div class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <p class="text-sm text-blue-700 dark:text-blue-300">
                                <strong>Note:</strong> This app requires a Microsoft Pen Protocol stylus. Mouse and finger input are disabled for drawing.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Viewer Area (Full Screen) -->
        <div id="pdfViewer" class="hidden fixed inset-0 bg-white">
            <!-- Settings Modal -->
            <div id="settingsModal" class="fixed bottom-20 left-1/2 transform -translate-x-1/2 z-40 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-6 py-3 hidden">
                <!-- Pen Settings -->
                <div id="penSettings" class="hidden">
                    <!-- Brush Size Dots and Pressure Switch in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setBrushSize(1)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="1">
                            <div style="width: 1px; height: 1px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(2)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="2">
                            <div style="width: 2px; height: 2px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(4)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="4">
                            <div style="width: 4px; height: 4px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(6)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="6">
                            <div style="width: 6px; height: 6px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(8)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="8">
                            <div style="width: 8px; height: 8px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(11)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="11">
                            <div style="width: 11px; height: 11px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(14)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="14">
                            <div style="width: 14px; height: 14px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(16)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="16">
                            <div style="width: 16px; height: 16px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(18)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="18">
                            <div style="width: 18px; height: 18px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(20)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="20">
                            <div style="width: 20px; height: 20px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        
                        <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 mx-2"></div>
                        
                        <!-- Pressure Switch -->
                        <div class="flex items-center gap-2">
                            <i data-lucide="zap" class="w-3 h-3 text-gray-600 dark:text-gray-400"></i>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="pressureSwitch" class="sr-only peer" checked>
                                <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Pressure</span>
                        </div>
                    </div>
                </div>

                <!-- Color Settings -->
                <div id="colorSettings" class="hidden flex items-center gap-4">
                    <!-- Color Grid -->
                    <div class="grid grid-cols-10 gap-1">
                        <button onclick="setColor('#000000')" class="w-5 h-5 rounded-full bg-black border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#FFFFFF')" class="w-5 h-5 rounded-full bg-white border border-gray-400 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#6B7280')" class="w-5 h-5 rounded-full bg-gray-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EF4444')" class="w-5 h-5 rounded-full bg-red-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F97316')" class="w-5 h-5 rounded-full bg-orange-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F59E0B')" class="w-5 h-5 rounded-full bg-yellow-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#84CC16')" class="w-5 h-5 rounded-full bg-lime-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#10B981')" class="w-5 h-5 rounded-full bg-emerald-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#06B6D4')" class="w-5 h-5 rounded-full bg-cyan-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#3B82F6')" class="w-5 h-5 rounded-full bg-blue-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        
                        <button onclick="setColor('#6366F1')" class="w-5 h-5 rounded-full bg-indigo-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#8B5CF6')" class="w-5 h-5 rounded-full bg-violet-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#A855F7')" class="w-5 h-5 rounded-full bg-purple-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EC4899')" class="w-5 h-5 rounded-full bg-pink-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F43F5E')" class="w-5 h-5 rounded-full bg-rose-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#DC2626')" class="w-5 h-5 rounded-full bg-red-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#059669')" class="w-5 h-5 rounded-full bg-emerald-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#2563EB')" class="w-5 h-5 rounded-full bg-blue-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#7C3AED')" class="w-5 h-5 rounded-full bg-violet-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#92400E')" class="w-5 h-5 rounded-full bg-yellow-800 border border-gray-300 hover:scale-110 transition-transform"></button>
                    </div>
                </div>

                <!-- Eraser Settings -->
                <div id="eraserSettings" class="hidden">
                    <!-- Eraser Size Dots in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setEraserSize(4)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="4">
                            <div style="width: 4px; height: 4px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(12)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="12">
                            <div style="width: 12px; height: 12px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(25)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-eraser-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="25">
                            <div style="width: 25px; height: 25px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(35)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="35">
                            <div style="width: 35px; height: 35px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(50)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="50">
                            <div style="width: 50px; height: 50px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Bottom Toolbar -->
            <div id="floatingToolbar" class="fixed bottom-2 left-1/2 transform -translate-x-1/2 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-6 py-3 flex items-center gap-4">
                <!-- Tool Selection -->
                <button id="penTool" onclick="setTool('pen')" 
                        class="w-8 h-8 rounded-full flex items-center justify-center tool-active hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="pen-tool" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="eraserTool" onclick="setTool('eraser')" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="eraser" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="colorTool" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <div id="colorIndicator" class="w-5 h-5 rounded-full border-2 border-gray-400 dark:border-gray-500" style="background-color: #000000;"></div>
                </button>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600"></div>
                
                <!-- Actions -->
                <button onclick="clearCanvas()" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="trash-2" class="w-4 h-4 text-red-600 dark:text-red-400"></i>
                </button>
            </div>

            <!-- PDF Content -->
            <div id="pdfContent" class="w-full h-full flex items-center justify-center overflow-auto"></div>
        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Application state
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentBrushSize = 3;
        let currentEraserSize = 25;
        let pressureEnabled = true;
        let isDrawing = false;
        let drawingData = {}; // Store drawing data for each page with scale info
        let originalPageDimensions = {}; // Store original PDF page dimensions
        
        // Stylus eraser button state
        let originalTool = 'pen'; // Track the original tool before eraser button press
        let isEraserButtonPressed = false;

        // Double-click detection
        let lastClickTime = 0;
        let lastClickTarget = null;
        const DOUBLE_CLICK_DELAY = 300; // milliseconds

        // Drawing state
        let lastX = 0;
        let lastY = 0;

        // File upload handler
        document.getElementById('pdfUpload').addEventListener('change', handleFileUpload);

        // Settings event listeners
        function setupSettingsListeners() {
            // Pressure switch
            const pressureSwitch = document.getElementById('pressureSwitch');
            pressureSwitch.addEventListener('change', function() {
                pressureEnabled = this.checked;
            });

            // Theme toggle switch
            const themeToggle = document.getElementById('themeToggle');
            
            // Set initial state based on current theme
            themeToggle.checked = document.documentElement.classList.contains('dark');
            
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            // Tool buttons with double-click detection
            document.getElementById('penTool').addEventListener('pointerdown', handleToolDoubleClick);
            document.getElementById('eraserTool').addEventListener('pointerdown', handleToolDoubleClick);
            document.getElementById('colorTool').addEventListener('pointerdown', handleColorSingleClick);
        }

        // Brush size selection
        function setBrushSize(size) {
            currentBrushSize = size;
            
            // Update visual selection
            document.querySelectorAll('.brush-size-dot').forEach(btn => {
                btn.classList.remove('selected-size');
            });
            document.querySelector(`[data-size="${size}"]`).classList.add('selected-size');
            
            // Close modal after selection
            hideSettingsModal();
        }

        // Eraser size selection
        function setEraserSize(size) {
            currentEraserSize = size;
            
            // Update visual selection
            document.querySelectorAll('.eraser-size-dot').forEach(btn => {
                btn.classList.remove('selected-eraser-size');
            });
            document.querySelector(`[data-eraser-size="${size}"]`).classList.add('selected-eraser-size');
            
            // Close modal after selection
            hideSettingsModal();
        }

        // Handle double-click on tool buttons
        function handleToolDoubleClick(e) {
            if (e.pointerType !== 'pen') return;
            
            const currentTime = Date.now();
            const target = e.currentTarget;
            
            if (lastClickTarget === target && (currentTime - lastClickTime) < DOUBLE_CLICK_DELAY) {
                // Double-click detected
                e.preventDefault();
                const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                showSettingsModal(toolType);
            } else {
                // Single click - set tool
                setTimeout(() => {
                    if (Date.now() - currentTime >= DOUBLE_CLICK_DELAY) {
                        const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                        setTool(toolType);
                    }
                }, DOUBLE_CLICK_DELAY);
            }
            
            lastClickTime = currentTime;
            lastClickTarget = target;
        }

        // Handle single-click on color button
        function handleColorSingleClick(e) {
            if (e.pointerType !== 'pen') return;
            
            // Immediately show color picker on single tap
            e.preventDefault();
            showSettingsModal('color');
        }

        // Modal management
        function showSettingsModal(toolType) {
            const modal = document.getElementById('settingsModal');
            const penSettings = document.getElementById('penSettings');
            const eraserSettings = document.getElementById('eraserSettings');
            const colorSettings = document.getElementById('colorSettings');
            
            // Hide all settings panels
            penSettings.classList.add('hidden');
            eraserSettings.classList.add('hidden');
            colorSettings.classList.add('hidden');
            
            // Show the appropriate settings panel
            if (toolType === 'pen') {
                penSettings.classList.remove('hidden');
            } else if (toolType === 'eraser') {
                eraserSettings.classList.remove('hidden');
            } else if (toolType === 'color') {
                colorSettings.classList.remove('hidden');
            }
            
            // Show the modal
            modal.classList.remove('hidden');
        }

        function hideSettingsModal() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('hidden');
        }

        // Click outside modal to close
        document.addEventListener('pointerdown', function(e) {
            if (e.pointerType !== 'pen') return;
            
            const modal = document.getElementById('settingsModal');
            const toolbar = document.getElementById('floatingToolbar');
            
            if (!modal.contains(e.target) && !toolbar.contains(e.target) && !modal.classList.contains('hidden')) {
                hideSettingsModal();
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (!pdfDoc) return;
            
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                changePage(-1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                changePage(1);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closePDF();
            }
        });

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                drawingData = {}; // Reset drawing data
                
                // Hide upload area and header, show PDF viewer
                document.getElementById('uploadArea').style.display = 'none';
                document.querySelector('header').style.display = 'none';
                document.getElementById('pdfViewer').classList.remove('hidden');
                
                await renderPage(currentPage);
                document.getElementById('downloadBtn').disabled = false;
            } catch (error) {
                console.error('Error loading PDF:', error);
                showCustomAlert('Error loading PDF file. Please try again.');
            }
        }

        async function renderPage(pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const container = document.getElementById('pdfContent');
                
                // Calculate scale to fit the screen width (with small margin to prevent scrollbars)
                const containerWidth = window.innerWidth - 20; // Small margin to prevent overflow
                const viewport = page.getViewport({ scale: 1 });
                
                // Scale to fill the width while preventing overflow
                const scale = containerWidth / viewport.width;
                const scaledViewport = page.getViewport({ scale });

                // Create page container
                const pageContainer = document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.style.width = scaledViewport.width + 'px';
                pageContainer.style.height = scaledViewport.height + 'px';

                // Create and setup PDF canvas
                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;
                pdfCanvas.height = scaledViewport.height;
                pdfCanvas.style.display = 'block';

                // Create and setup drawing canvas
                const drawingCanvas = document.createElement('canvas');
                drawingCanvas.className = 'drawing-canvas';
                drawingCanvas.width = scaledViewport.width;
                drawingCanvas.height = scaledViewport.height;

                // Setup drawing event listeners
                setupDrawingEvents(drawingCanvas);

                // Clear container and add new elements
                container.innerHTML = '';
                pageContainer.appendChild(pdfCanvas);
                pageContainer.appendChild(drawingCanvas);
                container.appendChild(pageContainer);

                // Store original page dimensions for first render or if not stored
                if (!originalPageDimensions[pageNum]) {
                    originalPageDimensions[pageNum] = {
                        width: viewport.width,
                        height: viewport.height
                    };
                }

                // Render PDF page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;

                // Restore drawing data for this page with proper scaling
                if (drawingData[pageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    const img = new Image();
                    img.onload = function() {
                        // Calculate scaling factors based on canvas size changes
                        const scaleX = scaledViewport.width / drawingData[pageNum].canvasWidth;
                        const scaleY = scaledViewport.height / drawingData[pageNum].canvasHeight;
                        
                        // Scale and draw the image to fit the new canvas size
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                    };
                    img.src = drawingData[pageNum].imageData;
                }

            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }

        function setupDrawingEvents(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Create eraser indicator
            const eraserIndicator = document.createElement('div');
            eraserIndicator.id = 'eraserIndicator';
            eraserIndicator.style.cssText = `
                position: absolute;
                border: 2px dashed #666;
                border-radius: 50%;
                pointer-events: none;
                z-index: 15;
                display: none;
                background: rgba(255, 255, 255, 0.1);
            `;
            document.body.appendChild(eraserIndicator);

            // Pointer events for stylus detection
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', draw);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointerout', stopDrawing);
            canvas.addEventListener('pointercancel', stopDrawing);

            // Prevent default touch and mouse behaviors to avoid conflicts
            canvas.addEventListener('touchstart', e => e.preventDefault());
            canvas.addEventListener('touchmove', e => e.preventDefault());
            canvas.addEventListener('touchend', e => e.preventDefault());
            canvas.addEventListener('mousedown', e => e.preventDefault());
            canvas.addEventListener('mousemove', e => e.preventDefault());
            canvas.addEventListener('mouseup', e => e.preventDefault());

            function startDrawing(e) {
                // Only allow pen input (Microsoft Pen Protocol stylus)
                if (e.pointerType !== 'pen') {
                    return;
                }

                // Check for eraser button press (barrel button on stylus)
                // Common eraser button values: button 2 (right click) or button 5 (eraser)
                // Also check buttons bitmask for barrel button (bit 2 = 4)
                const eraserButtonPressed = e.button === 2 || e.button === 5 || (e.buttons & 4) !== 0;
                
                if (eraserButtonPressed && !isEraserButtonPressed) {
                    // Store original tool and switch to eraser
                    originalTool = currentTool;
                    isEraserButtonPressed = true;
                    if (currentTool !== 'eraser') {
                        setTool('eraser');
                    }
                } else if (!eraserButtonPressed && isEraserButtonPressed) {
                    // Restore original tool when eraser button is released
                    isEraserButtonPressed = false;
                    setTool(originalTool);
                }

                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                lastX = e.clientX - rect.left;
                lastY = e.clientY - rect.top;
                
                // Show eraser indicator if using eraser tool
                if (currentTool === 'eraser') {
                    showEraserIndicator(e.clientX, e.clientY);
                }
                
                // Update pressure indicator
                updatePressureIndicator(e.pressure || 0);
            }

            function draw(e) {
                // Only allow pen input
                if (e.pointerType !== 'pen' || !isDrawing) {
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                // Update eraser indicator position if using eraser tool
                if (currentTool === 'eraser') {
                    updateEraserIndicator(e.clientX, e.clientY);
                }

                ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                ctx.strokeStyle = currentColor;
                
                // Get pressure value for both tools
                const pressure = e.pressure || 0.5;
                
                // Use appropriate size based on tool
                const toolSize = currentTool === 'eraser' ? currentEraserSize : currentBrushSize;
                
                // Apply pressure only to pen tool, not eraser
                if (currentTool === 'eraser') {
                    // Eraser uses consistent size without pressure variation
                    ctx.lineWidth = toolSize;
                } else {
                    // Pen tool uses pressure for line width if enabled (pressure ranges from 0 to 1)
                    const pressureMultiplier = pressureEnabled ? (0.2 + (pressure * 1.8)) : 1.0; // Range from 0.2 to 2.0 or fixed at 1.0
                    ctx.lineWidth = toolSize * pressureMultiplier;
                }

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();

                lastX = currentX;
                lastY = currentY;
                
                // Update pressure indicator (but only for pen tool)
                if (currentTool === 'pen') {
                    updatePressureIndicator(pressure);
                }
            }

            function stopDrawing(e) {
                // Only process pen input
                if (e.pointerType !== 'pen') return;
                
                if (isDrawing) {
                    isDrawing = false;
                    // Save drawing data for current page with canvas dimensions
                    drawingData[currentPage] = {
                        imageData: canvas.toDataURL(),
                        canvasWidth: canvas.width,
                        canvasHeight: canvas.height
                    };
                    
                    // Hide eraser indicator
                    hideEraserIndicator();
                    
                    // Reset pressure indicator
                    updatePressureIndicator(0);
                }
            }

            function showEraserIndicator(clientX, clientY) {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator) {
                    const size = currentEraserSize;
                    indicator.style.width = size + 'px';
                    indicator.style.height = size + 'px';
                    indicator.style.left = (clientX - size/2) + 'px';
                    indicator.style.top = (clientY - size/2) + 'px';
                    indicator.style.display = 'block';
                }
            }

            function updateEraserIndicator(clientX, clientY) {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator && indicator.style.display === 'block') {
                    const size = currentEraserSize;
                    indicator.style.left = (clientX - size/2) + 'px';
                    indicator.style.top = (clientY - size/2) + 'px';
                }
            }

            function hideEraserIndicator() {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }
        }



        function updatePressureIndicator(pressure) {
            const indicator = document.getElementById('pressureIndicator');
            if (indicator) {
                const percentage = Math.round(pressure * 100);
                indicator.textContent = `Pressure: ${percentage}%`;
            }
        }

        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderPage(currentPage);
            }
        }

        function closePDF() {
            // Show upload area and header, hide PDF viewer
            document.getElementById('uploadArea').style.display = 'block';
            document.querySelector('header').style.display = 'block';
            document.getElementById('pdfViewer').classList.add('hidden');
            
            // Reset state
            pdfDoc = null;
            currentPage = 1;
            totalPages = 0;
            drawingData = {};
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('pdfUpload').value = '';
        }

        function setTool(tool) {
            currentTool = tool;
            
            // Update tool buttons
            document.querySelectorAll('#penTool, #eraserTool').forEach(btn => {
                btn.classList.remove('tool-active');
            });
            
            if (tool === 'pen') {
                document.getElementById('penTool').classList.add('tool-active');
            } else if (tool === 'eraser') {
                document.getElementById('eraserTool').classList.add('tool-active');
            }

            // Update cursor
            const canvas = document.querySelector('.drawing-canvas');
            if (canvas) {
                canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            }
        }

        function setColor(color) {
            currentColor = color;
            
            // Update color indicator
            const colorIndicator = document.getElementById('colorIndicator');
            if (colorIndicator) {
                colorIndicator.style.backgroundColor = color;
            }
            
            // Close modal after selection
            hideSettingsModal();
        }

        function clearCanvas() {
            showConfirmDialog('Are you sure you want to clear all drawings on this page?', () => {
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    delete drawingData[currentPage];
                }
            });
        }

        async function downloadPDF() {
            if (!pdfDoc) return;

            try {
                if (drawingData[currentPage]) {
                    const link = document.createElement('a');
                    link.download = `pdf-drawing-page-${currentPage}.png`;
                    link.href = drawingData[currentPage].imageData;
                    link.click();
                } else {
                    showCustomAlert('No drawings found on current page to download.');
                }
                
            } catch (error) {
                console.error('Error downloading:', error);
                showCustomAlert('Error downloading the file.');
            }
        }

        // Custom dialog functions (replacing alert/confirm)
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-primary text-white hover:bg-primary/90 rounded text-base" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showConfirmDialog(message, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base" onclick="this.closest('.fixed').remove()">Cancel</button>
                        <button class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded text-base" onclick="this.closest('.fixed').remove(); (${onConfirm})()">Confirm</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Initialize Lucide icons
        function initializeLucideIcons() {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                // Retry after a short delay if Lucide isn't loaded yet
                setTimeout(initializeLucideIcons, 100);
            }
        }
        
        // Initialize icons when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeLucideIcons();
            setupSettingsListeners();
        });
        
        // Also initialize when PDF viewer is shown
        const originalRenderPage = renderPage;
        renderPage = async function(pageNum) {
            await originalRenderPage(pageNum);
            initializeLucideIcons();
        };

        // Handle window resize for responsive behavior with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                // Clear existing timeout
                clearTimeout(resizeTimeout);
                
                // Set new timeout to prevent excessive re-rendering
                resizeTimeout = setTimeout(() => {
                    renderPage(currentPage);
                }, 250); // Wait 250ms after resize stops
            }
        });
    </script>
</body>
</html>
