<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing App</title>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Monaco, Inconsolata, "Roboto Mono", monospace;
            background: #ffffff;
            color: #000000;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 3rem;
            background: white;
            border-bottom: 1px solid #d1d5db;
            z-index: 20;
            display: flex;
            align-items: center;
            padding: 0 1rem;
        }

        .header-title {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Hamburger menu */
        .hamburger {
            padding: 0.5rem;
            margin-right: 0.75rem;
            background: none;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }

        .hamburger:hover {
            background: #f3f4f6;
        }

        .hamburger.open {
            transform: rotate(90deg);
        }

        .hamburger-line {
            width: 1.25rem;
            height: 0.125rem;
            background: black;
            margin-bottom: 0.25rem;
        }

        .hamburger-line:last-child {
            margin-bottom: 0;
        }

        /* Side menu */
        .side-menu {
            position: fixed;
            left: 0;
            top: 3rem;
            bottom: 0;
            width: 16rem;
            background: white;
            border-right: 1px solid #d1d5db;
            z-index: 10;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform 0.2s ease;
            will-change: transform;
        }

        .side-menu.open {
            transform: translateX(0);
        }

        .menu-content {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-section h3 {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .section-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Tool buttons */
        .tool-btn {
            width: 100%;
            text-align: left;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.25rem;
            border: 1px solid #e5e7eb;
            background: white;
            cursor: pointer;
            transition: background-color 0.1s ease;
        }

        .tool-btn:hover {
            background-color: #f5f5f5;
        }

        .tool-btn.active {
            background-color: #e5e5e5;
        }

        /* Range input */
        .range-container {
            display: flex;
            flex-direction: column;
        }

        .range-input {
            width: 100%;
            height: 0.25rem;
            background: #d1d5db;
            border-radius: 0.5rem;
            appearance: none;
            cursor: pointer;
            outline: none;
        }

        .range-input::-webkit-slider-thumb {
            appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        .range-input::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }

        .range-value {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        /* Status indicators */
        .status-text {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .input-details {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-indicator {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background: #9ca3af;
        }

        .input-info {
            font-size: 0.75rem;
            color: #6b7280;
            font-family: ui-monospace, monospace;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .device-type {
            color: #6b7280;
        }

        .button-state {
            color: #9ca3af;
        }

        /* Canvas area */
        .canvas-container {
            position: fixed;
            top: 3rem;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            overflow: hidden;
        }

        #drawingCanvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        /* Filter status */
        .filter-status {
            font-size: 0.75rem;
            color: #6b7280;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Color variants for indicators */
        .bg-red-500 { background: #ef4444; }
        .bg-blue-500 { background: #3b82f6; }
        .bg-green-500 { background: #10b981; }
        .bg-orange-500 { background: #f59e0b; }
        .bg-gray-400 { background: #9ca3af; }

        /* Eraser indicator */
        .eraser-indicator {
            position: fixed;
            border: 1px solid #6b7280;
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
            background: rgba(107, 114, 128, 0.1);
            transform: translate(-50%, -50%);
            display: none;
        }

        .hidden {
            display: none;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .side-menu {
                width: 20rem;
            }
            
            .header {
                padding: 0 0.5rem;
            }
            
            .header-title {
                font-size: 0.75rem;
            }
            
            .input-info {
                display: none;
            }
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body>
    <!-- Header -->
    <div class="header">
        <button id="menuToggle" class="hamburger">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </button>
        <span class="header-title">Drawing App</span>
        <div class="header-right">
            <span id="statusText" class="status-text">Ready</span>
            <div id="inputDetails" class="input-details">
                <div id="inputIndicator" class="input-indicator"></div>
                <div id="inputInfo" class="input-info">
                    <div id="deviceType" class="device-type">-</div>
                    <div id="buttonState" class="button-state">-</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="sideMenu" class="side-menu">
        <div class="menu-content">
            <!-- Tools -->
            <div class="menu-section">
                <h3>Tools</h3>
                <div class="section-content">
                    <button id="penTool" class="tool-btn active">Pen</button>
                    <button id="eraserTool" class="tool-btn">Eraser</button>
                </div>
            </div>

            <!-- Stroke Width -->
            <div class="menu-section">
                <h3>Stroke Width</h3>
                <div class="range-container">
                    <input type="range" id="strokeWidth" min="1" max="20" value="2" class="range-input">
                    <div class="range-value">
                        <span id="strokeWidthValue">2</span>px
                    </div>
                </div>
            </div>

            <!-- Smoothing -->
            <div class="menu-section">
                <h3>Smoothing</h3>
                <div class="section-content">
                    <button id="smoothingToggle" class="tool-btn active">Quadratic Smoothing: ON</button>
                </div>
                <div class="range-container" style="margin-top: 0.5rem;">
                    <label style="font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem;">Smoothing Threshold</label>
                    <input type="range" id="smoothingThreshold" min="1" max="10" value="3" class="range-input">
                    <div class="range-value">
                        <span id="smoothingThresholdValue">3</span>px
                    </div>
                </div>
            </div>

            <!-- Dynamic Eraser -->
            <div class="menu-section">
                <h3>Dynamic Eraser</h3>
                <div class="section-content">
                    <button id="dynamicEraserToggle" class="tool-btn active">Speed Dynamic: ON</button>
                </div>
                <div class="range-container" style="margin-top: 0.5rem;">
                    <label style="font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem;">Min Size</label>
                    <input type="range" id="eraserMinSize" min="1" max="15" value="2" class="range-input">
                    <div class="range-value">
                        <span id="eraserMinSizeValue">2</span>px
                    </div>
                </div>
                <div class="range-container" style="margin-top: 0.5rem;">
                    <label style="font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem;">Max Size</label>
                    <input type="range" id="eraserMaxSize" min="5" max="200" value="20" class="range-input">
                    <div class="range-value">
                        <span id="eraserMaxSizeValue">20</span>px
                    </div>
                </div>
                <div class="range-container" style="margin-top: 0.5rem;">
                    <label style="font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem;">Sensitivity</label>
                    <input type="range" id="eraserSensitivity" min="1" max="10" value="5" class="range-input">
                    <div class="range-value">
                        <span id="eraserSensitivityValue">5</span>
                    </div>
                </div>
                <div class="filter-status" style="margin-top: 0.5rem;">
                    <div>Current Size: <span id="currentEraserSize">2</span>px</div>
                    <div>Speed: <span id="currentSpeed">0</span> px/s</div>
                </div>
            </div>



            <!-- Actions -->
            <div class="menu-section">
                <h3>Actions</h3>
                <div class="section-content">
                    <button id="clearBtn" class="tool-btn">Clear All</button>
                    <button id="undoBtn" class="tool-btn">Undo</button>
                </div>
            </div>

            <!-- Input Filter Status -->
            <div class="menu-section">
                <h3>Input Filter</h3>
                <div class="filter-status">
                    <div>✓ Pen Enabled</div>
                    <div>✓ Mouse Enabled</div>
                    <div>✗ Touch Disabled</div>
                </div>
            </div>

            <!-- Worker Controls -->
            <div class="menu-section">
                <h3>Web Worker</h3>
                <div class="section-content">
                    <button id="inlineWorkerBtn" class="tool-btn">Use Inline Worker</button>
                    <button id="fileWorkerBtn" class="tool-btn">Use File Worker</button>
                    <button id="noWorkerBtn" class="tool-btn">Disable Worker</button>
                </div>
                <div class="filter-status" style="margin-top: 0.5rem;">
                    <div id="workerStatus">Status: <span id="workerStatusValue">Initializing...</span></div>
                    <div id="workerType">Type: <span id="workerTypeValue">-</span></div>
                    <div id="workerActive">Active: <span id="workerActiveValue">-</span></div>
                </div>
                <div style="margin-top: 0.5rem;">
                    <button id="testWorkerBtn" class="tool-btn" style="font-size: 0.75rem;">Test Worker</button>
                </div>
            </div>

            <!-- DPR Info -->
            <div class="menu-section">
                <h3>Display Info</h3>
                <div class="filter-status">
                    <div id="dprInfo">DPR: <span id="dprValue">-</span></div>
                    <div id="canvasSize">Canvas: <span id="canvasSizeValue">-</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div id="canvasContainer" class="canvas-container">
        <canvas id="drawingCanvas"></canvas>
        <!-- Eraser indicator -->
        <div id="eraserIndicator" class="eraser-indicator"></div>
    </div>

    <script>
        // Canvas and drawing state
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let currentTool = 'pen';
        let strokeWidth = 2;
        let strokes = [];
        let currentStroke = [];
        
        // Smoothing settings
        let smoothingEnabled = true;
        let smoothingThreshold = 3;
        
        // Dynamic eraser settings
        let dynamicEraserEnabled = true;
        let eraserMinSize = 2;
        let eraserMaxSize = 20;
        let eraserSensitivity = 5;
        let currentEraserSize = 2;
        let targetEraserSize = 2;
        
        // Speed tracking for dynamic eraser
        let lastMousePos = null;
        let lastMouseTime = 0;
        let currentSpeed = 0;
        let lastSpeedUpdateTime = 0;
        
        // Smooth animation variables
        let smoothingAnimationId = null;
        
        // Antialiasing - permanently disabled to use native AA
        let antialiasingEnabled = false;
        
        // UI elements
        const menuToggle = document.getElementById('menuToggle');
        const sideMenu = document.getElementById('sideMenu');
        const statusText = document.getElementById('statusText');
        const inputIndicator = document.getElementById('inputIndicator');
        const deviceType = document.getElementById('deviceType');
        const buttonState = document.getElementById('buttonState');
        const eraserIndicator = document.getElementById('eraserIndicator');
        
        // DPR Detection and Canvas Setup
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            // Set display size
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Set actual size accounting for DPR
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Scale context to ensure correct drawing operations
            ctx.scale(dpr, dpr);
            
            // Set canvas style with antialiasing
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Enable antialiasing for drawing
            if (ctx.webkitImageSmoothingEnabled !== undefined) {
                ctx.webkitImageSmoothingEnabled = true;
            }
            if (ctx.mozImageSmoothingEnabled !== undefined) {
                ctx.mozImageSmoothingEnabled = true;
            }
            if (ctx.msImageSmoothingEnabled !== undefined) {
                ctx.msImageSmoothingEnabled = true;
            }
            
            // Update DPR info
            document.getElementById('dprValue').textContent = dpr.toFixed(2);
            document.getElementById('canvasSizeValue').textContent = `${canvas.width}×${canvas.height}`;
            
            statusText.textContent = `Canvas ready (DPR: ${dpr})`;
        }
        
        // Resize canvas when window resizes
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();
            
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            setupCanvas();
            redrawCanvas();
        }
        
        // Store original tool for stylus eraser switching
        let originalTool = 'pen';
        let isUsingStylesEraser = false;
        
        // Input filtering - only allow pen and mouse
        function isValidInput(event) {
            const pointerType = event.pointerType;
            
            // Block touch input
            if (pointerType === 'touch') {
                updateInputIndicator('TOUCH', 'BLOCKED', 'bg-red-500');
                return false;
            }
            
            // Handle pen input (including stylus eraser)
            if (pointerType === 'pen') {
                const pressure = event.pressure || 0;
                const button = event.button;
                const buttons = event.buttons;
                
                // Detect stylus eraser (button 5 or buttons with eraser flag)
                const isEraserEnd = button === 5 || (buttons & 32) === 32;
                
                if (isEraserEnd) {
                    // Using eraser end of stylus
                    if (!isUsingStylesEraser) {
                        // First time using eraser end - switch to eraser tool
                        originalTool = currentTool;
                        setTool('eraser');
                        isUsingStylesEraser = true;
                        statusText.textContent = 'Stylus eraser detected - switched to eraser';
                    }
                    updateInputIndicator('PEN', `ERASER P:${Math.round(pressure * 100)}%`, 'bg-orange-500');
                } else {
                    // Using normal pen tip
                    if (isUsingStylesEraser) {
                        // Switch back to original tool
                        setTool(originalTool);
                        isUsingStylesEraser = false;
                        statusText.textContent = `Stylus tip detected - switched back to ${originalTool}`;
                    }
                    updateInputIndicator('PEN', `TIP P:${Math.round(pressure * 100)}%`, 'bg-blue-500');
                }
                
                return true;
            }
            
            if (pointerType === 'mouse') {
                const buttons = event.buttons;
                const buttonText = buttons === 1 ? 'L' : buttons === 2 ? 'R' : buttons === 4 ? 'M' : '-';
                updateInputIndicator('MOUSE', buttonText, 'bg-green-500');
                return true;
            }
            
            // Block unknown input types
            updateInputIndicator('OTHER', 'Unknown', 'bg-orange-500');
            return false;
        }
        
        // Update input indicator
        function updateInputIndicator(device, state, colorClass) {
            deviceType.textContent = device;
            buttonState.textContent = state;
            inputIndicator.className = 'input-indicator ' + colorClass;
        }
        
        // Get coordinates relative to canvas
        function getCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }
        
        // Drawing state for smoothing
        let lastPoint = null;
        let lastMidPoint = null;
        
        // Drawing functions with quadratic smoothing (no pressure sensitivity)
        function startDrawing(event) {
            if (!isValidInput(event)) {
                event.preventDefault();
                return false;
            }
            
            isDrawing = true;
            const coords = getCoordinates(event);
            
            // Reset eraser size to minimum at start of new stroke
            if (currentTool === 'eraser' && dynamicEraserEnabled) {
                currentEraserSize = eraserMinSize;
                targetEraserSize = eraserMinSize;
                document.getElementById('currentEraserSize').textContent = currentEraserSize;
                currentSpeed = 0;
                document.getElementById('currentSpeed').textContent = currentSpeed;
            }
            
            currentStroke = [{
                x: coords.x,
                y: coords.y,
                tool: currentTool,
                width: strokeWidth
            }];
            
            // Initialize smoothing variables
            lastPoint = { x: coords.x, y: coords.y };
            lastMidPoint = null;
            
            // Set drawing style - use dynamic eraser size if enabled
            const activeStrokeWidth = (currentTool === 'eraser' && dynamicEraserEnabled) ? currentEraserSize : strokeWidth;
            ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
            ctx.strokeStyle = currentTool === 'eraser' ? 'rgba(0,0,0,1)' : '#000000';
            ctx.lineWidth = activeStrokeWidth;
            
            // Begin path
            ctx.beginPath();
            ctx.moveTo(coords.x, coords.y);
            
            event.preventDefault();
            return true;
        }
        
        // Minimal drawing function that enables native AA
        function drawWithAntialiasing(startPoint, endPoint, width, tool) {
            // Always use native AA (antialiasingEnabled is permanently false)
            ctx.lineWidth = width;
            ctx.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            ctx.strokeStyle = tool === 'eraser' ? 'rgba(0,0,0,1)' : '#000000';
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
        }

        function draw(event) {
            if (!isDrawing || !isValidInput(event)) {
                return;
            }
            
            const coords = getCoordinates(event);
            const currentPoint = { x: coords.x, y: coords.y };
            
            // Add point to current stroke
            currentStroke.push({
                x: coords.x,
                y: coords.y,
                tool: currentTool,
                width: strokeWidth
            });
            
            if (lastPoint) {
                // Check distance for smoothing threshold
                const distance = Math.sqrt(
                    Math.pow(currentPoint.x - lastPoint.x, 2) + 
                    Math.pow(currentPoint.y - lastPoint.y, 2)
                );
                
                // Use lower threshold for eraser to make it more responsive
                const activeThreshold = currentTool === 'eraser' ? 1 : smoothingThreshold;
                
                if (smoothingEnabled && distance >= activeThreshold) {
                    // Calculate midpoint between last point and current point
                    const midPoint = {
                        x: (lastPoint.x + currentPoint.x) / 2,
                        y: (lastPoint.y + currentPoint.y) / 2
                    };
                    
                    if (lastMidPoint) {
                        // Standard quadratic curve (native AA) - use dynamic eraser size if enabled
                        const activeStrokeWidth = (currentTool === 'eraser' && dynamicEraserEnabled) ? currentEraserSize : strokeWidth;
                        ctx.lineWidth = activeStrokeWidth;
                        ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                        ctx.strokeStyle = currentTool === 'eraser' ? 'rgba(0,0,0,1)' : '#000000';
                        ctx.beginPath();
                        ctx.moveTo(lastMidPoint.x, lastMidPoint.y);
                        ctx.quadraticCurveTo(lastPoint.x, lastPoint.y, midPoint.x, midPoint.y);
                        ctx.stroke();
                    } else {
                        // First segment - use dynamic eraser size if enabled
                        const activeStrokeWidth = (currentTool === 'eraser' && dynamicEraserEnabled) ? currentEraserSize : strokeWidth;
                        drawWithAntialiasing(lastPoint, midPoint, activeStrokeWidth, currentTool);
                    }
                    
                    // Update for next iteration
                    lastMidPoint = midPoint;
                } else if (!smoothingEnabled) {
                    // Direct line drawing
                    drawWithAntialiasing(lastPoint, currentPoint, strokeWidth, currentTool);
                }
            }
            
            lastPoint = currentPoint;
            event.preventDefault();
        }
        
        function stopDrawing(event) {
            if (!isDrawing) return;
            
            isDrawing = false;
            
            // Save stroke to history
            if (currentStroke.length > 0) {
                strokes.push([...currentStroke]);
                statusText.textContent = `Stroke completed (${strokes.length} total)`;
            }
            
            currentStroke = [];
            updateInputIndicator('-', '-', 'bg-gray-400');
            
            event.preventDefault();
        }
        
        // Redraw entire canvas with quadratic smoothing (no pressure sensitivity)
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                
                // Set drawing style for this stroke
                ctx.globalCompositeOperation = stroke[0].tool === 'eraser' ? 'destination-out' : 'source-over';
                ctx.strokeStyle = stroke[0].tool === 'eraser' ? 'rgba(0,0,0,1)' : '#000000';
                ctx.lineWidth = stroke[0].width;
                
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                
                if (stroke.length === 2) {
                    // Just two points - draw a line
                    ctx.lineTo(stroke[1].x, stroke[1].y);
                    ctx.stroke();
                } else {
                    // Multiple points - use quadratic smoothing
                    let lastMidPoint = null;
                    
                    for (let i = 1; i < stroke.length; i++) {
                        const lastPoint = stroke[i - 1];
                        const currentPoint = stroke[i];
                        
                        // Calculate midpoint
                        const midPoint = {
                            x: (lastPoint.x + currentPoint.x) / 2,
                            y: (lastPoint.y + currentPoint.y) / 2
                        };
                        
                        if (i === 1) {
                            // First segment
                            ctx.lineTo(midPoint.x, midPoint.y);
                        } else {
                            // Quadratic curve from last midpoint to current midpoint
                            ctx.quadraticCurveTo(lastPoint.x, lastPoint.y, midPoint.x, midPoint.y);
                        }
                        
                        lastMidPoint = midPoint;
                    }
                    
                    // Draw final segment to last point
                    if (lastMidPoint && stroke.length > 2) {
                        const lastPoint = stroke[stroke.length - 1];
                        ctx.quadraticCurveTo(stroke[stroke.length - 2].x, stroke[stroke.length - 2].y, lastPoint.x, lastPoint.y);
                    }
                    
                    ctx.stroke();
                }
            });
        }
        
        // Event listeners for canvas
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerout', stopDrawing);
        canvas.addEventListener('pointercancel', stopDrawing);
        
        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Menu toggle functionality
        menuToggle.addEventListener('click', () => {
            const isOpen = sideMenu.classList.toggle('open');
            menuToggle.classList.toggle('open', isOpen);
            statusText.textContent = isOpen ? 'Menu opened' : 'Ready';
        });
        
        // Tool selection
        document.getElementById('penTool').addEventListener('click', () => setTool('pen'));
        document.getElementById('eraserTool').addEventListener('click', () => setTool('eraser'));
        
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
            
            canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            statusText.textContent = `${tool.charAt(0).toUpperCase() + tool.slice(1)} selected`;
            
            // Update eraser indicator
            updateEraserIndicator();
        }
        
        // Calculate dynamic eraser size based on speed
        function calculateDynamicEraserSize(speed) {
            if (!dynamicEraserEnabled || currentTool !== 'eraser') {
                return currentTool === 'eraser' ? strokeWidth : strokeWidth;
            }
            
            // Normalize speed (0-1000+ px/s to 0-1)
            const normalizedSpeed = Math.min(speed / (eraserSensitivity * 100), 1);
            
            // Interpolate between min and max size
            const size = eraserMinSize + (eraserMaxSize - eraserMinSize) * normalizedSpeed;
            
            return Math.round(size);
        }
        
        // Update eraser indicator size and visibility - only show when drawing
        function updateEraserIndicator() {
            if (currentTool === 'eraser' && isDrawing) {
                const size = dynamicEraserEnabled ? currentEraserSize : strokeWidth;
                eraserIndicator.style.width = size + 'px';
                eraserIndicator.style.height = size + 'px';
                eraserIndicator.style.display = 'block';
            } else {
                eraserIndicator.style.display = 'none';
            }
        }
        
        // Smooth eraser size animation function
        function animateEraserSize() {
            if (currentTool !== 'eraser' || !dynamicEraserEnabled) {
                if (smoothingAnimationId) {
                    cancelAnimationFrame(smoothingAnimationId);
                    smoothingAnimationId = null;
                }
                return;
            }
            
            // Smooth interpolation towards target size
            const sizeDiff = targetEraserSize - currentEraserSize;
            if (Math.abs(sizeDiff) > 0.1) {
                currentEraserSize += sizeDiff * 0.15; // Smooth transition speed
                
                // Update UI and indicator
                document.getElementById('currentEraserSize').textContent = Math.round(currentEraserSize);
                updateEraserIndicator();
                
                // Continue animation
                smoothingAnimationId = requestAnimationFrame(animateEraserSize);
            } else {
                // Close enough, snap to target
                currentEraserSize = targetEraserSize;
                document.getElementById('currentEraserSize').textContent = Math.round(currentEraserSize);
                updateEraserIndicator();
                smoothingAnimationId = null;
            }
        }
        
        // Start eraser decay animation (return to min size)
        function startEraserDecay() {
            if (currentTool !== 'eraser' || !dynamicEraserEnabled) return;
            
            // Gradually decay back to minimum size
            const decayStep = () => {
                const currentTime = performance.now();
                const timeSinceLastUpdate = currentTime - lastSpeedUpdateTime;
                
                // If no movement for 300ms, start decaying
                if (timeSinceLastUpdate > 300) {
                    targetEraserSize = eraserMinSize;
                    
                    // Start smooth animation if not already running
                    if (!smoothingAnimationId) {
                        animateEraserSize();
                    }
                } else {
                    // Check again soon
                    setTimeout(decayStep, 50);
                }
            };
            
            setTimeout(decayStep, 50);
        }
        
        // Update eraser indicator position and calculate speed
        function updateEraserPosition(event) {
            if (currentTool === 'eraser') {
                const currentTime = performance.now();
                const currentPos = { x: event.clientX, y: event.clientY };
                
                // Calculate speed for dynamic sizing
                if (lastMousePos && lastMouseTime) {
                    const deltaTime = currentTime - lastMouseTime;
                    const deltaX = currentPos.x - lastMousePos.x;
                    const deltaY = currentPos.y - lastMousePos.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (deltaTime > 0) {
                        currentSpeed = Math.round((distance / deltaTime) * 1000); // px/s
                        lastSpeedUpdateTime = currentTime;
                        
                        if (dynamicEraserEnabled) {
                            // Set target size instead of immediate size
                            targetEraserSize = calculateDynamicEraserSize(currentSpeed);
                            
                            // Update UI indicators
                            document.getElementById('currentSpeed').textContent = currentSpeed;
                            
                            // Start smooth animation if not already running
                            if (!smoothingAnimationId) {
                                animateEraserSize();
                            }
                            
                            // Start decay timer
                            startEraserDecay();
                        }
                    }
                }
                
                // Update position
                eraserIndicator.style.left = event.clientX + 'px';
                eraserIndicator.style.top = event.clientY + 'px';
                
                // Store current position and time for next calculation
                lastMousePos = currentPos;
                lastMouseTime = currentTime;
            }
        }
        
        // Stroke width control
        const strokeWidthSlider = document.getElementById('strokeWidth');
        strokeWidthSlider.addEventListener('input', (e) => {
            strokeWidth = parseInt(e.target.value);
            document.getElementById('strokeWidthValue').textContent = strokeWidth;
            statusText.textContent = `Stroke width: ${strokeWidth}px`;
            updateEraserIndicator(); // Update eraser size
        });
        
        // Smoothing controls
        document.getElementById('smoothingToggle').addEventListener('click', () => {
            smoothingEnabled = !smoothingEnabled;
            const toggleBtn = document.getElementById('smoothingToggle');
            if (smoothingEnabled) {
                toggleBtn.textContent = 'Quadratic Smoothing: ON';
                toggleBtn.classList.add('active');
                statusText.textContent = 'Smoothing enabled';
            } else {
                toggleBtn.textContent = 'Quadratic Smoothing: OFF';
                toggleBtn.classList.remove('active');
                statusText.textContent = 'Smoothing disabled';
            }
        });
        
        const smoothingThresholdSlider = document.getElementById('smoothingThreshold');
        smoothingThresholdSlider.addEventListener('input', (e) => {
            smoothingThreshold = parseInt(e.target.value);
            document.getElementById('smoothingThresholdValue').textContent = smoothingThreshold;
            statusText.textContent = `Smoothing threshold: ${smoothingThreshold}px`;
        });

        // Dynamic eraser controls
        document.getElementById('dynamicEraserToggle').addEventListener('click', () => {
            dynamicEraserEnabled = !dynamicEraserEnabled;
            const toggleBtn = document.getElementById('dynamicEraserToggle');
            if (dynamicEraserEnabled) {
                toggleBtn.textContent = 'Speed Dynamic: ON';
                toggleBtn.classList.add('active');
                statusText.textContent = 'Dynamic eraser enabled';
            } else {
                toggleBtn.textContent = 'Speed Dynamic: OFF';
                toggleBtn.classList.remove('active');
                statusText.textContent = 'Dynamic eraser disabled';
                currentEraserSize = strokeWidth; // Reset to normal size
                updateEraserIndicator();
            }
        });

        const eraserMinSizeSlider = document.getElementById('eraserMinSize');
        eraserMinSizeSlider.addEventListener('input', (e) => {
            eraserMinSize = parseInt(e.target.value);
            document.getElementById('eraserMinSizeValue').textContent = eraserMinSize;
            
            // Ensure max size is always greater than min size
            if (eraserMaxSize <= eraserMinSize) {
                eraserMaxSize = eraserMinSize + 1;
                document.getElementById('eraserMaxSize').value = eraserMaxSize;
                document.getElementById('eraserMaxSizeValue').textContent = eraserMaxSize;
            }
            
            statusText.textContent = `Eraser min size: ${eraserMinSize}px`;
        });

        const eraserMaxSizeSlider = document.getElementById('eraserMaxSize');
        eraserMaxSizeSlider.addEventListener('input', (e) => {
            eraserMaxSize = parseInt(e.target.value);
            document.getElementById('eraserMaxSizeValue').textContent = eraserMaxSize;
            
            // Ensure min size is always less than max size
            if (eraserMinSize >= eraserMaxSize) {
                eraserMinSize = eraserMaxSize - 1;
                document.getElementById('eraserMinSize').value = eraserMinSize;
                document.getElementById('eraserMinSizeValue').textContent = eraserMinSize;
            }
            
            statusText.textContent = `Eraser max size: ${eraserMaxSize}px`;
        });

        const eraserSensitivitySlider = document.getElementById('eraserSensitivity');
        eraserSensitivitySlider.addEventListener('input', (e) => {
            eraserSensitivity = parseInt(e.target.value);
            document.getElementById('eraserSensitivityValue').textContent = eraserSensitivity;
            statusText.textContent = `Eraser sensitivity: ${eraserSensitivity}`;
        });

        
        // Clear canvas
        document.getElementById('clearBtn').addEventListener('click', () => {
            strokes = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            statusText.textContent = 'Canvas cleared';
        });
        
        // Undo last stroke
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (strokes.length > 0) {
                strokes.pop();
                redrawCanvas();
                statusText.textContent = `Undone (${strokes.length} strokes remaining)`;
            } else {
                statusText.textContent = 'Nothing to undo';
            }
        });
        
        // Worker control event listeners
        document.getElementById('inlineWorkerBtn').addEventListener('click', switchToInlineWorker);
        document.getElementById('fileWorkerBtn').addEventListener('click', switchToFileWorker);
        document.getElementById('noWorkerBtn').addEventListener('click', disableWorker);
        document.getElementById('testWorkerBtn').addEventListener('click', testWorker);

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!sideMenu.contains(e.target) && !menuToggle.contains(e.target)) {
                if (sideMenu.classList.contains('open')) {
                    sideMenu.classList.remove('open');
                    menuToggle.classList.remove('open');
                    statusText.textContent = 'Ready';
                }
            }
        });
        
        // Window resize handler
        window.addEventListener('resize', resizeCanvas);
        
        // Web Worker setup
        let worker = null;
        
        function createInlineWorker() {
            const workerScript = `
                // Web Worker for drawing app computations
                self.onmessage = function(e) {
                    const { type, data } = e.data;
                    
                    switch(type) {
                        case 'smoothStroke':
                            const smoothedStroke = smoothStrokePoints(data.points, data.threshold);
                            self.postMessage({
                                type: 'smoothStrokeResult',
                                id: data.id,
                                result: smoothedStroke
                            });
                            break;
                            
                        case 'processImageData':
                            const processedData = processCanvasImageData(data.imageData, data.operation);
                            self.postMessage({
                                type: 'processImageDataResult',
                                id: data.id,
                                result: processedData
                            });
                            break;
                            
                        case 'calculateBounds':
                            const bounds = calculateStrokeBounds(data.strokes);
                            self.postMessage({
                                type: 'calculateBoundsResult',
                                id: data.id,
                                result: bounds
                            });
                            break;
                            
                        default:
                            self.postMessage({
                                type: 'error',
                                message: 'Unknown task type: ' + type
                            });
                    }
                };
                
                // Smooth stroke points using quadratic interpolation
                function smoothStrokePoints(points, threshold = 3) {
                    if (points.length < 3) return points;
                    
                    const smoothed = [points[0]]; // Keep first point
                    
                    for (let i = 1; i < points.length - 1; i++) {
                        const prev = points[i - 1];
                        const curr = points[i];
                        const next = points[i + 1];
                        
                        // Calculate distance
                        const dist = Math.sqrt(
                            Math.pow(curr.x - prev.x, 2) + 
                            Math.pow(curr.y - prev.y, 2)
                        );
                        
                        if (dist >= threshold) {
                            // Apply smoothing
                            const smoothedPoint = {
                                x: (prev.x + curr.x + next.x) / 3,
                                y: (prev.y + curr.y + next.y) / 3,
                                tool: curr.tool,
                                width: curr.width
                            };
                            smoothed.push(smoothedPoint);
                        } else {
                            smoothed.push(curr);
                        }
                    }
                    
                    smoothed.push(points[points.length - 1]); // Keep last point
                    return smoothed;
                }
                
                // Process canvas image data (example: invert colors)
                function processCanvasImageData(imageData, operation) {
                    const data = new Uint8ClampedArray(imageData.data);
                    
                    switch(operation) {
                        case 'invert':
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = 255 - data[i];     // Red
                                data[i + 1] = 255 - data[i + 1]; // Green
                                data[i + 2] = 255 - data[i + 2]; // Blue
                                // Alpha stays the same
                            }
                            break;
                            
                        case 'grayscale':
                            for (let i = 0; i < data.length; i += 4) {
                                const gray = Math.round(data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                                data[i] = gray;     // Red
                                data[i + 1] = gray; // Green
                                data[i + 2] = gray; // Blue
                            }
                            break;
                    }
                    
                    return {
                        data: data,
                        width: imageData.width,
                        height: imageData.height
                    };
                }
                
                // Calculate bounds of all strokes
                function calculateStrokeBounds(strokes) {
                    if (!strokes || strokes.length === 0) {
                        return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
                    }
                    
                    let minX = Infinity, minY = Infinity;
                    let maxX = -Infinity, maxY = -Infinity;
                    
                    strokes.forEach(stroke => {
                        stroke.forEach(point => {
                            minX = Math.min(minX, point.x);
                            minY = Math.min(minY, point.y);
                            maxX = Math.max(maxX, point.x);
                            maxY = Math.max(maxY, point.y);
                        });
                    });
                    
                    return {
                        minX: minX,
                        minY: minY,
                        maxX: maxX,
                        maxY: maxY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                }
            `;
            
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }
        
        function createFallbackWorker() {
            try {
                return new Worker('worker.js');
            } catch (error) {
                console.warn('Fallback worker.js not found:', error);
                return null;
            }
        }
        
        // Detect environment
        function isLocalhost() {
            return location.hostname === 'localhost' || 
                   location.hostname === '127.0.0.1' || 
                   location.protocol === 'file:';
        }
        
        function initWorker() {
            updateWorkerStatus('Initializing...', 'none', false);
            
            if (isLocalhost()) {
                // Localhost: try file worker first, then inline as fallback
                console.log('Detected localhost environment');
                worker = createFallbackWorker();
                if (worker) {
                    setupWorkerHandlers();
                    updateWorkerStatus('Ready', 'file', true);
                    console.log('Using file worker (worker.js)');
                } else {
                    console.warn('File worker failed, trying inline worker');
                    try {
                        worker = createInlineWorker();
                        setupWorkerHandlers();
                        updateWorkerStatus('Ready', 'inline', true);
                        console.log('Using inline worker as fallback');
                    } catch (error) {
                        updateWorkerStatus('Not Available', 'none', false);
                        console.warn('No web worker available, running on main thread');
                    }
                }
            } else {
                // Poe Canvas or other: try inline worker first, then file as fallback
                console.log('Detected Poe Canvas or other environment');
                try {
                    worker = createInlineWorker();
                    setupWorkerHandlers();
                    updateWorkerStatus('Ready', 'inline', true);
                    console.log('Using inline web worker');
                } catch (error) {
                    console.warn('Inline worker failed, trying file worker:', error);
                    worker = createFallbackWorker();
                    if (worker) {
                        setupWorkerHandlers();
                        updateWorkerStatus('Ready', 'file', true);
                        console.log('Using file worker as fallback');
                    } else {
                        updateWorkerStatus('Not Available', 'none', false);
                        console.warn('No web worker available, running on main thread');
                    }
                }
            }
        }
        
        // Worker task handlers
        function handleSmoothStrokeResult(id, result) {
            console.log('Smooth stroke result:', result);
            statusText.textContent = `Stroke smoothed (${result.length} points)`;
        }
        
        function handleImageDataResult(id, result) {
            console.log('Image data processed:', result);
            statusText.textContent = 'Image processing completed';
        }
        
        function handleBoundsResult(id, result) {
            console.log('Stroke bounds:', result);
            statusText.textContent = `Canvas bounds: ${Math.round(result.width)}×${Math.round(result.height)}`;
        }
        
        // Helper function to send tasks to worker
        function sendWorkerTask(type, data, id = Date.now()) {
            if (worker) {
                worker.postMessage({ type, data: { ...data, id } });
                return true;
            } else {
                console.warn('No worker available for task:', type);
                return false;
            }
        }
        
        // Worker state tracking
        let currentWorkerType = 'none';
        
        // Update worker status UI
        function updateWorkerStatus(status, type, active) {
            document.getElementById('workerStatusValue').textContent = status;
            document.getElementById('workerTypeValue').textContent = type;
            document.getElementById('workerActiveValue').textContent = active ? '✓ Yes' : '✗ No';
            currentWorkerType = type;
            
            // Update button states
            document.querySelectorAll('#inlineWorkerBtn, #fileWorkerBtn, #noWorkerBtn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (type === 'inline') {
                document.getElementById('inlineWorkerBtn').classList.add('active');
            } else if (type === 'file') {
                document.getElementById('fileWorkerBtn').classList.add('active');
            } else {
                document.getElementById('noWorkerBtn').classList.add('active');
            }
        }
        
        // Terminate current worker
        function terminateWorker() {
            if (worker) {
                worker.terminate();
                worker = null;
                console.log('Worker terminated');
            }
        }
        
        // Switch to inline worker
        function switchToInlineWorker() {
            terminateWorker();
            updateWorkerStatus('Loading...', 'inline', false);
            
            try {
                worker = createInlineWorker();
                setupWorkerHandlers();
                updateWorkerStatus('Ready', 'inline', true);
                statusText.textContent = 'Switched to inline worker';
                console.log('Switched to inline worker');
            } catch (error) {
                updateWorkerStatus('Failed', 'none', false);
                statusText.textContent = 'Inline worker failed';
                console.error('Inline worker failed:', error);
            }
        }
        
        // Switch to file worker
        function switchToFileWorker() {
            terminateWorker();
            updateWorkerStatus('Loading...', 'file', false);
            
            try {
                worker = createFallbackWorker();
                if (worker) {
                    setupWorkerHandlers();
                    updateWorkerStatus('Ready', 'file', true);
                    statusText.textContent = 'Switched to file worker';
                    console.log('Switched to file worker');
                } else {
                    updateWorkerStatus('Not Found', 'none', false);
                    statusText.textContent = 'worker.js not found';
                }
            } catch (error) {
                updateWorkerStatus('Failed', 'none', false);
                statusText.textContent = 'File worker failed';
                console.error('File worker failed:', error);
            }
        }
        
        // Disable worker
        function disableWorker() {
            terminateWorker();
            updateWorkerStatus('Disabled', 'none', false);
            statusText.textContent = 'Worker disabled';
            console.log('Worker disabled');
        }
        
        // Setup worker message handlers
        function setupWorkerHandlers() {
            if (!worker) return;
            
            worker.onmessage = function(e) {
                const { type, id, result, message } = e.data;
                
                switch(type) {
                    case 'smoothStrokeResult':
                        handleSmoothStrokeResult(id, result);
                        break;
                        
                    case 'processImageDataResult':
                        handleImageDataResult(id, result);
                        break;
                        
                    case 'calculateBoundsResult':
                        handleBoundsResult(id, result);
                        break;
                        
                    case 'error':
                        console.error('Worker error:', message);
                        statusText.textContent = 'Worker error: ' + message;
                        break;
                }
            };
            
            worker.onerror = function(error) {
                console.error('Worker error:', error);
                updateWorkerStatus('Error', currentWorkerType, false);
                statusText.textContent = 'Worker encountered an error';
            };
        }
        
        // Test worker functionality
        function testWorker() {
            if (!worker) {
                statusText.textContent = 'No worker to test';
                return;
            }
            
            statusText.textContent = 'Testing worker...';
            
            // Test with current strokes if available, otherwise use dummy data
            const testStrokes = strokes.length > 0 ? strokes : [[
                { x: 10, y: 10, tool: 'pen', width: 2 },
                { x: 50, y: 50, tool: 'pen', width: 2 },
                { x: 100, y: 30, tool: 'pen', width: 2 }
            ]];
            
            sendWorkerTask('calculateBounds', { strokes: testStrokes });
        }
        
        // Initialize
        initWorker();
        setupCanvas();
        setTool('pen');
        updateInputIndicator('-', '-', 'bg-gray-400');
        
        // Performance optimization: limit pointer move events
        let lastMoveTime = 0;
        const originalPointermove = canvas.pointermove;
        canvas.addEventListener('pointermove', (e) => {
            const now = performance.now();
            if (now - lastMoveTime > 8) { // ~120fps limit for slow devices
                lastMoveTime = now;
                draw(e);
                updateEraserPosition(e); // Update eraser indicator position
            }
        });
        
        // Add mouse movement tracking for eraser indicator (canvas area only)
        canvas.addEventListener('mousemove', updateEraserPosition);
        canvas.addEventListener('mouseenter', () => {
            if (currentTool === 'eraser') {
                eraserIndicator.style.display = 'block';
            }
        });
        canvas.addEventListener('mouseleave', () => {
            eraserIndicator.style.display = 'none';
        });
    </script>


</body></html>
