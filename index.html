<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Drawing App with Perfect Freehand</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Try multiple CDN sources for perfect-freehand -->
    <script>
        // Create exports object for CommonJS compatibility
        window.exports = {};
        
        // Try loading perfect-freehand from different sources and versions
        const cdnSources = [
            // Try the main package entry point
            'https://unpkg.com/perfect-freehand@1.2.0',
            'https://cdn.jsdelivr.net/npm/perfect-freehand@1.2.0',
            // Try different versions
            'https://unpkg.com/perfect-freehand@latest',
            'https://cdn.jsdelivr.net/npm/perfect-freehand@latest',
            // Try specific build files if they exist
            'https://unpkg.com/perfect-freehand@1.2.0/dist/index.js',
            'https://cdn.jsdelivr.net/npm/perfect-freehand@1.2.0/dist/index.js',
            // Try older version that might have UMD
            'https://unpkg.com/perfect-freehand@1.0.0',
            'https://cdn.jsdelivr.net/npm/perfect-freehand@1.0.0'
        ];
        
        let sourceIndex = 0;
        
        function loadPerfectFreehand() {
            return new Promise((resolve, reject) => {
                if (sourceIndex >= cdnSources.length) {
                    reject(new Error('All CDN sources failed'));
                    return;
                }
                
                const script = document.createElement('script');
                script.src = cdnSources[sourceIndex];
                script.onload = () => {
                    console.log(`Perfect Freehand loaded from: ${cdnSources[sourceIndex]}`);
                    resolve();
                };
                script.onerror = () => {
                    console.warn(`Failed to load from: ${cdnSources[sourceIndex]}`);
                    sourceIndex++;
                    script.remove();
                    loadPerfectFreehand().then(resolve).catch(reject);
                };
                document.head.appendChild(script);
            });
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
        }
        
        #drawingSurface {
            cursor: crosshair;
        }
        
        /* Menu animations */
        .slide-menu {
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .slide-menu.open {
            transform: translateX(0);
        }
        
        .menu-overlay {
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .menu-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        
        /* Menu buttons */
        .menu-button {
            transition: all 0.2s ease;
        }
        
        .menu-button:hover {
            background: #f5f5f5;
        }
        
        .menu-button.active {
            background: #000;
            color: white;
        }
        
        /* Control groups */
        .control-group {
            border-bottom: 1px solid #e5e5e5;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        /* Color picker styling */
        .color-dot {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            border: 1px solid #d1d5db;
            border-radius: 50%;
            cursor: pointer;
            outline: none;
            width: 10px;
            height: 10px;
            flex-shrink: 0;
        }
        
        .color-dot::-webkit-color-swatch-wrapper {
            padding: 0;
            border: none;
            border-radius: 50%;
        }
        
        .color-dot::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
        
        .color-dot::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }
        
        /* Range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #d1d5db;
            height: 4px;
            border-radius: 2px;
            cursor: pointer;
            outline: none;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #d1d5db;
            height: 4px;
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #6b7280;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform: scale(1);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        input[type="range"]::-moz-range-track {
            background: #d1d5db;
            height: 4px;
            border-radius: 2px;
            border: none;
        }
        
        input[type="range"]::-moz-range-thumb {
            background: #6b7280;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform: scale(1);
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        input[type="range"]::-moz-range-thumb:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        

    </style>
</head>
<body class="bg-white">
    <!-- Menu Toggle Button -->
    <button id="menuToggle" class="fixed top-4 left-4 z-50 p-3 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-50 transition-colors">
        <i data-lucide="menu" class="w-5 h-5 text-gray-600"></i>
    </button>

    <!-- Quick Clear Button -->
    <button id="quickClearBtn" class="fixed top-4 right-4 z-50 p-3 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-50 transition-colors">
        <i data-lucide="trash-2" class="w-5 h-5 text-gray-600"></i>
    </button>

    <!-- Menu Overlay -->
    <div id="menuOverlay" class="menu-overlay fixed inset-0 bg-black bg-opacity-20 z-40"></div>

    <!-- Slide Menu -->
    <div id="slideMenu" class="slide-menu fixed top-0 left-0 h-full w-72 bg-white border-r border-gray-200 z-50 overflow-y-auto">
        <!-- Menu Header -->
        <div class="flex items-center justify-between p-4 border-b border-gray-200">
            <h2 class="text-sm font-medium text-gray-900">Drawing Tools</h2>
            <button id="copyParams" class="p-1 hover:bg-gray-100 rounded transition-colors" title="Copy parameters">
                <i data-lucide="copy" class="w-5 h-5 text-gray-600"></i>
            </button>
        </div>

        <!-- Drawing Tools -->
        <div class="control-group p-4">
            <h3 class="text-xs font-medium text-gray-900 mb-3 flex items-center gap-2">
                <i data-lucide="edit-3" class="w-4 h-4"></i>
                Drawing Tools
            </h3>
            <div class="flex gap-2">
                <button id="penTool" class="menu-button active w-12 h-12 flex items-center justify-center rounded-lg border border-gray-200">
                    <i data-lucide="pen-tool" class="w-4 h-4"></i>
                </button>
                <button id="eraserTool" class="menu-button w-12 h-12 flex items-center justify-center rounded-lg border border-gray-200">
                    <i data-lucide="eraser" class="w-4 h-4"></i>
                </button>
            </div>
        </div>

        <!-- Perfect Freehand Settings -->
        <div class="control-group p-4">
            <h3 class="text-xs font-medium text-gray-900 mb-3 flex items-center gap-2">
                <i data-lucide="brush" class="w-4 h-4"></i>
                Brush Settings
            </h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Size & Color</label>
                    <div class="flex items-center gap-3">
                        <input type="range" id="brushSize" min="4" max="50" step="2" value="6" class="flex-1">
                        <input type="color" id="colorPicker" value="#000000" class="color-dot" title="Stroke Color">
                    </div>
                    <span id="brushSizeValue" class="text-xs text-gray-500 mt-1 block ml-2">6px</span>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Thinning</label>
                    <input type="range" id="thinning" min="-1" max="1" step="0.1" value="0.6" class="w-full">
                    <span id="thinningValue" class="text-xs text-gray-500 mt-1 block ml-2">0.6</span>
                    <p class="text-xs text-gray-400 mt-1">Negative values: thinner with pressure</p>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Smoothing</label>
                    <input type="range" id="smoothing" min="0" max="1" step="0.1" value="0" class="w-full">
                    <span id="smoothingValue" class="text-xs text-gray-500 mt-1 block ml-2">0</span>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Streamline</label>
                    <input type="range" id="streamline" min="0" max="1" step="0.1" value="0.2" class="w-full">
                    <span id="streamlineValue" class="text-xs text-gray-500 mt-1 block ml-2">0.2</span>
                </div>
                
                <div>
                    <label class="flex items-center gap-2 text-xs font-medium text-gray-700">
                        <input type="checkbox" id="simulatePressure" class="rounded">
                        Simulate Pressure
                    </label>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Easing Function</label>
                    <select id="easingFunction" class="w-full text-base px-2 py-1 border border-gray-200 rounded text-gray-700">
                        <option value="linear">Linear (t)</option>
                        <option value="easeInQuad" selected>Ease In Quad (t²)</option>
                        <option value="easeOutQuad">Ease Out Quad</option>
                        <option value="easeInOutQuad">Ease In/Out Quad</option>
                        <option value="easeInCubic">Ease In Cubic (t³)</option>
                        <option value="easeOutCubic">Ease Out Cubic</option>
                        <option value="easeInOutCubic">Ease In/Out Cubic</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Start Cap & Taper -->
        <div class="control-group p-4">
            <h3 class="text-xs font-medium text-gray-900 mb-3 flex items-center gap-2">
                <i data-lucide="corner-left-up" class="w-4 h-4"></i>
                Start Options
            </h3>
            <div class="space-y-4">
                <div>
                    <label class="flex items-center gap-2 text-xs font-medium text-gray-700">
                        <input type="checkbox" id="startCap" checked class="rounded">
                        Start Cap
                    </label>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Start Taper</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="startTaper" min="0" max="100" step="5" value="5" class="flex-1">
                        <button id="startTaperFull" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded border">Full</button>
                    </div>
                    <span id="startTaperValue" class="text-xs text-gray-500 mt-1 block ml-2">5px</span>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Start Easing</label>
                    <select id="startEasing" class="w-full text-base px-2 py-1 border border-gray-200 rounded text-gray-700">
                        <option value="default">Default (t * (2 - t))</option>
                        <option value="linear">Linear (t)</option>
                        <option value="easeInQuad">Ease In Quad</option>
                        <option value="easeOutQuad">Ease Out Quad</option>
                        <option value="easeInOutQuad">Ease In/Out Quad</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- End Cap & Taper -->
        <div class="control-group p-4">
            <h3 class="text-xs font-medium text-gray-900 mb-3 flex items-center gap-2">
                <i data-lucide="corner-right-down" class="w-4 h-4"></i>
                End Options
            </h3>
            <div class="space-y-4">
                <div>
                    <label class="flex items-center gap-2 text-xs font-medium text-gray-700">
                        <input type="checkbox" id="endCap" checked class="rounded">
                        End Cap
                    </label>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">End Taper</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="endTaper" min="0" max="100" step="5" value="5" class="flex-1">
                        <button id="endTaperFull" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded border">Full</button>
                    </div>
                    <span id="endTaperValue" class="text-xs text-gray-500 mt-1 block ml-2">5px</span>
                </div>
                
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">End Easing</label>
                    <select id="endEasing" class="w-full text-base px-2 py-1 border border-gray-200 rounded text-gray-700">
                        <option value="default">Default (--t * t * t + 1)</option>
                        <option value="linear">Linear (t)</option>
                        <option value="easeInQuad">Ease In Quad</option>
                        <option value="easeOutQuad">Ease Out Quad</option>
                        <option value="easeInOutQuad">Ease In/Out Quad</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Live Preview -->
        <div class="control-group p-4">
            <h3 class="text-xs font-medium text-gray-900 mb-3 flex items-center gap-2">
                <i data-lucide="eye" class="w-4 h-4"></i>
                Live Preview
            </h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-2">Color & Opacity</label>
                    <div class="flex items-center gap-3">
                        <input type="color" id="previewColorPicker" value="#0066ff" class="color-dot" title="Preview Color">
                        <input type="range" id="previewOpacity" min="0.1" max="1" step="0.1" value="0.7" class="flex-1">
                    </div>
                    <span id="opacityValue" class="text-xs text-gray-500 mt-1 block ml-2">0.7</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Surface -->
    <svg id="drawingSurface" width="100%" height="100%" class="block">
        <defs>
            <filter id="shadow-filter">
                <feDropShadow dx="0" dy="1" stdDeviation="1" flood-opacity="0.2"/>
            </filter>
        </defs>
    </svg>

    <script>


        // Perfect Freehand SVG Path Utility
        const average = (a, b) => (a + b) / 2;
        
        // Easing functions for perfect-freehand
        const easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => --t * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            default: t => t * (2 - t), // Default start easing
            defaultEnd: t => --t * t * t + 1 // Default end easing
        };
        
        function getSvgPathFromStroke(points, closed = true) {
            const len = points.length;
            if (len < 4) return '';

            let a = points[0];
            let b = points[1];
            const c = points[2];

            let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`;

            for (let i = 2, max = len - 1; i < max; i++) {
                a = points[i];
                b = points[i + 1];
                result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;
            }

            if (closed) {
                result += 'Z';
            }

            return result;
        }

        class VectorDrawingApp {
            constructor() {
                // Core drawing properties
                this.svg = document.getElementById('drawingSurface');
                this.currentStroke = null;
                this.isDrawing = false;
                this.strokes = [];
                this.currentInputPoints = [];
                
                // Tool settings
                this.currentTool = 'pen';
                this.brushSize = 6;
                this.color = '#000000';
                
                // Perfect Freehand settings
                this.thinning = 0.6;
                this.smoothing = 0;
                this.streamline = 0.2;
                this.simulatePressure = false;
                
                // Advanced Perfect Freehand settings
                this.easingFunction = 'easeInQuad';
                this.startCap = true;
                this.startTaper = 5;
                this.startTaperFull = false;
                this.startEasing = 'default';
                this.endCap = true;
                this.endTaper = 5;
                this.endTaperFull = false;
                this.endEasing = 'default';
                
                // Preview settings
                this.previewColor = '#0066ff';
                this.previewOpacity = 0.7;
                
                // Web Ink API
                this.inkPresenter = null;
                this.inkSupported = false;
                
                this.initialize();
            }
            
            // ==========================================
            // INITIALIZATION
            // ==========================================
            
            initialize() {
                this.setupEventListeners();
                this.setupInkAPI();
                this.resizeCanvas();
            }
            
            setupEventListeners() {
                this.setupMenuControls();
                this.setupToolControls();
                this.setupBrushControls();
                this.setupPreviewControls();
                this.setupDrawingEvents();
                this.setupUtilityControls();
                this.setupResizeHandlers();
            }
            
            setupMenuControls() {
                const menuToggle = document.getElementById('menuToggle');
                const copyParams = document.getElementById('copyParams');
                const menuOverlay = document.getElementById('menuOverlay');
                const slideMenu = document.getElementById('slideMenu');
                
                menuToggle.addEventListener('click', () => {
                    slideMenu.classList.add('open');
                    menuOverlay.classList.add('open');
                });
                
                const closeMenu = () => {
                    slideMenu.classList.remove('open');
                    menuOverlay.classList.remove('open');
                };
                
                menuOverlay.addEventListener('click', closeMenu);
                copyParams.addEventListener('click', () => this.copyParametersToClipboard());
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeMenu();
                });
            }
            
            setupToolControls() {
                document.getElementById('penTool').addEventListener('click', () => this.setTool('pen'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
            }
            
            setupBrushControls() {
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseFloat(e.target.value);
                    document.getElementById('brushSizeValue').textContent = this.brushSize + 'px';
                });
                
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.color = e.target.value;
                });
                
                document.getElementById('thinning').addEventListener('input', (e) => {
                    this.thinning = parseFloat(e.target.value);
                    document.getElementById('thinningValue').textContent = this.thinning.toFixed(1);
                });
                
                document.getElementById('smoothing').addEventListener('input', (e) => {
                    this.smoothing = parseFloat(e.target.value);
                    document.getElementById('smoothingValue').textContent = this.smoothing.toFixed(1);
                });
                
                document.getElementById('streamline').addEventListener('input', (e) => {
                    this.streamline = parseFloat(e.target.value);
                    document.getElementById('streamlineValue').textContent = this.streamline.toFixed(1);
                });
                
                document.getElementById('simulatePressure').addEventListener('change', (e) => {
                    this.simulatePressure = e.target.checked;
                });
                
                // Advanced controls
                document.getElementById('easingFunction').addEventListener('change', (e) => {
                    this.easingFunction = e.target.value;
                });
                
                document.getElementById('startCap').addEventListener('change', (e) => {
                    this.startCap = e.target.checked;
                });
                
                document.getElementById('startTaper').addEventListener('input', (e) => {
                    this.startTaper = parseFloat(e.target.value);
                    document.getElementById('startTaperValue').textContent = this.startTaper + 'px';
                    this.startTaperFull = false;
                });
                
                document.getElementById('startTaperFull').addEventListener('click', () => {
                    this.startTaperFull = true;
                    document.getElementById('startTaperValue').textContent = 'Full length';
                });
                
                document.getElementById('startEasing').addEventListener('change', (e) => {
                    this.startEasing = e.target.value;
                });
                
                document.getElementById('endCap').addEventListener('change', (e) => {
                    this.endCap = e.target.checked;
                });
                
                document.getElementById('endTaper').addEventListener('input', (e) => {
                    this.endTaper = parseFloat(e.target.value);
                    document.getElementById('endTaperValue').textContent = this.endTaper + 'px';
                    this.endTaperFull = false;
                });
                
                document.getElementById('endTaperFull').addEventListener('click', () => {
                    this.endTaperFull = true;
                    document.getElementById('endTaperValue').textContent = 'Full length';
                });
                
                document.getElementById('endEasing').addEventListener('change', (e) => {
                    this.endEasing = e.target.value;
                });
            }
            
            setupPreviewControls() {
                document.getElementById('previewColorPicker').addEventListener('change', (e) => {
                    this.previewColor = e.target.value;
                });
                
                document.getElementById('previewOpacity').addEventListener('input', (e) => {
                    this.previewOpacity = parseFloat(e.target.value);
                    document.getElementById('opacityValue').textContent = this.previewOpacity.toFixed(1);
                });
            }
            
            setupDrawingEvents() {
                this.svg.addEventListener('contextmenu', (e) => e.preventDefault());
                
                this.svg.addEventListener('pointerdown', this.startDrawing.bind(this));
                this.svg.addEventListener('pointermove', this.continueDrawing.bind(this));
                this.svg.addEventListener('pointerup', this.endDrawing.bind(this));
                this.svg.addEventListener('pointercancel', this.endDrawing.bind(this));
            }
            
            setupUtilityControls() {
                document.getElementById('quickClearBtn').addEventListener('click', () => this.clearCanvas());
            }
            
            setupResizeHandlers() {
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('load', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.svg.setAttribute('width', window.innerWidth);
                this.svg.setAttribute('height', window.innerHeight);
            }
            
            // ==========================================
            // WEB INK API SETUP
            // ==========================================
            
            async setupInkAPI() {
                if ('ink' in navigator && 'requestPresenter' in navigator.ink) {
                    try {
                        this.inkPresenter = await navigator.ink.requestPresenter({
                            presentationArea: this.svg
                        });
                        this.inkSupported = true;
                        console.log('Web Ink presenter initialized');
                    } catch (error) {
                        console.log('Web Ink API not available, using pointer events only');
                        this.inkSupported = false;
                    }
                } else {
                    this.inkSupported = false;
                }
            }
            
            // ==========================================
            // DRAWING LOGIC WITH PERFECT FREEHAND
            // ==========================================
            
            startDrawing(event) {
                // Only allow pen and mouse input - disable finger/touch
                if (event.button !== undefined && event.button !== 0) return;
                if (event.pointerType === 'touch') return;
                
                this.isDrawing = true;
                const point = this.getPoint(event);
                
                console.log('Start drawing:', event.pointerType, point); // Debug log
                
                if (this.currentTool === 'pen') {
                    this.currentInputPoints = [point];
                    this.createPreviewStroke();
                    
                    if (this.inkPresenter) {
                        this.inkPresenter.updateInkTrailStartPoint(event, {
                            color: this.hexToRgba(this.previewColor, this.previewOpacity),
                            diameter: this.brushSize * 0.5
                        });
                    }
                } else if (this.currentTool === 'eraser') {
                    this.eraseAt(point);
                }
                
                event.preventDefault();
            }
            
            continueDrawing(event) {
                if (!this.isDrawing) return;
                
                const point = this.getPoint(event);
                
                if (this.currentTool === 'pen') {
                    this.currentInputPoints.push(point);
                    this.updatePreviewStroke();
                    
                    if (this.inkPresenter) {
                        const pressure = this.getInkPressure(event);
                        this.inkPresenter.updateInkTrailStartPoint(event, {
                            color: this.hexToRgba(this.previewColor, this.previewOpacity),
                            diameter: this.brushSize * (0.3 + pressure * 0.7)
                        });
                    }
                } else if (this.currentTool === 'eraser') {
                    this.eraseAt(point);
                }
                
                event.preventDefault();
            }
            
            endDrawing(event) {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                if (this.currentTool === 'pen' && this.currentStroke && this.currentInputPoints.length > 1) {
                    this.finalizeStroke();
                } else if (this.currentStroke) {
                    // Remove incomplete stroke
                    this.currentStroke.remove();
                }
                
                this.currentStroke = null;
                this.currentInputPoints = [];
                
                event.preventDefault();
            }
            
            // ==========================================
            // PERFECT FREEHAND STROKE CREATION
            // ==========================================
            
            getPoint(event) {
                const rect = this.svg.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                if (this.simulatePressure) {
                    // Let perfect-freehand simulate pressure based on velocity
                    return [x, y];
                } else {
                    // Use actual pressure from stylus/pen
                    const pressure = this.getInkPressure(event);
                    return [x, y, pressure];
                }
            }
            
            getInkPressure(event) {
                if (event.pressure !== undefined && event.pressure > 0) {
                    return Math.min(1, Math.max(0.1, event.pressure));
                }
                
                if (event.pointerType === 'pen') {
                    return 0.7;
                } else if (event.pointerType === 'touch') {
                    return event.force || 0.5;
                }
                
                return 0.5;
            }
            
            createPreviewStroke() {
                this.currentStroke = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.currentStroke.setAttribute('fill', this.color);
                this.currentStroke.setAttribute('stroke', 'none');
                this.currentStroke.setAttribute('filter', 'url(#shadow-filter)');
                this.svg.appendChild(this.currentStroke);
            }
            
            updatePreviewStroke() {
                if (!this.currentStroke || this.currentInputPoints.length < 2) return;
                
                try {
                    const options = this.getPerfectFreehandOptions(false);
                    const outlinePoints = perfectFreehand.getStroke(this.currentInputPoints, options);
                    const pathData = getSvgPathFromStroke(outlinePoints);
                    this.currentStroke.setAttribute('d', pathData);
                } catch (error) {
                    console.warn('Error updating stroke:', error);
                }
            }
            
            finalizeStroke() {
                if (!this.currentStroke || this.currentInputPoints.length < 2) return;
                
                try {
                    const options = this.getPerfectFreehandOptions(true);
                    const outlinePoints = perfectFreehand.getStroke(this.currentInputPoints, options);
                    const pathData = getSvgPathFromStroke(outlinePoints);
                    this.currentStroke.setAttribute('d', pathData);
                    
                    // Store stroke data for eraser functionality
                    this.currentStroke.inputPoints = [...this.currentInputPoints];
                    this.currentStroke.strokeOptions = {...options};
                    
                    this.strokes.push(this.currentStroke);
                } catch (error) {
                    console.warn('Error finalizing stroke:', error);
                    this.currentStroke.remove();
                }
            }
            
            // Generate complete perfect-freehand options object
            getPerfectFreehandOptions(isLast = true) {
                return {
                    size: this.brushSize,
                    thinning: this.thinning,
                    smoothing: this.smoothing,
                    streamline: this.streamline,
                    simulatePressure: this.simulatePressure,
                    easing: easingFunctions[this.easingFunction],
                    last: isLast,
                    start: {
                        cap: this.startCap,
                        taper: this.startTaperFull ? true : (this.startTaper || 0),
                        easing: this.startEasing === 'default' ? easingFunctions.default : easingFunctions[this.startEasing]
                    },
                    end: {
                        cap: this.endCap,
                        taper: this.endTaperFull ? true : (this.endTaper || 0),
                        easing: this.endEasing === 'default' ? easingFunctions.defaultEnd : easingFunctions[this.endEasing]
                    }
                };
            }
            
            // ==========================================
            // ERASER FUNCTIONALITY
            // ==========================================
            
            eraseAt(point) {
                const eraserRadius = Math.max(this.brushSize * 0.8, 10);
                
                this.strokes.forEach((stroke, index) => {
                    if (!stroke.inputPoints || stroke.inputPoints.length < 2) return;
                    
                    const intersectingIndices = [];
                    stroke.inputPoints.forEach((strokePoint, pointIndex) => {
                        const distance = Math.sqrt(
                            Math.pow(strokePoint[0] - point[0], 2) + 
                            Math.pow(strokePoint[1] - point[1], 2)
                        );
                        
                        if (distance <= eraserRadius) {
                            intersectingIndices.push(pointIndex);
                        }
                    });
                    
                    if (intersectingIndices.length === 0) return;
                    
                    if (intersectingIndices.length >= stroke.inputPoints.length * 0.7) {
                        // Remove entire stroke if most points are erased
                        stroke.remove();
                        this.strokes.splice(index, 1);
                        return;
                    }
                    
                    this.splitStrokeAtErasedPoints(stroke, intersectingIndices, index);
                });
            }
            
            splitStrokeAtErasedPoints(originalStroke, erasedIndices, strokeIndex) {
                const points = originalStroke.inputPoints;
                const segments = [];
                let currentSegment = [];
                
                for (let i = 0; i < points.length; i++) {
                    if (!erasedIndices.includes(i)) {
                        currentSegment.push(points[i]);
                    } else {
                        if (currentSegment.length >= 3) {
                            segments.push([...currentSegment]);
                        }
                        currentSegment = [];
                    }
                }
                
                if (currentSegment.length >= 3) {
                    segments.push(currentSegment);
                }
                
                originalStroke.remove();
                this.strokes.splice(strokeIndex, 1);
                
                segments.forEach(segmentPoints => {
                    if (segmentPoints.length >= 3) {
                        const newStroke = this.createStrokeFromPoints(segmentPoints, originalStroke.strokeOptions);
                        this.svg.appendChild(newStroke);
                        this.strokes.push(newStroke);
                    }
                });
            }
            
            createStrokeFromPoints(inputPoints, options) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('fill', this.color);
                path.setAttribute('stroke', 'none');
                path.setAttribute('filter', 'url(#shadow-filter)');
                
                try {
                    const outlinePoints = perfectFreehand.getStroke(inputPoints, options);
                    const pathData = getSvgPathFromStroke(outlinePoints);
                    path.setAttribute('d', pathData);
                    
                    path.inputPoints = inputPoints;
                    path.strokeOptions = options;
                } catch (error) {
                    console.warn('Error creating stroke from points:', error);
                }
                
                return path;
            }
            
            // ==========================================
            // TOOL MANAGEMENT
            // ==========================================
            
            setTool(tool) {
                this.currentTool = tool;
                
                document.querySelectorAll('.menu-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                if (tool === 'pen') {
                    document.getElementById('penTool').classList.add('active');
                    this.svg.style.cursor = 'crosshair';
                } else if (tool === 'eraser') {
                    document.getElementById('eraserTool').classList.add('active');
                    this.svg.style.cursor = 'pointer';
                }
            }
            
            // ==========================================
            // UTILITY FUNCTIONS
            // ==========================================
            
            clearCanvas() {
                this.strokes.forEach(stroke => stroke.remove());
                this.strokes = [];
                
                const paths = this.svg.querySelectorAll('path');
                paths.forEach(path => path.remove());
            }
            
            hexToRgba(hex, opacity) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            
            copyParametersToClipboard() {
                const params = {
                    currentTool: this.currentTool,
                    brushSize: this.brushSize,
                    brushColor: this.color,
                    thinning: this.thinning,
                    smoothing: this.smoothing,
                    streamline: this.streamline,
                    simulatePressure: this.simulatePressure,
                    easingFunction: this.easingFunction,
                    startCap: this.startCap,
                    startTaper: this.startTaperFull ? 'full' : this.startTaper,
                    startEasing: this.startEasing,
                    endCap: this.endCap,
                    endTaper: this.endTaperFull ? 'full' : this.endTaper,
                    endEasing: this.endEasing,
                    previewColor: this.previewColor,
                    previewOpacity: this.previewOpacity
                };
                
                const paramText = `Perfect Freehand Drawing App - Current Parameters:

=== TOOL SETTINGS ===
Tool: ${params.currentTool}
Brush Size: ${params.brushSize}px
Brush Color: ${params.brushColor}

=== CORE STROKE SETTINGS ===
Thinning: ${params.thinning}
Smoothing: ${params.smoothing}
Streamline: ${params.streamline}
Simulate Pressure: ${params.simulatePressure}
Easing Function: ${params.easingFunction}

=== START OPTIONS ===
Start Cap: ${params.startCap}
Start Taper: ${params.startTaper}${params.startTaper === 'full' ? '' : 'px'}
Start Easing: ${params.startEasing}

=== END OPTIONS ===
End Cap: ${params.endCap}
End Taper: ${params.endTaper}${params.endTaper === 'full' ? '' : 'px'}
End Easing: ${params.endEasing}

=== PREVIEW SETTINGS ===
Preview Color: ${params.previewColor}
Preview Opacity: ${params.previewOpacity}`;
                
                navigator.clipboard.writeText(paramText).then(() => {
                    this.showToast('Parameters copied to clipboard!', 'success');
                }).catch(err => {
                    this.showToast('Failed to copy parameters', 'error');
                    console.error('Failed to copy parameters:', err);
                });
            }
            
            showToast(message, type = 'success') {
                const existingToast = document.querySelector('.toast');
                if (existingToast) existingToast.remove();

                const toast = document.createElement('div');
                toast.className = `toast fixed top-20 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-lg shadow-lg z-50 text-sm font-medium transition-all duration-300 ${
                    type === 'success' ? 'bg-green-500 text-white' : 'bg-red-500 text-white'
                }`;
                toast.textContent = message;
                toast.style.opacity = '0';
                toast.style.transform = 'translate(-50%, -20px)';

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translate(-50%, 0)';
                }, 10);

                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translate(-50%, -20px)';
                    setTimeout(() => {
                        if (toast.parentNode) toast.remove();
                    }, 300);
                }, 2500);
            }
        }
        
        // ==========================================
        // INITIALIZATION
        // ==========================================
        
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Try to load perfect-freehand with fallback CDNs
                await loadPerfectFreehand();
                
                // Handle CommonJS exports and make functions globally available
                if (typeof exports !== 'undefined' && exports.getStroke) {
                    // CommonJS build loaded - make functions global
                    window.getStroke = exports.getStroke;
                    window.getStrokePoints = exports.getStrokePoints;
                    window.getStrokeOutlinePoints = exports.getStrokeOutlinePoints;
                    window.perfectFreehand = { 
                        getStroke: exports.getStroke,
                        getStrokePoints: exports.getStrokePoints,
                        getStrokeOutlinePoints: exports.getStrokeOutlinePoints
                    };
                    console.log('Perfect Freehand library loaded successfully (CommonJS)');
                } else if (typeof perfectFreehand !== 'undefined' || typeof getStroke !== 'undefined') {
                    // UMD build loaded
                    console.log('Perfect Freehand library loaded successfully (UMD)');
                } else {
                    throw new Error('Library not found after loading');
                }
                
                // Initialize the app
                new VectorDrawingApp();
                lucide.createIcons();
                
            } catch (error) {
                console.error('Perfect Freehand library failed to load:', error);
                
                // Show fallback message
                document.body.innerHTML = `
                    <div class="flex items-center justify-center h-screen bg-gray-100">
                        <div class="text-center p-8 bg-white rounded-lg shadow-lg max-w-md mx-4">
                            <h2 class="text-xl font-semibold text-red-600 mb-4">Library Loading Error</h2>
                            <p class="text-gray-700 mb-4">The perfect-freehand library failed to load from all CDN sources.</p>
                            <p class="text-sm text-gray-500 mb-4">This could be due to network issues or CDN availability.</p>
                            <button onclick="window.location.reload()" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 mr-2">
                                Refresh Page
                            </button>
                            <button onclick="showErrorDetails()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                                Show Details
                            </button>
                            <div id="errorDetails" class="hidden mt-4 p-3 bg-gray-100 rounded text-xs text-left">
                                <strong>Attempted CDN URLs:</strong><br>
                                ${cdnSources.map(url => `• ${url}`).join('<br>')}
                            </div>
                        </div>
                    </div>
                `;
                
                window.showErrorDetails = () => {
                    document.getElementById('errorDetails').classList.toggle('hidden');
                };
            }
        });
    </script>
</body>
</html>
