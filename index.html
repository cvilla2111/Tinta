<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Drawing App - Stylus Only</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 10;
            touch-action: none; /* Prevent default touch behaviors */
        }
        .pdf-page-container {
            position: relative;
            margin: 0 auto;
        }
        .tool-active {
            background-color: #E5E7EB !important;
            color: #374151 !important;
        }
        .dark .tool-active {
            background-color: #4B5563 !important;
            color: #F3F4F6 !important;
        }
        .selected-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-size {
            background-color: #4B5563 !important;
        }
        .selected-eraser-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-eraser-size {
            background-color: #4B5563 !important;
        }
        
        /* Page transition effects */
        .page-transition {
            transition: opacity 0.3s ease-in-out;
        }
        .page-fade-out {
            opacity: 0;
        }
        .page-fade-in {
            opacity: 1;
        }

        /* Page thumbnail modal */
        .page-thumbnail-modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        .page-thumbnail-modal.open {
            transform: translateX(0);
        }
        .page-thumbnail {
            transition: all 0.2s ease;
        }
        .page-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        .page-thumbnail.current {
            border-color: #5D5CDE !important;
            box-shadow: 0 0 0 2px #5D5CDE;
        }


    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 min-h-screen">


    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
                <h1 class="text-2xl font-bold text-gray-900 dark:text-white">PDF Drawing App</h1>
                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">Stylus input only - Supports MPP stylus & Samsung S-Pen</p>
            </div>
            
            <!-- File Upload and Theme Toggle -->
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                <!-- Theme Toggle -->
                <div class="flex items-center gap-2">
                    <i data-lucide="sun" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="themeToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-gray-600"></div>
                    </label>
                    <i data-lucide="moon" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                </div>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 hidden sm:block"></div>
                
                <input type="file" id="pdfUpload" accept=".pdf" class="hidden">
                <button onclick="document.getElementById('pdfUpload').click()" 
                        class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-base">
                    Upload PDF
                </button>
                <button id="downloadBtn" onclick="downloadPDF()" 
                        class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-base" 
                        disabled>
                    Download
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div id="mainContent" class="max-w-7xl mx-auto">
        <!-- Initial Upload Area -->
        <div id="uploadArea" class="p-4">
            <div class="text-center">
                <div class="bg-gray-50 dark:bg-gray-800 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-12">
                    <div class="text-gray-400 dark:text-gray-500">
                        <svg class="mx-auto h-12 w-12 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                        </svg>
                        <p class="text-lg font-medium">No PDF loaded</p>
                        <p class="text-sm mt-2">Upload a PDF file to start drawing with your stylus</p>
                        <div class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <p class="text-sm text-blue-700 dark:text-blue-300">
                                <strong>Note:</strong> This app supports MPP stylus and Samsung S-Pen. Mouse and finger input are disabled for drawing.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Viewer Area (Full Screen) -->
        <div id="pdfViewer" class="hidden fixed inset-0 bg-white">
            <!-- Settings Modal -->
            <div id="settingsModal" class="fixed bottom-20 left-1/2 transform -translate-x-1/2 z-40 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-6 py-3 hidden">
                <!-- Pen Settings -->
                <div id="penSettings" class="hidden">
                    <!-- Brush Size Dots and Pressure Switch in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setBrushSize(1)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="1">
                            <div style="width: 1px; height: 1px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(2)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="2">
                            <div style="width: 2px; height: 2px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(4)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="4">
                            <div style="width: 4px; height: 4px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(6)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="6">
                            <div style="width: 6px; height: 6px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(8)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="8">
                            <div style="width: 8px; height: 8px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(11)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="11">
                            <div style="width: 11px; height: 11px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(14)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="14">
                            <div style="width: 14px; height: 14px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(16)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="16">
                            <div style="width: 16px; height: 16px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(18)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="18">
                            <div style="width: 18px; height: 18px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(20)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="20">
                            <div style="width: 20px; height: 20px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        
                        <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 mx-2"></div>
                        
                        <!-- Pressure Switch -->
                        <div class="flex items-center gap-2">
                            <i data-lucide="zap" class="w-3 h-3 text-gray-600 dark:text-gray-400"></i>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="pressureSwitch" class="sr-only peer" checked>
                                <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Pressure</span>
                        </div>
                    </div>
                </div>

                <!-- Color Settings -->
                <div id="colorSettings" class="hidden flex items-center gap-4">
                    <!-- Color Grid -->
                    <div class="grid grid-cols-10 gap-1">
                        <button onclick="setColor('#000000')" class="w-5 h-5 rounded-full bg-black border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#FFFFFF')" class="w-5 h-5 rounded-full bg-white border border-gray-400 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#6B7280')" class="w-5 h-5 rounded-full bg-gray-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EF4444')" class="w-5 h-5 rounded-full bg-red-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F97316')" class="w-5 h-5 rounded-full bg-orange-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F59E0B')" class="w-5 h-5 rounded-full bg-yellow-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#84CC16')" class="w-5 h-5 rounded-full bg-lime-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#10B981')" class="w-5 h-5 rounded-full bg-emerald-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#06B6D4')" class="w-5 h-5 rounded-full bg-cyan-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#3B82F6')" class="w-5 h-5 rounded-full bg-blue-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        
                        <button onclick="setColor('#6366F1')" class="w-5 h-5 rounded-full bg-indigo-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#8B5CF6')" class="w-5 h-5 rounded-full bg-violet-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#A855F7')" class="w-5 h-5 rounded-full bg-purple-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EC4899')" class="w-5 h-5 rounded-full bg-pink-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F43F5E')" class="w-5 h-5 rounded-full bg-rose-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#DC2626')" class="w-5 h-5 rounded-full bg-red-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#059669')" class="w-5 h-5 rounded-full bg-emerald-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#2563EB')" class="w-5 h-5 rounded-full bg-blue-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#7C3AED')" class="w-5 h-5 rounded-full bg-violet-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#92400E')" class="w-5 h-5 rounded-full bg-yellow-800 border border-gray-300 hover:scale-110 transition-transform"></button>
                    </div>
                </div>

                <!-- Eraser Settings -->
                <div id="eraserSettings" class="hidden">
                    <!-- Eraser Size Dots in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setEraserSize(4)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="4">
                            <div style="width: 4px; height: 4px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(12)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="12">
                            <div style="width: 12px; height: 12px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(25)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-eraser-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="25">
                            <div style="width: 25px; height: 25px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(35)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="35">
                            <div style="width: 35px; height: 35px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(50)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="50">
                            <div style="width: 50px; height: 50px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Page Navigation -->
            <div id="pageNavigation" class="fixed top-4 right-4 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-3 py-1.5 flex items-center gap-2">
                <button onclick="changePage(-1)" id="prevPageBtn" 
                        class="w-6 h-6 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="chevron-left" class="w-3 h-3 text-gray-700 dark:text-gray-300"></i>
                </button>
                
                <button onclick="openPageThumbnailModal()" class="flex items-center gap-1 px-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors">
                    <span id="currentPageNum" class="text-xs font-medium text-gray-900 dark:text-gray-100">1</span>
                    <span class="text-xs text-gray-500 dark:text-gray-400">/</span>
                    <span id="totalPagesNum" class="text-xs text-gray-500 dark:text-gray-400">1</span>
                </button>
                
                <button onclick="changePage(1)" id="nextPageBtn"
                        class="w-6 h-6 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="chevron-right" class="w-3 h-3 text-gray-700 dark:text-gray-300"></i>
                </button>
            </div>

            <!-- Bottom Toolbar -->
            <div id="floatingToolbar" class="fixed bottom-2 left-1/2 transform -translate-x-1/2 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-6 py-3 flex items-center gap-4">
                <!-- Tool Selection -->
                <button id="penTool" onclick="setTool('pen')" 
                        class="w-8 h-8 rounded-full flex items-center justify-center tool-active hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="pen-tool" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="eraserTool" onclick="setTool('eraser')" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="eraser" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="colorTool" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <div id="colorIndicator" class="w-5 h-5 rounded-full border-2 border-gray-400 dark:border-gray-500" style="background-color: #000000;"></div>
                </button>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600"></div>
                
                <!-- Actions -->
                <button onclick="openPresentationMode()" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="cast" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button onclick="toggleFullscreen()" id="fullscreenBtn"
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="maximize" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button onclick="clearCanvas()" 
                        class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="trash-2" class="w-4 h-4 text-red-600 dark:text-red-400"></i>
                </button>
            </div>

            <!-- Page Thumbnail Modal -->
            <div id="pageThumbnailModal" class="page-thumbnail-modal fixed inset-y-0 right-0 w-80 bg-white dark:bg-gray-800 shadow-2xl z-[70] border-l border-gray-200 dark:border-gray-700">
                <div class="h-full flex flex-col">
                    <!-- Header -->
                    <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
                        <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Pages</h3>
                        <button onclick="closePageThumbnailModal()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                            <i data-lucide="x" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                        </button>
                    </div>
                    
                    <!-- Thumbnails Container -->
                    <div id="thumbnailContainer" class="flex-1 overflow-y-auto p-4 space-y-3">
                        <!-- Thumbnails will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Modal Backdrop -->
            <div id="modalBackdrop" class="fixed inset-0 bg-black bg-opacity-50 z-[65] hidden" onclick="closePageThumbnailModal()"></div>

            <!-- PDF Content -->
            <div id="pdfContent" class="w-full h-full flex items-center justify-center overflow-auto"></div>
        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Application state
        let pdfDoc = null;
        let pdfArrayBuffer = null; // Store PDF data for presentation window
        let currentPage = 1;
        let totalPages = 0;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentBrushSize = 3;
        let currentEraserSize = 25;
        let pressureEnabled = true;
        let isDrawing = false;
        let drawingData = {}; // Store drawing data for each page with scale info
        let originalPageDimensions = {}; // Store original PDF page dimensions
        
        // Presentation mode state
        let presentationWindow = null;
        
        // Stylus eraser button state
        let originalTool = 'pen'; // Track the original tool before eraser button press
        let isEraserButtonPressed = false;

        // Double-click detection
        let lastClickTime = 0;
        let lastClickTarget = null;
        const DOUBLE_CLICK_DELAY = 300; // milliseconds

        // Drawing state
        let lastX = 0;
        let lastY = 0;

        // File upload handler
        document.getElementById('pdfUpload').addEventListener('change', handleFileUpload);

        // Settings event listeners
        function setupSettingsListeners() {
            // Pressure switch
            const pressureSwitch = document.getElementById('pressureSwitch');
            pressureSwitch.addEventListener('change', function() {
                pressureEnabled = this.checked;
            });

            // Theme toggle switch
            const themeToggle = document.getElementById('themeToggle');
            
            // Set initial state based on current theme
            themeToggle.checked = document.documentElement.classList.contains('dark');
            
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            // Tool buttons with double-click detection
            document.getElementById('penTool').addEventListener('pointerdown', handleToolDoubleClick);
            document.getElementById('eraserTool').addEventListener('pointerdown', handleToolDoubleClick);
            document.getElementById('colorTool').addEventListener('pointerdown', handleColorSingleClick);
        }

        // Brush size selection
        function setBrushSize(size) {
            currentBrushSize = size;
            
            // Update visual selection
            document.querySelectorAll('.brush-size-dot').forEach(btn => {
                btn.classList.remove('selected-size');
            });
            document.querySelector(`[data-size="${size}"]`).classList.add('selected-size');
            
            // Close modal after selection
            hideSettingsModal();
        }

        // Eraser size selection
        function setEraserSize(size) {
            currentEraserSize = size;
            
            // Update visual selection
            document.querySelectorAll('.eraser-size-dot').forEach(btn => {
                btn.classList.remove('selected-eraser-size');
            });
            document.querySelector(`[data-eraser-size="${size}"]`).classList.add('selected-eraser-size');
            
            // Close modal after selection
            hideSettingsModal();
        }

        // Handle double-click on tool buttons
        function handleToolDoubleClick(e) {
            if (e.pointerType !== 'pen') return;
            
            const currentTime = Date.now();
            const target = e.currentTarget;
            
            if (lastClickTarget === target && (currentTime - lastClickTime) < DOUBLE_CLICK_DELAY) {
                // Double-click detected
                e.preventDefault();
                const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                showSettingsModal(toolType);
            } else {
                // Single click - set tool
                setTimeout(() => {
                    if (Date.now() - currentTime >= DOUBLE_CLICK_DELAY) {
                        const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                        setTool(toolType);
                    }
                }, DOUBLE_CLICK_DELAY);
            }
            
            lastClickTime = currentTime;
            lastClickTarget = target;
        }

        // Handle single-click on color button
        function handleColorSingleClick(e) {
            if (e.pointerType !== 'pen') return;
            
            // Immediately show color picker on single tap
            e.preventDefault();
            showSettingsModal('color');
        }

        // Modal management
        function showSettingsModal(toolType) {
            const modal = document.getElementById('settingsModal');
            const penSettings = document.getElementById('penSettings');
            const eraserSettings = document.getElementById('eraserSettings');
            const colorSettings = document.getElementById('colorSettings');
            
            // Hide all settings panels
            penSettings.classList.add('hidden');
            eraserSettings.classList.add('hidden');
            colorSettings.classList.add('hidden');
            
            // Show the appropriate settings panel
            if (toolType === 'pen') {
                penSettings.classList.remove('hidden');
            } else if (toolType === 'eraser') {
                eraserSettings.classList.remove('hidden');
            } else if (toolType === 'color') {
                colorSettings.classList.remove('hidden');
            }
            
            // Show the modal
            modal.classList.remove('hidden');
        }

        function hideSettingsModal() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('hidden');
        }

        // Click outside modal to close
        document.addEventListener('pointerdown', function(e) {
            if (e.pointerType !== 'pen') return;
            
            const modal = document.getElementById('settingsModal');
            const toolbar = document.getElementById('floatingToolbar');
            
            if (!modal.contains(e.target) && !toolbar.contains(e.target) && !modal.classList.contains('hidden')) {
                hideSettingsModal();
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (!pdfDoc) return;
            
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                changePage(-1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                changePage(1);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closePDF();
            }
        });

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfArrayBuffer = arrayBuffer.slice(); // Store a copy for presentation window
                pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                drawingData = {}; // Reset drawing data
                
                // Hide upload area and header, show PDF viewer
                document.getElementById('uploadArea').style.display = 'none';
                document.querySelector('header').style.display = 'none';
                document.getElementById('pdfViewer').classList.remove('hidden');
                
                await renderPage(currentPage);
                document.getElementById('downloadBtn').disabled = false;
                
                // Update page navigation UI
                updatePageNavigation();
            } catch (error) {
                console.error('Error loading PDF:', error);
                showCustomAlert('Error loading PDF file. Please try again.');
            }
        }

        async function renderPage(pageNum, withTransition = false, direction = 1) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const container = document.getElementById('pdfContent');
                
                console.log('renderPage called with transition:', withTransition, 'direction:', direction); // Debug log
                
                if (withTransition) {
                    console.log('Starting fade transition'); // Debug log
                    await performFadeTransition(pageNum, direction);
                    return;
                }
                
                // Calculate scale to fit the screen width (with small margin to prevent scrollbars)
                const containerWidth = window.innerWidth - 20; // Small margin to prevent overflow
                const viewport = page.getViewport({ scale: 1 });
                
                // Ultra-High-DPI rendering: Scale to fill the width, then render at 4x resolution for maximum quality
                const displayScale = containerWidth / viewport.width;
                const renderScale = displayScale * 4; // 4x resolution for ultra-high quality
                const scaledViewport = page.getViewport({ scale: renderScale });
                
                // Calculate display dimensions (what user sees)
                const displayWidth = Math.floor(containerWidth);
                const displayHeight = Math.floor(viewport.height * displayScale);

                // Create page container with display dimensions
                const pageContainer = document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.style.width = displayWidth + 'px';
                pageContainer.style.height = displayHeight + 'px';

                // Create and setup PDF canvas with high resolution
                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;  // High resolution (2x)
                pdfCanvas.height = scaledViewport.height; // High resolution (2x)
                pdfCanvas.style.width = displayWidth + 'px';  // Display size
                pdfCanvas.style.height = displayHeight + 'px'; // Display size
                pdfCanvas.style.display = 'block';

                // Create and setup drawing canvas with NORMAL resolution for performance
                const drawingCanvas = document.createElement('canvas');
                drawingCanvas.className = 'drawing-canvas';
                drawingCanvas.width = displayWidth;   // Normal resolution for smooth drawing
                drawingCanvas.height = displayHeight; // Normal resolution for smooth drawing
                drawingCanvas.style.width = displayWidth + 'px';  // Display size
                drawingCanvas.style.height = displayHeight + 'px'; // Display size

                // Setup drawing event listeners
                setupDrawingEvents(drawingCanvas);

                // Clear container and add new elements
                container.innerHTML = '';
                pageContainer.appendChild(pdfCanvas);
                pageContainer.appendChild(drawingCanvas);
                container.appendChild(pageContainer);

                // Store original page dimensions for first render or if not stored
                if (!originalPageDimensions[pageNum]) {
                    originalPageDimensions[pageNum] = {
                        width: viewport.width,
                        height: viewport.height
                    };
                }

                // Render PDF page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;

                // Restore drawing data for this page with proper scaling
                if (drawingData[pageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    const img = new Image();
                    img.onload = function() {
                        // Calculate scaling factors based on canvas size changes (use drawing canvas dimensions)
                        const scaleX = drawingCanvas.width / drawingData[pageNum].canvasWidth;
                        const scaleY = drawingCanvas.height / drawingData[pageNum].canvasHeight;
                        
                        // Scale and draw the image to fit the new canvas size
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                    };
                    img.src = drawingData[pageNum].imageData;
                }

                // Reset any transition styles
                container.style.transition = '';
                container.style.transform = '';

            } catch (error) {
                console.error('Error rendering page:', error);
                // Reset styles on error
                const container = document.getElementById('pdfContent');
                container.style.transition = '';
                container.style.transform = '';
            }
        }

        async function performFadeTransition(targetPageNum, direction) {
            const container = document.getElementById('pdfContent');
            const currentPageElement = container.firstElementChild;
            
            // Calculate scale for consistent sizing with ultra-high quality
            const containerWidth = window.innerWidth - 20;
            const targetPage = await pdfDoc.getPage(targetPageNum);
            const viewport = targetPage.getViewport({ scale: 1 });
            
            // Ultra-High-DPI rendering: Same 4x scaling as main render
            const displayScale = containerWidth / viewport.width;
            const renderScale = displayScale * 4; // 4x resolution for ultra-high quality
            const scaledViewport = targetPage.getViewport({ scale: renderScale });
            
            // Calculate display dimensions (what user sees)
            const displayWidth = Math.floor(containerWidth);
            const displayHeight = Math.floor(viewport.height * displayScale);

            // Create new page container
            const newPageContainer = document.createElement('div');
            newPageContainer.className = 'pdf-page-container';
            newPageContainer.style.cssText = `
                width: ${displayWidth}px;
                height: ${displayHeight}px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                opacity: 0;
                transition: opacity 0.4s ease-in-out;
            `;

            // Create PDF canvas with ultra-high resolution
            const pdfCanvas = document.createElement('canvas');
            pdfCanvas.width = scaledViewport.width;  // Ultra-high resolution (4x)
            pdfCanvas.height = scaledViewport.height; // Ultra-high resolution (4x)
            pdfCanvas.style.width = displayWidth + 'px';  // Display size
            pdfCanvas.style.height = displayHeight + 'px'; // Display size
            pdfCanvas.style.display = 'block';

            // Create drawing canvas with NORMAL resolution for performance
            const drawingCanvas = document.createElement('canvas');
            drawingCanvas.className = 'drawing-canvas';
            drawingCanvas.width = displayWidth;   // Normal resolution for smooth drawing
            drawingCanvas.height = displayHeight; // Normal resolution for smooth drawing
            drawingCanvas.style.width = displayWidth + 'px';  // Display size
            drawingCanvas.style.height = displayHeight + 'px'; // Display size

            newPageContainer.appendChild(pdfCanvas);
            newPageContainer.appendChild(drawingCanvas);

            // Render the new page
            const renderContext = {
                canvasContext: pdfCanvas.getContext('2d'),
                viewport: scaledViewport
            };
            await targetPage.render(renderContext).promise;

            // Restore drawing data for new page
            if (drawingData[targetPageNum]) {
                const ctx = drawingCanvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                    // Calculate scaling factors based on canvas size changes (use drawing canvas dimensions)
                    const scaleX = drawingCanvas.width / drawingData[targetPageNum].canvasWidth;
                    const scaleY = drawingCanvas.height / drawingData[targetPageNum].canvasHeight;
                    
                    ctx.save();
                    ctx.scale(scaleX, scaleY);
                    ctx.drawImage(img, 0, 0);
                    ctx.restore();
                };
                img.src = drawingData[targetPageNum].imageData;
            }

            // Position current page absolutely and prepare for fade out
            if (currentPageElement) {
                currentPageElement.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    opacity: 1;
                    transition: opacity 0.5s ease-in-out;
                `;
            }

            // Add new page to container (behind current page)
            container.appendChild(newPageContainer);

            // Force reflow
            newPageContainer.offsetHeight;

            // Start fade transition
            if (currentPageElement) {
                currentPageElement.style.opacity = '0';
            }
            newPageContainer.style.opacity = '1';

            // Wait for fade animation to complete
            await new Promise(resolve => setTimeout(resolve, 400));

            // Clean up: remove old page and reset container
            container.innerHTML = '';
            
            // Reset new page styles to normal positioning
            newPageContainer.style.cssText = `
                width: ${displayWidth}px;
                height: ${displayHeight}px;
                position: relative;
                margin: 0 auto;
                opacity: 1;
            `;
            
            container.appendChild(newPageContainer);

            // Setup drawing events for new page
            setupDrawingEvents(drawingCanvas);

            console.log('Fade transition complete'); // Debug log
        }

        function setupDrawingEvents(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Enhanced ink quality settings
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Stroke smoothing variables
            let points = [];
            let pressureHistory = [];
            const maxHistoryLength = 5;

            // Create eraser indicator
            const eraserIndicator = document.createElement('div');
            eraserIndicator.id = 'eraserIndicator';
            eraserIndicator.style.cssText = `
                position: absolute;
                border: 2px dashed #666;
                border-radius: 50%;
                pointer-events: none;
                z-index: 15;
                display: none;
                background: rgba(255, 255, 255, 0.1);
            `;
            document.body.appendChild(eraserIndicator);

            // Pointer events for stylus detection
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', draw);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointercancel', stopDrawing);
            
            // Only stop drawing on pointerout if we're actually drawing and the pointer leaves the document
            canvas.addEventListener('pointerout', (e) => {
                // Only stop if we're actually drawing and the pointer is leaving the entire viewport
                if (isDrawing && (e.clientX < 0 || e.clientY < 0 || 
                    e.clientX > window.innerWidth || e.clientY > window.innerHeight)) {
                    stopDrawing(e);
                }
            });

            // Prevent default touch and mouse behaviors to avoid conflicts
            canvas.addEventListener('touchstart', e => e.preventDefault());
            canvas.addEventListener('touchmove', e => e.preventDefault());
            canvas.addEventListener('touchend', e => e.preventDefault());
            canvas.addEventListener('mousedown', e => e.preventDefault());
            canvas.addEventListener('mousemove', e => e.preventDefault());
            canvas.addEventListener('mouseup', e => e.preventDefault());
            
            // Samsung S-Pen specific: Handle context menu event (S-Pen button press)
            canvas.addEventListener('contextmenu', handleSPenContextMenu);
            document.addEventListener('contextmenu', handleSPenContextMenu);

            function startDrawing(e) {
                // Only allow pen input (Microsoft Pen Protocol stylus)
                if (e.pointerType !== 'pen') {
                    return;
                }

                // Debug logging for Samsung S-Pen detection
                console.log('Pointer event details:', {
                    button: e.button,
                    buttons: e.buttons,
                    buttonsBinary: e.buttons.toString(2),
                    pointerType: e.pointerType,
                    pressure: e.pressure,
                    tangentialPressure: e.tangentialPressure,
                    tiltX: e.tiltX,
                    tiltY: e.tiltY,
                    twist: e.twist
                });

                // Enhanced eraser detection for multiple stylus types
                // MPP Stylus: button 2 (right click) or button 5 (eraser), buttons bitmask bit 2 = 4
                // Samsung S-Pen: Various patterns - button 2, 5, or different bitmasks
                // Some S-Pens: Use eraser tip detection or specific button combinations
                const eraserButtonPressed = 
                    e.button === 2 ||           // Standard right-click/barrel button
                    e.button === 5 ||           // Standard eraser button
                    e.button === 1 ||           // Some S-Pens use button 1 for eraser
                    (e.buttons & 2) !== 0 ||    // Right button bitmask
                    (e.buttons & 4) !== 0 ||    // Middle/barrel button bitmask
                    (e.buttons & 32) !== 0 ||   // Eraser button bitmask (some devices)
                    
                    // Samsung S-Pen specific: Check for eraser tip by pressure patterns
                    (e.pressure === 0 && e.pointerType === 'pen') ||
                    
                    // Samsung S-Pen: Some models send tangential pressure for eraser
                    (e.tangentialPressure && e.tangentialPressure !== 0);
                
                if (eraserButtonPressed && !isEraserButtonPressed) {
                    // Store original tool and switch to eraser
                    originalTool = currentTool;
                    isEraserButtonPressed = true;
                    if (currentTool !== 'eraser') {
                        setTool('eraser');
                    }
                } else if (!eraserButtonPressed && isEraserButtonPressed) {
                    // Restore original tool when eraser button is released
                    isEraserButtonPressed = false;
                    setTool(originalTool);
                }

                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                
                // Calculate coordinates accounting for high-DPI scaling
                const displayX = e.clientX - rect.left;
                const displayY = e.clientY - rect.top;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                lastX = displayX * scaleX;
                lastY = displayY * scaleY;
                
                // Reset stroke history for new stroke
                points = [];
                pressureHistory = [];
                
                // Add initial point
                const pressure = e.pressure || 0.5;
                points.push({ x: lastX, y: lastY, pressure: pressure });
                pressureHistory.push(pressure);
                
                // Show eraser indicator if using eraser tool
                if (currentTool === 'eraser') {
                    showEraserIndicator(e.clientX, e.clientY);
                }
                
                // Update pressure indicator
                updatePressureIndicator(pressure);
            }

            function draw(e) {
                // Only allow pen input
                if (e.pointerType !== 'pen' || !isDrawing) {
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                
                // Calculate coordinates accounting for high-DPI scaling
                const displayX = e.clientX - rect.left;
                const displayY = e.clientY - rect.top;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const currentX = displayX * scaleX;
                const currentY = displayY * scaleY;

                // Update eraser indicator position if using eraser tool
                if (currentTool === 'eraser') {
                    updateEraserIndicator(e.clientX, e.clientY);
                }

                // Get pressure value
                const pressure = e.pressure || 0.5;
                
                // Add current point to history for smoothing
                points.push({ x: currentX, y: currentY, pressure: pressure });
                pressureHistory.push(pressure);
                
                // Keep history within limits
                if (points.length > maxHistoryLength) {
                    points.shift();
                    pressureHistory.shift();
                }

                ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                
                // Use appropriate size based on tool (scale up for high-DPI)
                const scaleFactor = Math.min(scaleX, scaleY);
                const toolSize = (currentTool === 'eraser' ? currentEraserSize : currentBrushSize) * scaleFactor;
                
                if (currentTool === 'eraser') {
                    // Eraser: Simple consistent rendering
                    ctx.lineWidth = toolSize;
                    ctx.strokeStyle = currentColor; // For composite operation
                    
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                } else {
                    // Pen: Enhanced ink rendering with smoothing and pressure
                    drawSmoothStroke(ctx, points, pressureHistory, toolSize);
                }

                // Update presentation window in real-time
                updatePresentationWindowRealtime(lastX, lastY, currentX, currentY, ctx.lineWidth, currentTool, currentColor);

                lastX = currentX;
                lastY = currentY;
                
                // Update pressure indicator (but only for pen tool)
                if (currentTool === 'pen') {
                    updatePressureIndicator(pressure);
                }
            }
            
            // Advanced smooth stroke rendering function
            function drawSmoothStroke(ctx, points, pressureHistory, baseSize) {
                if (points.length < 2) return;
                
                // Smooth pressure calculation
                const avgPressure = pressureHistory.reduce((sum, p) => sum + p, 0) / pressureHistory.length;
                const smoothPressure = pressureEnabled ? avgPressure : 0.7;
                
                // Calculate dynamic line width with pressure
                const pressureMultiplier = pressureEnabled ? (0.3 + (smoothPressure * 1.4)) : 1.0;
                const dynamicWidth = baseSize * pressureMultiplier;
                
                // Use solid, opaque color - no transparency
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = dynamicWidth;
                
                // Smooth curve drawing using quadratic curves
                if (points.length >= 3) {
                    const p0 = points[points.length - 3];
                    const p1 = points[points.length - 2];
                    const p2 = points[points.length - 1];
                    
                    // Calculate control point for smooth curve
                    const midPoint1 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
                    const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                    
                    ctx.beginPath();
                    ctx.moveTo(midPoint1.x, midPoint1.y);
                    ctx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
                    ctx.stroke();
                } else if (points.length === 2) {
                    // Fallback for first stroke segment
                    const p1 = points[0];
                    const p2 = points[1];
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
            
            // Helper function to convert hex color to rgba
            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function stopDrawing(e) {
                // Only process pen input
                if (e.pointerType !== 'pen') return;
                
                if (isDrawing) {
                    isDrawing = false;
                    // Save drawing data for current page with canvas dimensions
                    drawingData[currentPage] = {
                        imageData: canvas.toDataURL(),
                        canvasWidth: canvas.width,
                        canvasHeight: canvas.height
                    };
                    
                    // Hide eraser indicator
                    hideEraserIndicator();
                    
                    // Reset pressure indicator
                    updatePressureIndicator(0);
                }
            }

            function showEraserIndicator(clientX, clientY) {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator) {
                    const size = currentEraserSize;
                    indicator.style.width = size + 'px';
                    indicator.style.height = size + 'px';
                    indicator.style.left = (clientX - size/2) + 'px';
                    indicator.style.top = (clientY - size/2) + 'px';
                    indicator.style.display = 'block';
                }
            }

            function updateEraserIndicator(clientX, clientY) {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator && indicator.style.display === 'block') {
                    const size = currentEraserSize;
                    indicator.style.left = (clientX - size/2) + 'px';
                    indicator.style.top = (clientY - size/2) + 'px';
                }
            }

            function hideEraserIndicator() {
                const indicator = document.getElementById('eraserIndicator');
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }
        }



        // Samsung S-Pen Context Menu Handler (Galaxy Tab S7 eraser button)
        function handleSPenContextMenu(e) {
            console.log('Context menu event triggered:', {
                type: e.type,
                pointerType: e.pointerType,
                button: e.button,
                buttons: e.buttons,
                target: e.target.tagName,
                timestamp: Date.now()
            });
            
            // Check if this is S-Pen related (prevent regular context menus from being affected)
            if (e.pointerType === 'pen' || 
                (e.target && e.target.classList && e.target.classList.contains('drawing-canvas'))) {
                
                e.preventDefault(); // Prevent context menu from showing
                e.stopPropagation();
                
                console.log('S-Pen eraser button detected via context menu!');
                
                // Toggle eraser mode when S-Pen button is pressed
                if (!isEraserButtonPressed) {
                    console.log('Switching to eraser mode');
                    originalTool = currentTool;
                    isEraserButtonPressed = true;
                    if (currentTool !== 'eraser') {
                        setTool('eraser');
                    }
                } else {
                    console.log('Switching back to original tool:', originalTool);
                    isEraserButtonPressed = false;
                    setTool(originalTool);
                }
                
                return false;
            }
        }

        function updatePressureIndicator(pressure) {
            const indicator = document.getElementById('pressureIndicator');
            if (indicator) {
                const percentage = Math.round(pressure * 100);
                indicator.textContent = `Pressure: ${percentage}%`;
            }
        }

        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                
                // Update page navigation UI
                updatePageNavigation();
                
                // Start transitions in both windows simultaneously
                renderPage(currentPage, true, direction); // Main window fade transition
                
                // Trigger presentation window fade transition if open
                if (presentationWindow && !presentationWindow.closed) {
                    triggerPresentationFadeTransition(currentPage, direction);
                }
            }
        }

        // Update page navigation UI
        function updatePageNavigation() {
            // Update page numbers
            document.getElementById('currentPageNum').textContent = currentPage;
            document.getElementById('totalPagesNum').textContent = totalPages;
            
            // Update button states
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            // Disable previous button if on first page
            if (currentPage <= 1) {
                prevBtn.disabled = true;
                prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                prevBtn.disabled = false;
                prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
            
            // Disable next button if on last page
            if (currentPage >= totalPages) {
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                nextBtn.disabled = false;
                nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
            
            // Update thumbnail selection if modal is open
            updateThumbnailSelection();
        }

        // Page Thumbnail Modal Functions
        async function openPageThumbnailModal() {
            if (!pdfDoc) return;

            const modal = document.getElementById('pageThumbnailModal');
            const backdrop = document.getElementById('modalBackdrop');
            const container = document.getElementById('thumbnailContainer');

            // Show backdrop
            backdrop.classList.remove('hidden');

            // Always regenerate thumbnails for better quality (force refresh)
            await generatePageThumbnails();

            // Update current page selection
            updateThumbnailSelection();

            // Show modal with slide animation
            setTimeout(() => {
                modal.classList.add('open');
            }, 10);

            // Scroll to current page
            scrollToCurrentThumbnail();
        }

        function closePageThumbnailModal() {
            const modal = document.getElementById('pageThumbnailModal');
            const backdrop = document.getElementById('modalBackdrop');

            // Hide modal with slide animation
            modal.classList.remove('open');

            // Hide backdrop after animation
            setTimeout(() => {
                backdrop.classList.add('hidden');
            }, 300);
        }

        async function generatePageThumbnails() {
            const container = document.getElementById('thumbnailContainer');
            container.innerHTML = '<div class="text-center py-8"><div class="text-gray-500 dark:text-gray-400">Generating thumbnails...</div></div>';

            const thumbnails = [];

            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    // Ultra-high quality thumbnails - scale to fit width of ~400px for crisp display
                    const targetWidth = 400;
                    const viewport = page.getViewport({ scale: 1 });
                    const scale = targetWidth / viewport.width;
                    const scaledViewport = page.getViewport({ scale });

                    // Create thumbnail container
                    const thumbnailDiv = document.createElement('div');
                    thumbnailDiv.className = 'page-thumbnail bg-white dark:bg-gray-700 rounded-lg border-2 border-gray-200 dark:border-gray-600 overflow-hidden cursor-pointer';
                    thumbnailDiv.setAttribute('data-page', pageNum);
                    thumbnailDiv.onclick = () => goToPage(pageNum);

                    // Create canvas for PDF with higher resolution
                    const canvas = document.createElement('canvas');
                    canvas.width = scaledViewport.width;
                    canvas.height = scaledViewport.height;
                    canvas.className = 'w-full h-auto';

                    // Create canvas for drawings overlay with higher resolution
                    const drawingCanvas = document.createElement('canvas');
                    drawingCanvas.width = scaledViewport.width;
                    drawingCanvas.height = scaledViewport.height;
                    drawingCanvas.className = 'absolute top-0 left-0 w-full h-auto';

                    // Container for canvases
                    const canvasContainer = document.createElement('div');
                    canvasContainer.className = 'relative';
                    canvasContainer.appendChild(canvas);
                    canvasContainer.appendChild(drawingCanvas);

                    // Page number label
                    const pageLabel = document.createElement('div');
                    pageLabel.className = 'p-2 text-xs text-center text-gray-600 dark:text-gray-400 border-t border-gray-200 dark:border-gray-600';
                    pageLabel.textContent = `Page ${pageNum}`;

                    thumbnailDiv.appendChild(canvasContainer);
                    thumbnailDiv.appendChild(pageLabel);

                    // Render PDF page with higher quality
                    const renderContext = {
                        canvasContext: canvas.getContext('2d'),
                        viewport: scaledViewport
                    };
                    await page.render(renderContext).promise;

                    // Render drawings if they exist with proper scaling
                    if (drawingData[pageNum]) {
                        const ctx = drawingCanvas.getContext('2d');
                        const img = new Image();
                        img.onload = function() {
                            const scaleX = scaledViewport.width / drawingData[pageNum].canvasWidth;
                            const scaleY = scaledViewport.height / drawingData[pageNum].canvasHeight;
                            
                            ctx.save();
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(img, 0, 0);
                            ctx.restore();
                        };
                        img.src = drawingData[pageNum].imageData;
                    }

                    thumbnails.push(thumbnailDiv);

                } catch (error) {
                    console.error(`Error generating thumbnail for page ${pageNum}:`, error);
                }
            }

            // Clear loading message and add all thumbnails
            container.innerHTML = '';
            thumbnails.forEach(thumb => container.appendChild(thumb));

            // Initialize icons for the thumbnails
            initializeLucideIcons();
        }

        function updateThumbnailSelection() {
            const thumbnails = document.querySelectorAll('.page-thumbnail');
            thumbnails.forEach(thumb => {
                const pageNum = parseInt(thumb.getAttribute('data-page'));
                if (pageNum === currentPage) {
                    thumb.classList.add('current');
                } else {
                    thumb.classList.remove('current');
                }
            });
        }

        function scrollToCurrentThumbnail() {
            const container = document.getElementById('thumbnailContainer');
            const currentThumbnail = container.querySelector(`[data-page="${currentPage}"]`);
            
            if (currentThumbnail) {
                // Scroll to center the current thumbnail
                const containerHeight = container.clientHeight;
                const thumbnailTop = currentThumbnail.offsetTop;
                const thumbnailHeight = currentThumbnail.offsetHeight;
                
                const scrollPosition = thumbnailTop - (containerHeight / 2) + (thumbnailHeight / 2);
                container.scrollTo({
                    top: Math.max(0, scrollPosition),
                    behavior: 'smooth'
                });
            }
        }

        function goToPage(pageNum) {
            if (pageNum >= 1 && pageNum <= totalPages && pageNum !== currentPage) {
                const direction = pageNum > currentPage ? 1 : -1;
                currentPage = pageNum;
                
                // Update page navigation UI
                updatePageNavigation();
                
                // Start transitions in both windows
                renderPage(currentPage, true, direction);
                
                // Trigger presentation window fade transition if open
                if (presentationWindow && !presentationWindow.closed) {
                    triggerPresentationFadeTransition(currentPage, direction);
                }
                
                // Close the modal
                closePageThumbnailModal();
            }
        }

        // Presentation Mode Functions
        function openPresentationMode() {
            if (!pdfDoc || !pdfArrayBuffer) {
                showCustomAlert('Please load a PDF first before opening presentation mode.');
                return;
            }

            // Check if presentation window is already open
            if (presentationWindow && !presentationWindow.closed) {
                showConfirmDialog('Close the presentation window?', () => {
                    presentationWindow.close();
                    presentationWindow = null;
                });
                return;
            }

            // Open new presentation window
            const windowFeatures = 'width=1280,height=720,resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no';
            presentationWindow = window.open('about:blank', 'PDFPresentation', windowFeatures);
            
            if (presentationWindow) {
                // Handle presentation window close
                presentationWindow.addEventListener('beforeunload', () => {
                    presentationWindow = null;
                });
                
                // Create and inject presentation HTML
                const presentationHTML = createPresentationHTML();
                presentationWindow.document.write(presentationHTML);
                presentationWindow.document.close();
                
                // Use a different approach - wait for the window's load event
                presentationWindow.addEventListener('load', () => {
                    // Additional wait to ensure PDF.js is loaded
                    setTimeout(() => {
                        initializePresentationWindow();
                    }, 300);
                });
                
                // Backup initialization in case load event doesn't fire
                setTimeout(() => {
                    if (presentationWindow && !presentationWindow.closed) {
                        initializePresentationWindow();
                    }
                }, 1000);
                
            } else {
                showCustomAlert('Unable to open presentation window. Please allow popups for this site.');
            }
        }

        // Initialize presentation window with PDF data
        function initializePresentationWindow() {
            if (!presentationWindow || presentationWindow.closed) return;
            
            try {
                // Use postMessage for more reliable cross-window communication
                const initData = {
                    type: 'INIT_PDF',
                    pdfArrayBuffer: pdfArrayBuffer,
                    currentPage: currentPage,
                    totalPages: totalPages,
                    drawingData: drawingData
                };
                
                presentationWindow.postMessage(initData, '*');
                
            } catch (error) {
                console.error('Error initializing presentation window:', error);
                // Fallback to direct property assignment
                try {
                    presentationWindow.pdfArrayBuffer = pdfArrayBuffer;
                    presentationWindow.currentPage = currentPage;
                    presentationWindow.totalPages = totalPages;
                    presentationWindow.drawingData = drawingData;
                    
                    presentationWindow.eval(`
                        if (typeof initializePDF === 'function') {
                            initializePDF();
                        }
                    `);
                } catch (fallbackError) {
                    console.error('Fallback initialization also failed:', fallbackError);
                }
            }
        }

        function createPresentationHTML() {
            return '<!DOCTYPE html>' +
                '<html lang="en">' +
                '<head>' +
                    '<meta charset="UTF-8">' +
                    '<meta name="viewport" content="width=device-width, initial-scale=1.0">' +
                    '<title>PDF Presentation</title>' +
                    '<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"><\/script>' +
                    '<style>' +
                        'body {' +
                            'margin: 0;' +
                            'padding: 0;' +
                            'background: #000;' +
                            'display: flex;' +
                            'justify-content: center;' +
                            'align-items: center;' +
                            'min-height: 100vh;' +
                            'overflow: hidden;' +
                        '}' +
                        '#presentationContent {' +
                            'display: flex;' +
                            'justify-content: center;' +
                            'align-items: center;' +
                            'width: 100%;' +
                            'height: 100vh;' +
                        '}' +
                        '.pdf-page-container {' +
                            'position: relative;' +
                        '}' +
                        '.presentation-canvas {' +
                            'position: absolute;' +
                            'top: 0;' +
                            'left: 0;' +
                        '}' +
                        '#fullscreenBtn {' +
                            'position: fixed;' +
                            'top: 20px;' +
                            'right: 20px;' +
                            'z-index: 1000;' +
                            'background: rgba(255, 255, 255, 0.9);' +
                            'border: none;' +
                            'border-radius: 8px;' +
                            'padding: 12px 16px;' +
                            'cursor: pointer;' +
                            'font-size: 14px;' +
                            'font-weight: 600;' +
                            'color: #374151;' +
                            'box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);' +
                            'transition: all 0.2s ease;' +
                            'display: flex;' +
                            'align-items: center;' +
                            'gap: 8px;' +
                        '}' +
                        '#fullscreenBtn:hover {' +
                            'background: rgba(255, 255, 255, 1);' +
                            'transform: translateY(-1px);' +
                            'box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);' +
                        '}' +
                        '#fullscreenBtn:active {' +
                            'transform: translateY(0);' +
                        '}' +
                        '#fullscreenBtn svg {' +
                            'width: 16px;' +
                            'height: 16px;' +
                        '}' +
                        '.fullscreen-hidden {' +
                            'opacity: 0;' +
                            'pointer-events: none;' +
                            'transform: translateY(-10px);' +
                        '}' +
                    '</style>' +
                '</head>' +
                '<body>' +
                    '<button id="fullscreenBtn" onclick="enterFullscreen()">' +
                        '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>' +
                        '</svg>' +
                        'Fullscreen' +
                    '</button>' +
                    '<div id="presentationContent"></div>' +
                    '<script>' +
                        'pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";' +
                        'window.addEventListener("resize", () => {' +
                            'if (window.currentRenderFunction) {' +
                                'window.currentRenderFunction();' +
                            '}' +
                        '});' +
                        'window.addEventListener("message", async function(event) {' +
                            'if (event.data && event.data.type === "INIT_PDF") {' +
                                'try {' +
                                    'window.pdfArrayBuffer = event.data.pdfArrayBuffer;' +
                                    'window.currentPage = event.data.currentPage;' +
                                    'window.totalPages = event.data.totalPages;' +
                                    'window.drawingData = event.data.drawingData;' +
                                    'if (window.pdfArrayBuffer) {' +
                                        'window.presentationPdfDoc = await pdfjsLib.getDocument(window.pdfArrayBuffer).promise;' +
                                        'window.renderPresentationPage(window.currentPage);' +
                                    '}' +
                                '} catch (error) {' +
                                    'console.error("Error handling postMessage:", error);' +
                                '}' +
                            '} else if (event.data && event.data.type === "FADE_TRANSITION") {' +
                                'try {' +
                                    'window.drawingData = event.data.drawingData;' +
                                    'window.performPresentationFadeTransition(event.data.targetPageNum, event.data.direction);' +
                                '} catch (error) {' +
                                    'console.error("Error handling fade transition:", error);' +
                                '}' +
                            '}' +
                        '});' +
                        'window.initializePDF = async function() {' +
                            'try {' +
                                'if (window.pdfArrayBuffer) {' +
                                    'window.presentationPdfDoc = await pdfjsLib.getDocument(window.pdfArrayBuffer).promise;' +
                                    'window.renderPresentationPage(window.currentPage || 1);' +
                                '}' +
                            '} catch (error) {' +
                                'console.error("Error in initializePDF:", error);' +
                            '}' +
                        '};' +
                        'window.renderPresentationPage = async function(pageNum) {' +
                            'if (!window.presentationPdfDoc) return;' +
                            'try {' +
                                'const page = await window.presentationPdfDoc.getPage(pageNum);' +
                                'const container = document.getElementById("presentationContent");' +
                                'const windowWidth = window.innerWidth;' +
                                'const windowHeight = window.innerHeight;' +
                                'const viewport = page.getViewport({ scale: 1 });' +
                                'const scaleX = windowWidth / viewport.width;' +
                                'const scaleY = (windowHeight - 10) / viewport.height;' +
                                'const scale = scaleX;' +
                                'const scaledViewport = page.getViewport({ scale });' +
                                'const pageContainer = document.createElement("div");' +
                                'pageContainer.className = "pdf-page-container";' +
                                'pageContainer.style.width = scaledViewport.width + "px";' +
                                'pageContainer.style.height = scaledViewport.height + "px";' +
                                'const pdfCanvas = document.createElement("canvas");' +
                                'pdfCanvas.width = scaledViewport.width;' +
                                'pdfCanvas.height = scaledViewport.height;' +
                                'pdfCanvas.style.display = "block";' +
                                'const drawingCanvas = document.createElement("canvas");' +
                                'drawingCanvas.className = "presentation-canvas";' +
                                'drawingCanvas.width = scaledViewport.width;' +
                                'drawingCanvas.height = scaledViewport.height;' +
                                'container.innerHTML = "";' +
                                'pageContainer.appendChild(pdfCanvas);' +
                                'pageContainer.appendChild(drawingCanvas);' +
                                'container.appendChild(pageContainer);' +
                                'const renderContext = {' +
                                    'canvasContext: pdfCanvas.getContext("2d"),' +
                                    'viewport: scaledViewport' +
                                '};' +
                                'await page.render(renderContext).promise;' +
                                'if (window.drawingData && window.drawingData[pageNum]) {' +
                                    'const ctx = drawingCanvas.getContext("2d");' +
                                    'const img = new Image();' +
                                    'img.onload = function() {' +
                                        'const scaleX = scaledViewport.width / window.drawingData[pageNum].canvasWidth;' +
                                        'const scaleY = scaledViewport.height / window.drawingData[pageNum].canvasHeight;' +
                                        'ctx.save();' +
                                        'ctx.scale(scaleX, scaleY);' +
                                        'ctx.drawImage(img, 0, 0);' +
                                        'ctx.restore();' +
                                    '};' +
                                    'img.src = window.drawingData[pageNum].imageData;' +
                                '}' +
                                'window.currentRenderFunction = () => window.renderPresentationPage(pageNum);' +
                            '} catch (error) {' +
                                'console.error("Error rendering presentation page:", error);' +
                            '}' +
                        '};' +
                        'window.performPresentationFadeTransition = async function(targetPageNum, direction) {' +
                            'if (!window.presentationPdfDoc) return;' +
                            'try {' +
                                'const container = document.getElementById("presentationContent");' +
                                'const currentPageElement = container.firstElementChild;' +
                                'const windowWidth = window.innerWidth;' +
                                'const windowHeight = window.innerHeight;' +
                                'const targetPage = await window.presentationPdfDoc.getPage(targetPageNum);' +
                                'const viewport = targetPage.getViewport({ scale: 1 });' +
                                'const scaleX = windowWidth / viewport.width;' +
                                'const scaleY = (windowHeight - 10) / viewport.height;' +
                                'const scale = scaleX;' +
                                'const scaledViewport = targetPage.getViewport({ scale });' +
                                'const newPageContainer = document.createElement("div");' +
                                'newPageContainer.className = "pdf-page-container";' +
                                'newPageContainer.style.cssText = `width: ${scaledViewport.width}px; height: ${scaledViewport.height}px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0; transition: opacity 0.5s ease-in-out;`;' +
                                'const pdfCanvas = document.createElement("canvas");' +
                                'pdfCanvas.width = scaledViewport.width;' +
                                'pdfCanvas.height = scaledViewport.height;' +
                                'pdfCanvas.style.display = "block";' +
                                'const drawingCanvas = document.createElement("canvas");' +
                                'drawingCanvas.className = "presentation-canvas";' +
                                'drawingCanvas.width = scaledViewport.width;' +
                                'drawingCanvas.height = scaledViewport.height;' +
                                'newPageContainer.appendChild(pdfCanvas);' +
                                'newPageContainer.appendChild(drawingCanvas);' +
                                'const renderContext = { canvasContext: pdfCanvas.getContext("2d"), viewport: scaledViewport };' +
                                'await targetPage.render(renderContext).promise;' +
                                'if (window.drawingData && window.drawingData[targetPageNum]) {' +
                                    'const ctx = drawingCanvas.getContext("2d");' +
                                    'const img = new Image();' +
                                    'img.onload = function() {' +
                                        'const scaleX = scaledViewport.width / window.drawingData[targetPageNum].canvasWidth;' +
                                        'const scaleY = scaledViewport.height / window.drawingData[targetPageNum].canvasHeight;' +
                                        'ctx.save();' +
                                        'ctx.scale(scaleX, scaleY);' +
                                        'ctx.drawImage(img, 0, 0);' +
                                        'ctx.restore();' +
                                    '};' +
                                    'img.src = window.drawingData[targetPageNum].imageData;' +
                                '}' +
                                'if (currentPageElement) {' +
                                    'currentPageElement.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 1; transition: opacity 0.5s ease-in-out;`;' +
                                '}' +
                                'container.appendChild(newPageContainer);' +
                                'newPageContainer.offsetHeight;' +
                                'if (currentPageElement) {' +
                                    'currentPageElement.style.opacity = "0";' +
                                '}' +
                                'newPageContainer.style.opacity = "1";' +
                                'await new Promise(resolve => setTimeout(resolve, 500));' +
                                'container.innerHTML = "";' +
                                'newPageContainer.style.cssText = `width: ${scaledViewport.width}px; height: ${scaledViewport.height}px; position: relative; opacity: 1;`;' +
                                'container.appendChild(newPageContainer);' +
                                'window.currentRenderFunction = () => window.renderPresentationPage(targetPageNum);' +
                            '} catch (error) {' +
                                'console.error("Error in presentation fade transition:", error);' +
                            '}' +
                        '};' +
                        'function enterFullscreen() {' +
                            'const btn = document.getElementById("fullscreenBtn");' +
                            'if (document.documentElement.requestFullscreen) {' +
                                'document.documentElement.requestFullscreen().then(() => {' +
                                    'btn.classList.add("fullscreen-hidden");' +
                                '}).catch(err => {' +
                                    'console.error("Error entering fullscreen:", err);' +
                                '});' +
                            '} else if (document.documentElement.webkitRequestFullscreen) {' +
                                'document.documentElement.webkitRequestFullscreen();' +
                                'btn.classList.add("fullscreen-hidden");' +
                            '} else if (document.documentElement.msRequestFullscreen) {' +
                                'document.documentElement.msRequestFullscreen();' +
                                'btn.classList.add("fullscreen-hidden");' +
                            '}' +
                        '}' +
                        'document.addEventListener("fullscreenchange", handleFullscreenChange);' +
                        'document.addEventListener("webkitfullscreenchange", handleFullscreenChange);' +
                        'document.addEventListener("msfullscreenchange", handleFullscreenChange);' +
                        'function handleFullscreenChange() {' +
                            'const btn = document.getElementById("fullscreenBtn");' +
                            'const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);' +
                            'if (isFullscreen) {' +
                                'btn.classList.add("fullscreen-hidden");' +
                            '} else {' +
                                'btn.classList.remove("fullscreen-hidden");' +
                            '}' +
                            'setTimeout(() => {' +
                                'if (window.currentRenderFunction) {' +
                                    'window.currentRenderFunction();' +
                                '}' +
                            '}, 100);' +
                        '}' +
                    '<\/script>' +
                '</body>' +
                '</html>';
        }

        async function renderPresentationPage(pageNum) {
            if (!presentationWindow || presentationWindow.closed || !pdfDoc) return;

            try {
                const page = await pdfDoc.getPage(pageNum);
                const container = presentationWindow.document.getElementById('presentationContent');
                
                // Calculate scale to fit the presentation window
                const windowWidth = presentationWindow.innerWidth;
                const windowHeight = presentationWindow.innerHeight;
                const viewport = page.getViewport({ scale: 1 });
                
                // Scale to fit both width and height with some padding
                const scaleX = (windowWidth - 40) / viewport.width;
                const scaleY = (windowHeight - 40) / viewport.height;
                const scale = Math.min(scaleX, scaleY);
                
                const scaledViewport = page.getViewport({ scale });

                // Create page container
                const pageContainer = presentationWindow.document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.style.width = scaledViewport.width + 'px';
                pageContainer.style.height = scaledViewport.height + 'px';

                // Create and setup PDF canvas
                const pdfCanvas = presentationWindow.document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;
                pdfCanvas.height = scaledViewport.height;
                pdfCanvas.style.display = 'block';

                // Create and setup presentation canvas for drawings
                const drawingCanvas = presentationWindow.document.createElement('canvas');
                drawingCanvas.className = 'presentation-canvas';
                drawingCanvas.width = scaledViewport.width;
                drawingCanvas.height = scaledViewport.height;

                // Clear container and add new elements
                container.innerHTML = '';
                pageContainer.appendChild(pdfCanvas);
                pageContainer.appendChild(drawingCanvas);
                container.appendChild(pageContainer);

                // Render PDF page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;

                // Restore drawing data for this page with proper scaling
                if (drawingData[pageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    const img = new Image();
                    img.onload = function() {
                        // Calculate scaling factors based on canvas size changes
                        const scaleX = scaledViewport.width / drawingData[pageNum].canvasWidth;
                        const scaleY = scaledViewport.height / drawingData[pageNum].canvasHeight;
                        
                        // Scale and draw the image to fit the new canvas size
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                    };
                    img.src = drawingData[pageNum].imageData;
                }

                // Store render function for window resize
                presentationWindow.currentRenderFunction = () => renderPresentationPage(pageNum);

            } catch (error) {
                console.error('Error rendering presentation page:', error);
            }
        }

        function updatePresentationWindow() {
            if (presentationWindow && !presentationWindow.closed) {
                try {
                    // Update drawing data in presentation window
                    presentationWindow.drawingData = drawingData;
                    presentationWindow.currentPage = currentPage;
                    
                    // Call the presentation window's render function
                    presentationWindow.renderPresentationPage(currentPage);
                } catch (error) {
                    console.error('Error updating presentation window:', error);
                }
            }
        }

        // Trigger fade transition in presentation window
        function triggerPresentationFadeTransition(targetPageNum, direction) {
            if (!presentationWindow || presentationWindow.closed) return;

            try {
                // Send message to presentation window to start fade transition
                presentationWindow.postMessage({
                    type: 'FADE_TRANSITION',
                    targetPageNum: targetPageNum,
                    direction: direction,
                    drawingData: drawingData
                }, '*');
            } catch (error) {
                console.error('Error triggering presentation fade transition:', error);
                // Fallback to direct update
                updatePresentationWindow();
            }
        }

        // Real-time presentation window update for drawing
        function updatePresentationWindowRealtime(fromX, fromY, toX, toY, lineWidth, tool, color) {
            if (!presentationWindow || presentationWindow.closed) return;

            try {
                const container = presentationWindow.document.getElementById('presentationContent');
                const drawingCanvas = container.querySelector('.presentation-canvas');
                if (!drawingCanvas) return;

                const ctx = drawingCanvas.getContext('2d');
                const mainCanvas = document.querySelector('.drawing-canvas');
                
                if (!mainCanvas) return;

                // Calculate scaling factors between main canvas and presentation canvas
                const scaleX = drawingCanvas.width / mainCanvas.width;
                const scaleY = drawingCanvas.height / mainCanvas.height;

                // Apply the same drawing properties
                ctx.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth * Math.min(scaleX, scaleY); // Scale line width proportionally
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw the line with scaled coordinates
                ctx.beginPath();
                ctx.moveTo(fromX * scaleX, fromY * scaleY);
                ctx.lineTo(toX * scaleX, toY * scaleY);
                ctx.stroke();

            } catch (error) {
                console.error('Error updating presentation window in real-time:', error);
            }
        }

        function closePDF() {
            // Show upload area and header, hide PDF viewer
            document.getElementById('uploadArea').style.display = 'block';
            document.querySelector('header').style.display = 'block';
            document.getElementById('pdfViewer').classList.add('hidden');
            
            // Reset state
            pdfDoc = null;
            currentPage = 1;
            totalPages = 0;
            drawingData = {};
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('pdfUpload').value = '';
        }

        function setTool(tool) {
            currentTool = tool;
            
            // Update tool buttons
            document.querySelectorAll('#penTool, #eraserTool').forEach(btn => {
                btn.classList.remove('tool-active');
            });
            
            if (tool === 'pen') {
                document.getElementById('penTool').classList.add('tool-active');
            } else if (tool === 'eraser') {
                document.getElementById('eraserTool').classList.add('tool-active');
            }

            // Update cursor
            const canvas = document.querySelector('.drawing-canvas');
            if (canvas) {
                canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            }
        }

        function setColor(color) {
            currentColor = color;
            
            // Update color indicator
            const colorIndicator = document.getElementById('colorIndicator');
            if (colorIndicator) {
                colorIndicator.style.backgroundColor = color;
            }
            
            // Close modal after selection
            hideSettingsModal();
        }

        function clearCanvas() {
            showConfirmDialog('Are you sure you want to clear all drawings on this page?', () => {
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    delete drawingData[currentPage];
                    
                    // Clear presentation window canvas in real-time
                    clearPresentationCanvas();
                }
            });
        }

        // Clear presentation window canvas
        function clearPresentationCanvas() {
            if (!presentationWindow || presentationWindow.closed) return;

            try {
                const container = presentationWindow.document.getElementById('presentationContent');
                const drawingCanvas = container.querySelector('.presentation-canvas');
                if (drawingCanvas) {
                    const ctx = drawingCanvas.getContext('2d');
                    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                }
            } catch (error) {
                console.error('Error clearing presentation canvas:', error);
            }
        }

        async function downloadPDF() {
            if (!pdfDoc) return;

            try {
                if (drawingData[currentPage]) {
                    const link = document.createElement('a');
                    link.download = `pdf-drawing-page-${currentPage}.png`;
                    link.href = drawingData[currentPage].imageData;
                    link.click();
                } else {
                    showCustomAlert('No drawings found on current page to download.');
                }
                
            } catch (error) {
                console.error('Error downloading:', error);
                showCustomAlert('Error downloading the file.');
            }
        }

        // Fullscreen functionality for Android devices
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    // Safari
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) {
                    // IE/Edge
                    element.msRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    // Firefox
                    element.mozRequestFullScreen();
                }
                
                // Update icon to minimize
                updateFullscreenIcon(true);
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                }
                
                // Update icon to maximize
                updateFullscreenIcon(false);
            }
        }

        function updateFullscreenIcon(isFullscreen) {
            const icon = document.querySelector('#fullscreenBtn i');
            if (icon) {
                if (isFullscreen) {
                    icon.setAttribute('data-lucide', 'minimize');
                } else {
                    icon.setAttribute('data-lucide', 'maximize');
                }
                // Reinitialize icons to update the display
                initializeLucideIcons();
            }
        }

        // Listen for fullscreen changes to update the icon
        document.addEventListener('fullscreenchange', () => {
            updateFullscreenIcon(!!document.fullscreenElement);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            updateFullscreenIcon(!!document.webkitFullscreenElement);
        });
        document.addEventListener('msfullscreenchange', () => {
            updateFullscreenIcon(!!document.msFullscreenElement);
        });
        document.addEventListener('mozfullscreenchange', () => {
            updateFullscreenIcon(!!document.mozFullScreenElement);
        });

        // Custom dialog functions (replacing alert/confirm)
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-primary text-white hover:bg-primary/90 rounded text-base" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showConfirmDialog(message, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base" onclick="this.closest('.fixed').remove()">Cancel</button>
                        <button class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded text-base" onclick="this.closest('.fixed').remove(); (${onConfirm})()">Confirm</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Initialize Lucide icons
        function initializeLucideIcons() {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                // Retry after a short delay if Lucide isn't loaded yet
                setTimeout(initializeLucideIcons, 100);
            }
        }
        
        // Initialize icons when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeLucideIcons();
            setupSettingsListeners();
        });
        
        // Also initialize when PDF viewer is shown
        const originalRenderPage = renderPage;
        renderPage = async function(pageNum, withTransition = false) {
            await originalRenderPage(pageNum, withTransition);
            initializeLucideIcons();
        };

        // Handle window resize for responsive behavior with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                // Clear existing timeout
                clearTimeout(resizeTimeout);
                
                // Set new timeout to prevent excessive re-rendering
                resizeTimeout = setTimeout(() => {
                    renderPage(currentPage);
                }, 250); // Wait 250ms after resize stops
            }
        });
    </script>
</body>
</html>
