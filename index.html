<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotator with Web Ink API</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: { primary: '#5D5CDE' }
                }
            }
        }
    </script>
    <style>
        .aspect-16-9 { aspect-ratio: 16 / 9; }
        .lucide { stroke-width: 0.5px; }
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto;
            cursor: crosshair;
        }
        .pdf-container { position: relative; overflow: auto; }
        .toolbar {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
        }
        .dark .toolbar { background: rgba(30, 30, 30, 0.9); }
        .eraser-cursor {
            position: fixed;
            border: 2px dashed #666;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            display: none;
        }
        .dark .eraser-cursor { border-color: #999; }
        .tool-btn {
            @apply text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-gray-100;
        }
        .tool-btn.active {
            @apply bg-primary text-white hover:bg-primary/90;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            border: none;
        }
        .ink-status {
            @apply text-xs text-green-600 dark:text-green-400 font-medium;
        }
        .ink-disabled {
            @apply text-xs text-orange-600 dark:text-orange-400 font-medium;
        }
    </style>
</head>
<body class="bg-white text-gray-900 transition-colors duration-200">
    <!-- Home Screen -->
    <div id="homeScreen" class="min-h-screen flex items-center justify-center p-8">
        <div class="max-w-4xl w-full aspect-16-9 bg-gray-50 dark:bg-gray-800 rounded-2xl border-2 border-dashed border-gray-300 dark:border-gray-600 flex flex-col items-center justify-center relative">
            <!-- Dark Mode Toggle -->
            <button id="themeToggle" class="absolute top-6 right-6 p-2 rounded-lg bg-white dark:bg-gray-700 shadow-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors">
                <i data-lucide="sun" class="w-5 h-5 dark:hidden"></i>
                <i data-lucide="moon" class="w-5 h-5 hidden dark:block"></i>
            </button>

            <div class="text-center">
                <div class="mb-8">
                    <i data-lucide="file-text" class="w-16 h-16 mx-auto text-gray-400 dark:text-gray-500 mb-4"></i>
                    <h1 class="text-3xl font-bold text-gray-700 dark:text-gray-200 mb-2">PDF Annotator with Web Ink</h1>
                    <p class="text-gray-500 dark:text-gray-400">Enhanced stylus support with Web Ink API</p>
                    <div id="inkStatus" class="mt-2">
                        <span id="inkStatusText" class="ink-disabled">Checking Web Ink API support...</span>
                    </div>
                </div>
                
                <button id="loadPdfBtn" class="inline-flex items-center px-8 py-4 bg-primary text-white rounded-xl hover:bg-primary/90 transition-colors shadow-lg">
                    <i data-lucide="upload" class="w-5 h-5 mr-3"></i>
                    Load PDF
                </button>
                
                <input type="file" id="pdfInput" accept=".pdf" class="hidden">
            </div>
        </div>
    </div>

    <!-- PDF Viewer Screen -->
    <div id="pdfScreen" class="hidden h-screen bg-gray-100 dark:bg-gray-900 overflow-hidden">
        <!-- PDF Container -->
        <div class="pdf-container h-full w-full">
            <div id="pdfViewerContainer" class="w-full h-full relative bg-white dark:bg-gray-800 overflow-hidden">
                <canvas id="pdfCanvas" class="block w-full h-full"></canvas>
                <canvas id="annotationCanvas" class="drawing-canvas"></canvas>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" class="hidden fixed bottom-20 left-6 bg-white dark:bg-gray-800 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-600 p-4 w-64">
            <!-- Web Ink Status -->
            <div class="mb-4 p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600 dark:text-gray-300">Web Ink API</span>
                    <span id="modalInkStatus" class="ink-disabled">Disabled</span>
                </div>
            </div>

            <!-- Pen Settings -->
            <div id="penSettings">
                <!-- Performance Presets -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Performance Presets</h3>
                    <div class="grid grid-cols-3 gap-1">
                        <button id="performancePreset" class="preset-btn px-2 py-1 text-xs bg-primary text-white rounded transition-colors">Fast</button>
                        <button id="balancedPreset" class="preset-btn px-2 py-1 text-xs bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 rounded transition-colors">Balanced</button>
                        <button id="qualityPreset" class="preset-btn px-2 py-1 text-xs bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 rounded transition-colors">Quality</button>
                    </div>
                </div>

                <!-- Color Palette -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Color</h3>
                    <div class="grid grid-cols-8 gap-2" id="colorPalette">
                        <!-- Colors will be generated dynamically -->
                    </div>
                </div>
                
                <!-- Pen Size -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Pen Size</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">1</span>
                        <input type="range" id="penSizeSlider" min="1" max="20" value="2" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">20</span>
                    </div>
                    <div class="flex justify-center mt-2">
                        <div id="penSizePreview" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                    </div>
                </div>

                <!-- Pressure Sensitivity -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Pressure</h3>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Pressure Sensitivity</span>
                        <button id="pressureToggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 dark:bg-gray-600 transition-colors focus:outline-none">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"></span>
                        </button>
                    </div>
                    <!-- Pressure Sensitivity -->
                    <div class="mt-2">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Pressure Sensitivity</span>
                            <span id="pressureSensitivityValue" class="text-xs text-gray-500 dark:text-gray-400">100%</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Low</span>
                            <input type="range" id="pressureSensitivitySlider" min="25" max="300" step="5" value="100" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                            <span class="text-xs text-gray-500 dark:text-gray-400">High</span>
                        </div>
                    </div>
                    
                    <!-- Pressure Curve -->
                    <div class="mt-2">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Pressure Curve</span>
                            <span id="pressureCurveValue" class="text-xs text-gray-500 dark:text-gray-400">1.8</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Linear</span>
                            <input type="range" id="pressureCurveSlider" min="1.0" max="3.0" step="0.1" value="1.8" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Curved</span>
                        </div>
                    </div>

                    <!-- Pressure Deadzone -->
                    <div class="mt-2">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Pressure Deadzone</span>
                            <span id="pressureDeadzoneValue" class="text-xs text-gray-500 dark:text-gray-400">5%</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500 dark:text-gray-400">None</span>
                            <input type="range" id="pressureDeadzoneSlider" min="0" max="25" step="1" value="5" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                            <span class="text-xs text-gray-500 dark:text-gray-400">25%</span>
                        </div>
                        <div class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                            Ignores very light pressure to prevent accidental marks
                        </div>
                    </div>
                </div>

                <!-- Tilt Sensitivity -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Tilt Effects</h3>
                    <div class="flex items-center justify-between">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Tilt Sensitivity</span>
                        <button id="tiltToggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 dark:bg-gray-600 transition-colors focus:outline-none">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"></span>
                        </button>
                    </div>
                </div>

                <!-- Stroke Stabilization -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Stabilization</h3>
                    <div class="flex items-center justify-between mb-1">
                        <span class="text-xs text-gray-500 dark:text-gray-400">Hand Tremor Reduction</span>
                        <span id="stabilizationValue" class="text-xs text-gray-500 dark:text-gray-400">10%</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">Off</span>
                        <input type="range" id="stabilizationSlider" min="0" max="70" step="5" value="10" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">High</span>
                    </div>
                    <div class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                        Higher values reduce latency but may feel less smooth
                    </div>
                </div>

                <!-- Stroke Smoothing -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Smoothing</h3>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Enable Smoothing</span>
                        <button id="smoothingToggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-primary transition-colors focus:outline-none">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-5"></span>
                        </button>
                    </div>
                    <div class="mt-2">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Smoothing Level</span>
                            <span id="smoothingLevelValue" class="text-xs text-gray-500 dark:text-gray-400">40%</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Sharp</span>
                            <input type="range" id="smoothingLevelSlider" min="0" max="90" step="10" value="40" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                            <span class="text-xs text-gray-500 dark:text-gray-400">Smooth</span>
                        </div>
                    </div>
                </div>

                <!-- Velocity Effects -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Velocity Effects</h3>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Speed Sensitivity</span>
                        <button id="velocityToggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-primary transition-colors focus:outline-none">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-5"></span>
                        </button>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <div>
                            <div class="flex items-center justify-between mb-1">
                                <span class="text-xs text-gray-500 dark:text-gray-400">Min Size</span>
                                <span id="velocityMinValue" class="text-xs text-gray-500 dark:text-gray-400">70%</span>
                            </div>
                            <input type="range" id="velocityMinSlider" min="30" max="100" step="5" value="70" class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        </div>
                        <div>
                            <div class="flex items-center justify-between mb-1">
                                <span class="text-xs text-gray-500 dark:text-gray-400">Max Size</span>
                                <span id="velocityMaxValue" class="text-xs text-gray-500 dark:text-gray-400">150%</span>
                            </div>
                            <input type="range" id="velocityMaxSlider" min="100" max="300" step="10" value="150" class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        </div>
                    </div>
                </div>

                <!-- Performance Mode -->
                <div class="mb-4">
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Performance</h3>
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Performance Mode</span>
                        <button id="performanceModeToggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-200 dark:bg-gray-600 transition-colors focus:outline-none">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"></span>
                        </button>
                    </div>
                    <div class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                        Disables advanced features for maximum speed
                    </div>
                </div>

                <!-- Opacity -->
                <div>
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Opacity</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">10%</span>
                        <input type="range" id="opacitySlider" min="0.1" max="1" step="0.1" value="1" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">100%</span>
                    </div>
                </div>
            </div>

            <!-- Eraser Settings -->
            <div id="eraserSettings" class="hidden">
                <!-- Eraser Size -->
                <div>
                    <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Eraser Size</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500 dark:text-gray-400">5</span>
                        <input type="range" id="eraserSizeSlider" min="5" max="90" value="10" class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg cursor-pointer">
                        <span class="text-xs text-gray-500 dark:text-gray-400">90</span>
                    </div>
                    <div class="flex justify-center mt-2">
                        <div id="eraserSizePreview" class="border-2 border-gray-400 dark:border-gray-500 rounded-full bg-transparent"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Floating Toolbar -->
        <div id="toolbar" class="toolbar fixed bottom-6 left-6 flex items-center space-x-0.5 px-2 py-1 rounded-full border border-gray-200 dark:border-gray-600 shadow-lg">
            <button id="penTool" class="tool-btn active p-1 rounded-lg transition-colors" data-tool="pen">
                <i data-lucide="pen-tool" class="w-5 h-5"></i>
            </button>
            <button id="eraserTool" class="tool-btn p-1 rounded-lg transition-colors" data-tool="eraser">
                <i data-lucide="eraser" class="w-5 h-5"></i>
            </button>
            <div class="w-px h-4 bg-gray-300 dark:bg-gray-600 mx-1"></div>
            <button id="undoBtn" class="tool-btn p-1 rounded-lg transition-colors">
                <i data-lucide="undo" class="w-5 h-5"></i>
            </button>
            <button id="redoBtn" class="tool-btn p-1 rounded-lg transition-colors">
                <i data-lucide="redo" class="w-5 h-5"></i>
            </button>
            <button id="clearBtn" class="tool-btn p-1 rounded-lg transition-colors">
                <i data-lucide="trash-2" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- Ink Status Indicator -->
        <div id="inkIndicator" class="fixed top-4 right-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-600 p-2">
            <div class="flex items-center space-x-2">
                <div id="inkDot" class="w-2 h-2 rounded-full bg-gray-400"></div>
                <span id="inkText" class="text-xs text-gray-600 dark:text-gray-300">Web Ink: Checking...</span>
            </div>
        </div>

        <!-- Eraser Cursor -->
        <div id="eraserCursor" class="eraser-cursor"></div>
    </div>

    <script>
        // Initialize Lucide icons and theme
        lucide.createIcons();
        
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
        });

        class PDFAnnotator {
            constructor() {
                // Core properties
                this.pdfDoc = null;
                this.currentPage = 1;
                this.totalPages = 0;
                
                // Drawing state
                this.isDrawing = false;
                this.currentTool = 'pen';
                this.previousTool = 'pen';
                this.strokeColor = '#000000';
                this.penSize = 2;
                this.eraserSize = 10;
                this.strokeOpacity = 1;
                this.pressureSensitive = false;
                this.tiltSensitive = false;
                this.isEraserButtonPressed = false;
                
                // Web Ink API properties
                this.inkPresenter = null;
                this.supportsWebInk = false;
                this.currentStroke = null;
                this.inkPoints = [];
                this.lastPressure = 0.5;
                this.lastTiltX = 0;
                this.lastTiltY = 0;
                
                // Enhanced ink quality properties
                this.smoothingEnabled = true;
                this.velocityFiltering = true;
                this.strokeSmoothing = 0.4; // Reduced for lower latency
                this.pressureCurve = 1.8;
                this.pressureSensitivity = 1.0; // NEW: Overall pressure multiplier
                this.pressureDeadzone = 0.05; // NEW: Ignore pressure below this threshold
                this.velocityRange = { min: 0.7, max: 1.5 }; // Reduced range for performance
                this.stabilization = 0.1; // Much lower for immediate response
                this.predictiveRendering = true;
                this.performanceMode = false;
                
                // Stroke tracking for quality improvements
                this.lastPoint = null;
                this.lastLastPoint = null;
                this.velocityHistory = [];
                this.pressureHistory = [];
                this.smoothedPoints = [];
                this.lastTimestamp = 0;
                this.strokeStartTime = 0;
                
                // History management
                this.undoStack = [];
                this.redoStack = [];
                
                // Page-specific annotations storage
                this.pageAnnotations = new Map(); // Store annotations per page
                
                // Constants
                this.MAX_UNDO_STATES = 20;
                this.DOUBLE_TAP_DELAY = 300;
                
                // Color palette
                this.colors = [
                    '#000000', '#ef4444', '#3b82f6', '#22c55e',
                    '#eab308', '#a855f7', '#ec4899', '#f97316',
                    '#6b7280', '#6366f1', '#14b8a6', '#84cc16',
                    '#f59e0b', '#f43f5e', '#06b6d4', '#ffffff'
                ];
                
                this.init();
            }

            async init() {
                this.setupElements();
                await this.initWebInkAPI();
                this.generateColorPalette();
                this.bindEvents();
                this.updateUI();
                this.updateInkStatus();
            }

            async initWebInkAPI() {
                try {
                    // Check if Web Ink API is supported
                    if ('ink' in navigator && 'requestPresenter' in navigator.ink) {
                        this.supportsWebInk = true;
                        console.log('Web Ink API is supported!');
                        
                        // Request an ink presenter when we have a canvas
                        // We'll do this after the PDF is loaded
                        this.updateInkStatusDisplay(true);
                    } else {
                        this.supportsWebInk = false;
                        console.log('Web Ink API is not supported in this browser');
                        this.updateInkStatusDisplay(false);
                    }
                } catch (error) {
                    console.error('Error initializing Web Ink API:', error);
                    this.supportsWebInk = false;
                    this.updateInkStatusDisplay(false);
                }
            }

            async setupInkPresenter() {
                if (!this.supportsWebInk || this.inkPresenter) return;
                
                try {
                    // Request ink presenter for the annotation canvas
                    this.inkPresenter = await navigator.ink.requestPresenter({
                        presentationArea: this.elements.annotationCanvas
                    });
                    
                    console.log('Ink presenter created successfully');
                    this.updateInkStatusDisplay(true, true);
                    
                    // Enable pressure sensitivity by default when Web Ink is available
                    if (!this.pressureSensitive) {
                        this.togglePressureSensitivity();
                    }
                    
                } catch (error) {
                    console.error('Error creating ink presenter:', error);
                    this.updateInkStatusDisplay(true, false);
                }
            }

            updateInkStatusDisplay(supported, active = false) {
                const statusElements = [
                    document.getElementById('inkStatusText'),
                    document.getElementById('modalInkStatus'),
                    document.getElementById('inkText')
                ];
                
                const dotElement = document.getElementById('inkDot');
                
                if (supported && active) {
                    statusElements.forEach(el => {
                        if (el) {
                            el.textContent = active ? 'Active' : 'Available';
                            el.className = 'ink-status';
                        }
                    });
                    if (dotElement) {
                        dotElement.className = 'w-2 h-2 rounded-full bg-green-500';
                    }
                } else if (supported) {
                    statusElements.forEach(el => {
                        if (el) {
                            el.textContent = 'Available';
                            el.className = 'text-xs text-blue-600 dark:text-blue-400 font-medium';
                        }
                    });
                    if (dotElement) {
                        dotElement.className = 'w-2 h-2 rounded-full bg-blue-500';
                    }
                } else {
                    statusElements.forEach(el => {
                        if (el) {
                            el.textContent = 'Not Supported';
                            el.className = 'ink-disabled';
                        }
                    });
                    if (dotElement) {
                        dotElement.className = 'w-2 h-2 rounded-full bg-gray-400';
                    }
                }
            }

            setupElements() {
                // Cache DOM elements
                this.elements = {
                    homeScreen: document.getElementById('homeScreen'),
                    pdfScreen: document.getElementById('pdfScreen'),
                    pdfCanvas: document.getElementById('pdfCanvas'),
                    annotationCanvas: document.getElementById('annotationCanvas'),
                    settingsModal: document.getElementById('settingsModal'),
                    eraserCursor: document.getElementById('eraserCursor'),
                    toolbar: document.getElementById('toolbar')
                };
                
                // Setup canvas contexts
                this.pdfCtx = this.elements.pdfCanvas.getContext('2d');
                this.annotationCtx = this.elements.annotationCanvas.getContext('2d');
                
                // Optimize canvas performance
                this.annotationCtx.lineCap = 'round';
                this.annotationCtx.lineJoin = 'round';
            }

            generateColorPalette() {
                const palette = document.getElementById('colorPalette');
                palette.innerHTML = this.colors.map(color => 
                    `<button class="color-btn w-6 h-6 rounded-full border-2 border-gray-300 hover:border-gray-500" 
                             style="background-color: ${color}" 
                             data-color="${color}"></button>`
                ).join('');
            }

            bindEvents() {
                // Theme toggle
                document.getElementById('themeToggle').addEventListener('click', () => {
                    document.documentElement.classList.toggle('dark');
                });

                // File loading
                document.getElementById('loadPdfBtn').addEventListener('click', () => {
                    document.getElementById('pdfInput').click();
                });

                document.getElementById('pdfInput').addEventListener('change', (e) => {
                    if (e.target.files[0]) this.loadPDF(e.target.files[0]);
                });

                // Keyboard navigation
                document.addEventListener('keydown', this.handleKeydown.bind(this));

                // Tool events
                this.elements.toolbar.addEventListener('click', this.handleToolbarClick.bind(this));

                // Settings events
                this.bindSettingsEvents();

                // Drawing events
                this.bindDrawingEvents();

                // Modal events
                this.bindModalEvents();
            }

            bindSettingsEvents() {
                // Color selection
                document.getElementById('colorPalette').addEventListener('click', (e) => {
                    if (e.target.classList.contains('color-btn')) {
                        this.setColor(e.target.dataset.color);
                        this.hideSettingsModal();
                    }
                });

                // Sliders
                document.getElementById('penSizeSlider').addEventListener('input', (e) => {
                    this.penSize = parseInt(e.target.value);
                    this.updatePreview('pen');
                });

                document.getElementById('eraserSizeSlider').addEventListener('input', (e) => {
                    this.eraserSize = parseInt(e.target.value);
                    this.updatePreview('eraser');
                    this.updateEraserCursor();
                });

                document.getElementById('opacitySlider').addEventListener('input', (e) => {
                    this.strokeOpacity = parseFloat(e.target.value);
                });

                document.getElementById('pressureToggle').addEventListener('click', () => {
                    this.togglePressureSensitivity();
                });

                document.getElementById('tiltToggle').addEventListener('click', () => {
                    this.toggleTiltSensitivity();
                });

                // Performance Presets
                document.getElementById('performancePreset').addEventListener('click', () => {
                    this.applyPerformancePreset('performance');
                });

                document.getElementById('balancedPreset').addEventListener('click', () => {
                    this.applyPerformancePreset('balanced');
                });

                document.getElementById('qualityPreset').addEventListener('click', () => {
                    this.applyPerformancePreset('quality');
                });

                // Advanced ink controls
                document.getElementById('pressureCurveSlider').addEventListener('input', (e) => {
                    this.pressureCurve = parseFloat(e.target.value);
                    document.getElementById('pressureCurveValue').textContent = e.target.value;
                });

                document.getElementById('stabilizationSlider').addEventListener('input', (e) => {
                    this.stabilization = parseInt(e.target.value) / 100; // Convert to 0-1 range
                    document.getElementById('stabilizationValue').textContent = e.target.value + '%';
                });

                document.getElementById('smoothingToggle').addEventListener('click', () => {
                    this.toggleSmoothing();
                });

                document.getElementById('smoothingLevelSlider').addEventListener('input', (e) => {
                    this.strokeSmoothing = parseInt(e.target.value) / 100; // Convert to 0-1 range
                    document.getElementById('smoothingLevelValue').textContent = e.target.value + '%';
                });

                document.getElementById('velocityToggle').addEventListener('click', () => {
                    this.toggleVelocityFiltering();
                });

                document.getElementById('velocityMinSlider').addEventListener('input', (e) => {
                    this.velocityRange.min = parseInt(e.target.value) / 100; // Convert to 0-1 range
                    document.getElementById('velocityMinValue').textContent = e.target.value + '%';
                });

                document.getElementById('velocityMaxSlider').addEventListener('input', (e) => {
                    this.velocityRange.max = parseInt(e.target.value) / 100; // Convert to 0-1 range
                    document.getElementById('velocityMaxValue').textContent = e.target.value + '%';
                });

                document.getElementById('performanceModeToggle').addEventListener('click', () => {
                    this.togglePerformanceMode();
                });

                // NEW: Pressure sensitivity controls
                document.getElementById('pressureSensitivitySlider').addEventListener('input', (e) => {
                    this.pressureSensitivity = parseInt(e.target.value) / 100; // Convert to 0-3 range
                    document.getElementById('pressureSensitivityValue').textContent = e.target.value + '%';
                });

                document.getElementById('pressureDeadzoneSlider').addEventListener('input', (e) => {
                    this.pressureDeadzone = parseInt(e.target.value) / 100; // Convert to 0-0.25 range
                    document.getElementById('pressureDeadzoneValue').textContent = e.target.value + '%';
                });
            }

            bindDrawingEvents() {
                const canvas = this.elements.annotationCanvas;
                
                // Pointer events (supports mouse, stylus/pen, but excludes finger touch)
                canvas.addEventListener('pointerdown', this.handlePointerStart.bind(this));
                canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
                canvas.addEventListener('pointerup', this.handlePointerEnd.bind(this));
                canvas.addEventListener('pointerout', this.handlePointerEnd.bind(this));
                canvas.addEventListener('pointerenter', this.showEraserCursor.bind(this));
                canvas.addEventListener('pointerleave', this.hideEraserCursor.bind(this));

                // Fallback mouse events for older browsers
                canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                canvas.addEventListener('mouseout', this.stopDrawing.bind(this));
                canvas.addEventListener('mouseenter', this.showEraserCursor.bind(this));
                canvas.addEventListener('mouseleave', this.hideEraserCursor.bind(this));

                // Prevent default touch behavior to avoid scrolling during drawing
                canvas.addEventListener('touchstart', (e) => e.preventDefault());
                canvas.addEventListener('touchmove', (e) => e.preventDefault());
                canvas.addEventListener('touchend', (e) => e.preventDefault());
            }

            bindModalEvents() {
                // Double tap on tool buttons to open settings
                let lastTapTime = 0;
                let lastTappedTool = null;
                let tapTimeout = null;
                
                // Handle tool button clicks (both single and double tap)
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent toolbar click handler
                        
                        const tool = btn.dataset.tool;
                        const currentTime = Date.now();
                        const timeSinceLastTap = currentTime - lastTapTime;
                        
                        if (timeSinceLastTap < this.DOUBLE_TAP_DELAY && 
                            timeSinceLastTap > 0 && 
                            lastTappedTool === tool) {
                            // Double tap detected on same tool
                            clearTimeout(tapTimeout);
                            this.setTool(tool); // Ensure tool is selected
                            this.toggleSettingsModal();
                            lastTapTime = 0; // Reset to prevent triple tap
                            lastTappedTool = null;
                        } else {
                            // First tap or different tool
                            this.setTool(tool);
                            lastTapTime = currentTime;
                            lastTappedTool = tool;
                            
                            // Clear any existing timeout
                            clearTimeout(tapTimeout);
                            
                            // Set timeout to reset if no second tap comes
                            tapTimeout = setTimeout(() => {
                                lastTapTime = 0;
                                lastTappedTool = null;
                            }, this.DOUBLE_TAP_DELAY);
                        }
                    });
                });

                // Close modal on outside click/touch
                document.addEventListener('click', (e) => {
                    if (!this.elements.settingsModal.contains(e.target) && 
                        !this.elements.toolbar.contains(e.target)) {
                        this.hideSettingsModal();
                    }
                });

                // Close modal on outside touch (stylus, finger)
                document.addEventListener('touchstart', (e) => {
                    if (!this.elements.settingsModal.classList.contains('hidden') &&
                        !this.elements.settingsModal.contains(e.target) && 
                        !this.elements.toolbar.contains(e.target)) {
                        this.hideSettingsModal();
                    }
                });

                // Also handle touchend for better touch responsiveness
                document.addEventListener('touchend', (e) => {
                    if (!this.elements.settingsModal.classList.contains('hidden') &&
                        !this.elements.settingsModal.contains(e.target) && 
                        !this.elements.toolbar.contains(e.target)) {
                        this.hideSettingsModal();
                    }
                });
            }

            handleKeydown(e) {
                if (this.elements.pdfScreen.classList.contains('hidden')) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        if (this.currentPage > 1) {
                            this.navigateToPage(this.currentPage - 1);
                        }
                        break;
                    case 'ArrowRight':
                        if (this.currentPage < this.totalPages) {
                            this.navigateToPage(this.currentPage + 1);
                        }
                        break;
                    case 'Escape':
                        this.showHomeScreen();
                        break;
                }
            }

            navigateToPage(newPage) {
                if (newPage < 1 || newPage > this.totalPages) return;
                
                // Save annotations for current page before switching
                this.savePageAnnotations(this.currentPage);
                
                // Update to new page
                this.currentPage = newPage;
                
                // Render the new page
                this.renderPage();
            }

            handleToolbarClick(e) {
                const toolBtn = e.target.closest('.tool-btn');
                if (!toolBtn) return;

                // Only handle non-tool buttons here (undo, redo, clear)
                // Tool buttons are handled in bindModalEvents
                if (!toolBtn.dataset.tool) {
                    const action = toolBtn.id;
                    switch (action) {
                        case 'undoBtn': this.undo(); break;
                        case 'redoBtn': this.redo(); break;
                        case 'clearBtn': this.clearAnnotations(); break;
                    }
                }
            }

            handleMouseMove(e) {
                if (this.currentTool === 'eraser') {
                    this.positionEraserCursor(e.clientX, e.clientY);
                }
                this.draw(e);
            }

            handlePointerStart(e) {
                // Only allow drawing with stylus/pen and mouse, not finger touch
                if (e.pointerType === 'touch') {
                    return; // Ignore finger touch for drawing
                }
                
                // Check for eraser button press (stylus eraser)
                this.checkEraserButton(e);
                
                // Extract enhanced pointer data for Web Ink
                this.extractPointerData(e);
                
                this.startDrawing(e);
            }

            handlePointerMove(e) {
                // Only allow drawing with stylus/pen and mouse, not finger touch
                if (e.pointerType === 'touch') {
                    return; // Ignore finger touch for drawing
                }
                
                // Check for eraser button during move
                this.checkEraserButton(e);
                
                // Extract enhanced pointer data for Web Ink
                this.extractPointerData(e);
                
                if (this.currentTool === 'eraser') {
                    this.positionEraserCursor(e.clientX, e.clientY);
                }
                this.draw(e);
            }

            handlePointerEnd(e) {
                // Only allow drawing with stylus/pen and mouse, not finger touch
                if (e.pointerType === 'touch') {
                    return; // Ignore finger touch for drawing
                }
                
                // Check if eraser button was released
                this.checkEraserButton(e);
                
                this.stopDrawing();
            }

            extractPointerData(e) {
                // Extract enhanced pointer information available in modern browsers
                if (e.pressure !== undefined) {
                    this.lastPressure = e.pressure;
                }
                
                if (e.tiltX !== undefined && e.tiltY !== undefined) {
                    this.lastTiltX = e.tiltX;
                    this.lastTiltY = e.tiltY;
                }
                
                // Store point for potential Web Ink processing
                if (this.isDrawing && this.inkPresenter) {
                    this.inkPoints.push({
                        x: e.clientX,
                        y: e.clientY,
                        pressure: this.lastPressure,
                        tiltX: this.lastTiltX,
                        tiltY: this.lastTiltY,
                        timestamp: performance.now()
                    });
                }
            }

            checkEraserButton(e) {
                // Detect eraser button press on stylus
                // buttons: 32 = eraser button, 2 = secondary button (also used for eraser on some styluses)
                const eraserPressed = (e.buttons & 32) !== 0 || (e.pointerType === 'pen' && (e.buttons & 2) !== 0);
                
                if (eraserPressed && !this.isEraserButtonPressed) {
                    // Eraser button just pressed
                    this.isEraserButtonPressed = true;
                    if (this.currentTool !== 'eraser') {
                        this.previousTool = this.currentTool;
                        this.setTool('eraser');
                        // Show eraser cursor when switching to eraser via stylus button
                        this.showEraserCursor();
                        this.positionEraserCursor(e.clientX, e.clientY);
                    }
                } else if (!eraserPressed && this.isEraserButtonPressed) {
                    // Eraser button just released
                    this.isEraserButtonPressed = false;
                    if (this.currentTool === 'eraser' && this.previousTool) {
                        // Hide eraser cursor when switching away from eraser
                        this.hideEraserCursor();
                        this.setTool(this.previousTool);
                    }
                }
                
                // Update eraser cursor position if eraser is active
                if (this.currentTool === 'eraser' && this.isEraserButtonPressed) {
                    this.positionEraserCursor(e.clientX, e.clientY);
                }
            }

            async loadPDF(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                    this.totalPages = this.pdfDoc.numPages;
                    this.currentPage = 1;
                    
                    this.showPdfScreen();
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await this.renderPage();
                    
                    // Setup Web Ink presenter after canvas is ready
                    await this.setupInkPresenter();
                } catch (error) {
                    console.error('Error loading PDF:', error);
                }
            }

            async renderPage() {
                const page = await this.pdfDoc.getPage(this.currentPage);
                
                // Use fixed scale instead of dynamic scaling
                const scale = this.fixedScale || this.calculateInitialScale(page);
                this.fixedScale = scale; // Store for consistency
                
                const viewport = page.getViewport({ scale });
                
                // Set canvas dimensions to fixed size
                this.setCanvasDimensions(viewport.width, viewport.height);
                
                // Render PDF
                await page.render({
                    canvasContext: this.pdfCtx,
                    viewport: viewport
                }).promise;
                
                // Clear annotations canvas first
                this.annotationCtx.clearRect(
                    0, 0,
                    this.elements.annotationCanvas.width,
                    this.elements.annotationCanvas.height
                );
                
                // Restore annotations for current page
                this.restoreCurrentPageAnnotations();
                
                // Reset undo/redo stacks for the new page
                this.undoStack = [];
                this.redoStack = [];
            }

            saveCurrentPageAnnotations() {
                if (this.elements.annotationCanvas.width > 0 && this.elements.annotationCanvas.height > 0) {
                    const imageData = this.annotationCtx.getImageData(
                        0, 0,
                        this.elements.annotationCanvas.width,
                        this.elements.annotationCanvas.height
                    );
                    this.pageAnnotations.set(this.currentPage, imageData);
                }
            }

            restoreCurrentPageAnnotations() {
                const savedAnnotations = this.pageAnnotations.get(this.currentPage);
                if (savedAnnotations) {
                    this.annotationCtx.putImageData(savedAnnotations, 0, 0);
                }
            }

            savePageAnnotations(pageNumber) {
                if (this.elements.annotationCanvas.width > 0 && this.elements.annotationCanvas.height > 0) {
                    const imageData = this.annotationCtx.getImageData(
                        0, 0,
                        this.elements.annotationCanvas.width,
                        this.elements.annotationCanvas.height
                    );
                    this.pageAnnotations.set(pageNumber, imageData);
                }
            }

            calculateInitialScale(page) {
                // Calculate scale only once when first loading
                const container = document.getElementById('pdfViewerContainer');
                const containerWidth = container.clientWidth;
                const baseViewport = page.getViewport({ scale: 1 });
                
                // Use a reasonable default scale that fits most screens
                const fitScale = containerWidth / baseViewport.width;
                // Cap the scale to prevent too large or too small rendering
                return Math.min(Math.max(fitScale, 0.5), 2.0);
            }

            setCanvasDimensions(width, height) {
                [this.elements.pdfCanvas, this.elements.annotationCanvas].forEach(canvas => {
                    canvas.width = width;
                    canvas.height = height;
                    // Set fixed pixel dimensions instead of responsive sizing
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    canvas.style.display = 'block';
                });
            }

            setTool(tool) {
                this.currentTool = tool;
                
                // Update active state
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });
                
                // Update cursor
                this.elements.annotationCanvas.style.cursor = tool === 'pen' ? 'crosshair' : 'none';
                this.updateEraserCursor();
            }

            startDrawing(e) {
                this.isDrawing = true;
                this.saveState();
                
                // Reset stroke tracking
                this.inkPoints = [];
                this.velocityHistory = [];
                this.pressureHistory = [];
                this.smoothedPoints = [];
                this.strokeStartTime = performance.now();
                this.lastTimestamp = this.strokeStartTime;
                
                const { x, y } = this.getCanvasCoordinates(e);
                
                // Initialize stroke tracking
                this.lastPoint = { x, y, pressure: this.lastPressure, timestamp: this.strokeStartTime };
                this.lastLastPoint = null;
                
                this.annotationCtx.beginPath();
                this.annotationCtx.moveTo(x, y);
                
                // Set tool properties with enhanced Web Ink features
                if (this.currentTool === 'pen') {
                    this.setupPenDrawing();
                } else if (this.currentTool === 'eraser') {
                    this.setupEraserDrawing();
                }
                
                // Start Web Ink stroke if available
                if (this.inkPresenter && this.currentTool === 'pen') {
                    this.startWebInkStroke(e);
                }
            }

            setupPenDrawing() {
                this.annotationCtx.globalCompositeOperation = 'source-over';
                this.annotationCtx.strokeStyle = this.strokeColor;
                this.annotationCtx.globalAlpha = this.strokeOpacity;
                
                // Enhanced line cap for smoother appearance
                this.annotationCtx.lineCap = 'round';
                this.annotationCtx.lineJoin = 'round';
                
                // Calculate initial dynamic size
                const dynamicSize = this.calculateDynamicLineWidth();
                this.annotationCtx.lineWidth = dynamicSize;
            }

            setupEraserDrawing() {
                this.annotationCtx.globalCompositeOperation = 'destination-out';
                this.annotationCtx.lineWidth = this.eraserSize;
                this.annotationCtx.globalAlpha = 1;
                this.annotationCtx.lineCap = 'round';
                this.annotationCtx.lineJoin = 'round';
            }

            calculateDynamicLineWidth() {
                let dynamicSize = this.penSize;
                
                // Apply pressure curve for more natural response
                if (this.pressureSensitive && this.lastPressure > 0) {
                    // Apply deadzone - ignore pressure below threshold
                    let adjustedPressure = Math.max(0, this.lastPressure - this.pressureDeadzone);
                    
                    if (adjustedPressure > 0) {
                        // Normalize pressure after deadzone removal
                        adjustedPressure = adjustedPressure / (1 - this.pressureDeadzone);
                        
                        // Apply pressure sensitivity multiplier
                        adjustedPressure = Math.min(1, adjustedPressure * this.pressureSensitivity);
                        
                        // Apply pressure curve for more natural response
                        const pressureCurved = Math.pow(adjustedPressure, 1 / this.pressureCurve);
                        dynamicSize = this.penSize * (0.3 + pressureCurved * 1.7);
                    }
                }
                
                // Apply tilt effects for brush-like behavior
                if (this.tiltSensitive && (Math.abs(this.lastTiltX) > 5 || Math.abs(this.lastTiltY) > 5)) {
                    const tiltMagnitude = Math.sqrt(this.lastTiltX * this.lastTiltX + this.lastTiltY * this.lastTiltY);
                    const tiltFactor = Math.min(tiltMagnitude / 60, 1); // Normalize to 0-1
                    dynamicSize *= (1 + tiltFactor * 0.8);
                }
                
                return Math.max(0.5, Math.min(dynamicSize, 50));
            }

            calculateVelocity(currentPoint, lastPoint) {
                if (!lastPoint) return 0;
                
                const deltaTime = Math.max(currentPoint.timestamp - lastPoint.timestamp, 1);
                const deltaX = currentPoint.x - lastPoint.x;
                const deltaY = currentPoint.y - lastPoint.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                return distance / deltaTime * 16.67; // Normalize to pixels per frame at 60fps
            }

            smoothPressure(currentPressure) {
                this.pressureHistory.push(currentPressure);
                if (this.pressureHistory.length > 3) {
                    this.pressureHistory.shift();
                }
                
                // Simple moving average for pressure smoothing
                const sum = this.pressureHistory.reduce((a, b) => a + b, 0);
                return sum / this.pressureHistory.length;
            }

            smoothVelocity(currentVelocity) {
                this.velocityHistory.push(currentVelocity);
                if (this.velocityHistory.length > 3) {
                    this.velocityHistory.shift();
                }
                
                // Simple moving average for velocity smoothing
                const sum = this.velocityHistory.reduce((a, b) => a + b, 0);
                return sum / this.velocityHistory.length;
            }

            applyStabilization(currentPoint) {
                if (!this.lastPoint || this.stabilization === 0) return currentPoint;
                
                // Apply stabilization by interpolating between current and last point
                const stabilizedX = this.lastPoint.x + (currentPoint.x - this.lastPoint.x) * (1 - this.stabilization);
                const stabilizedY = this.lastPoint.y + (currentPoint.y - this.lastPoint.y) * (1 - this.stabilization);
                
                return {
                    x: stabilizedX,
                    y: stabilizedY,
                    pressure: currentPoint.pressure,
                    timestamp: currentPoint.timestamp
                };
            }

            startWebInkStroke(e) {
                try {
                    if (this.inkPresenter && 'start' in this.inkPresenter) {
                        // Start a new ink stroke
                        this.currentStroke = this.inkPresenter.start({
                            color: this.strokeColor,
                            diameter: this.penSize,
                            opacity: this.strokeOpacity
                        });
                    }
                } catch (error) {
                    console.log('Web Ink stroke start failed:', error);
                }
            }

            draw(e) {
                if (!this.isDrawing) return;
                
                const { x, y } = this.getCanvasCoordinates(e);
                const currentTime = performance.now();
                
                // Immediate response - draw point right away for lowest latency
                this.drawImmediatePoint(x, y);
                
                // Create current point with minimal processing for low latency
                const currentPoint = {
                    x: x,
                    y: y,
                    pressure: this.lastPressure, // Skip smoothing for immediate response
                    timestamp: currentTime
                };
                
                // Store point for potential smoothing later (if we implement background processing)
                if (this.lastPoint) {
                    this.drawOptimizedStroke(this.lastPoint, currentPoint);
                }
                
                // Update tracking points (minimal overhead)
                this.lastLastPoint = this.lastPoint;
                this.lastPoint = currentPoint;
                
                // Add point to Web Ink stroke if available (but don't wait for it)
                if (this.inkPresenter && this.currentStroke && this.currentTool === 'pen') {
                    this.addWebInkPoint(x, y);
                }
            }

            drawImmediatePoint(x, y) {
                // Immediate dot rendering for instant feedback (lowest latency)
                if (this.currentTool === 'pen') {
                    const size = this.calculateFastLineWidth();
                    this.annotationCtx.globalAlpha = this.strokeOpacity;
                    this.annotationCtx.fillStyle = this.strokeColor;
                    this.annotationCtx.beginPath();
                    this.annotationCtx.arc(x, y, size / 2, 0, Math.PI * 2);
                    this.annotationCtx.fill();
                }
            }

            drawOptimizedStroke(fromPoint, toPoint) {
                // Fast stroke drawing without heavy processing
                if (this.currentTool === 'pen') {
                    const size = this.calculateFastLineWidth();
                    this.annotationCtx.lineWidth = size;
                    this.annotationCtx.globalAlpha = this.strokeOpacity;
                    this.annotationCtx.strokeStyle = this.strokeColor;
                    this.annotationCtx.beginPath();
                    this.annotationCtx.moveTo(fromPoint.x, fromPoint.y);
                    this.annotationCtx.lineTo(toPoint.x, toPoint.y);
                    this.annotationCtx.stroke();
                } else if (this.currentTool === 'eraser') {
                    this.drawFastEraser(fromPoint, toPoint);
                }
            }

            calculateFastLineWidth() {
                // Fast line width calculation without complex processing
                let size = this.penSize;
                
                // Only apply pressure if enabled and available
                if (this.pressureSensitive && this.lastPressure > 0) {
                    // Simplified pressure curve for speed
                    size = this.penSize * (0.5 + this.lastPressure * 1.0);
                }
                
                return Math.max(0.5, Math.min(size, 50));
            }

            drawFastEraser(fromPoint, toPoint) {
                // Fast eraser without complex edge processing
                this.annotationCtx.globalCompositeOperation = 'destination-out';
                this.annotationCtx.lineWidth = this.eraserSize;
                this.annotationCtx.globalAlpha = 1;
                this.annotationCtx.beginPath();
                this.annotationCtx.moveTo(fromPoint.x, fromPoint.y);
                this.annotationCtx.lineTo(toPoint.x, toPoint.y);
                this.annotationCtx.stroke();
            }

            drawEnhancedStroke(point, velocity) {
                // Calculate dynamic properties
                let dynamicSize = this.calculateDynamicLineWidth();
                let dynamicOpacity = this.strokeOpacity;
                
                // Apply velocity-based size variation for natural feel
                if (this.velocityFiltering && velocity > 0) {
                    const velocityFactor = Math.min(Math.max(velocity / 5, this.velocityRange.min), this.velocityRange.max);
                    dynamicSize *= (0.8 + (1 / velocityFactor) * 0.4);
                }
                
                // Smooth stroke rendering with quadratic curves for better quality
                if (this.smoothingEnabled && this.lastPoint && this.lastLastPoint) {
                    this.drawSmoothCurve(this.lastLastPoint, this.lastPoint, point, dynamicSize, dynamicOpacity);
                } else {
                    // Fallback to simple line drawing
                    this.annotationCtx.lineWidth = dynamicSize;
                    this.annotationCtx.globalAlpha = dynamicOpacity;
                    this.annotationCtx.lineTo(point.x, point.y);
                    this.annotationCtx.stroke();
                }
            }

            drawSmoothCurve(p0, p1, p2, lineWidth, opacity) {
                // Calculate control points for quadratic curve
                const midPoint1 = {
                    x: (p0.x + p1.x) / 2,
                    y: (p0.y + p1.y) / 2
                };
                
                const midPoint2 = {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
                
                // Set drawing properties
                this.annotationCtx.lineWidth = lineWidth;
                this.annotationCtx.globalAlpha = opacity;
                
                // Begin new path for smooth curve
                this.annotationCtx.beginPath();
                this.annotationCtx.moveTo(midPoint1.x, midPoint1.y);
                
                // Draw quadratic curve for smoothness
                this.annotationCtx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
                this.annotationCtx.stroke();
                
                // Add slight texture for more natural appearance
                if (Math.random() < 0.3) { // 30% chance for texture dots
                    this.addTexturePoint(p1, lineWidth * 0.1);
                }
            }

            addTexturePoint(point, size) {
                // Add subtle texture for more natural ink appearance
                const ctx = this.annotationCtx;
                const originalAlpha = ctx.globalAlpha;
                
                ctx.globalAlpha = originalAlpha * 0.3;
                ctx.beginPath();
                ctx.arc(
                    point.x + (Math.random() - 0.5) * size * 2,
                    point.y + (Math.random() - 0.5) * size * 2,
                    size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.globalAlpha = originalAlpha;
            }

            drawEraserStroke(point) {
                // Simple eraser drawing with enhanced edge softening
                this.annotationCtx.lineWidth = this.eraserSize;
                this.annotationCtx.globalAlpha = 1;
                
                // Add feathered edge effect for softer erasing
                if (this.smoothingEnabled && this.lastPoint) {
                    const distance = Math.sqrt(
                        Math.pow(point.x - this.lastPoint.x, 2) + 
                        Math.pow(point.y - this.lastPoint.y, 2)
                    );
                    
                    if (distance > 1) {
                        // Draw multiple smaller circles for smoother erasing
                        const steps = Math.ceil(distance / 2);
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const x = this.lastPoint.x + (point.x - this.lastPoint.x) * t;
                            const y = this.lastPoint.y + (point.y - this.lastPoint.y) * t;
                            
                            this.annotationCtx.beginPath();
                            this.annotationCtx.arc(x, y, this.eraserSize / 2, 0, Math.PI * 2);
                            this.annotationCtx.fill();
                        }
                    }
                } else {
                    this.annotationCtx.lineTo(point.x, point.y);
                    this.annotationCtx.stroke();
                }
            }

            addWebInkPoint(x, y) {
                try {
                    if (this.currentStroke && 'addPoint' in this.currentStroke) {
                        this.currentStroke.addPoint({
                            x: x,
                            y: y,
                            pressure: this.lastPressure,
                            tiltX: this.lastTiltX,
                            tiltY: this.lastTiltY,
                            timestamp: performance.now()
                        });
                    }
                } catch (error) {
                    console.log('Web Ink point add failed:', error);
                }
            }

            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.redoStack = [];
                    
                    // End Web Ink stroke if available
                    if (this.inkPresenter && this.currentStroke && this.currentTool === 'pen') {
                        this.endWebInkStroke();
                    }
                    
                    this.currentStroke = null;
                    this.inkPoints = [];
                }
            }

            endWebInkStroke() {
                try {
                    if (this.currentStroke && 'end' in this.currentStroke) {
                        this.currentStroke.end();
                    }
                } catch (error) {
                    console.log('Web Ink stroke end failed:', error);
                }
            }

            getCanvasCoordinates(e) {
                const rect = this.elements.annotationCanvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            saveState() {
                const imageData = this.annotationCtx.getImageData(
                    0, 0, 
                    this.elements.annotationCanvas.width, 
                    this.elements.annotationCanvas.height
                );
                
                this.undoStack.push(imageData);
                if (this.undoStack.length > this.MAX_UNDO_STATES) {
                    this.undoStack.shift();
                }
            }

            undo() {
                if (this.undoStack.length === 0) return;
                
                this.redoStack.push(this.annotationCtx.getImageData(
                    0, 0,
                    this.elements.annotationCanvas.width,
                    this.elements.annotationCanvas.height
                ));
                
                const previousState = this.undoStack.pop();
                this.annotationCtx.putImageData(previousState, 0, 0);
            }

            redo() {
                if (this.redoStack.length === 0) return;
                
                this.undoStack.push(this.annotationCtx.getImageData(
                    0, 0,
                    this.elements.annotationCanvas.width,
                    this.elements.annotationCanvas.height
                ));
                
                const nextState = this.redoStack.pop();
                this.annotationCtx.putImageData(nextState, 0, 0);
            }

            clearAnnotations() {
                this.saveState();
                this.annotationCtx.clearRect(
                    0, 0,
                    this.elements.annotationCanvas.width,
                    this.elements.annotationCanvas.height
                );
                // Also remove the current page annotations from storage
                this.pageAnnotations.delete(this.currentPage);
                this.redoStack = [];
            }

            showHomeScreen() {
                this.elements.homeScreen.classList.remove('hidden');
                this.elements.pdfScreen.classList.add('hidden');
            }

            showPdfScreen() {
                this.elements.homeScreen.classList.add('hidden');
                this.elements.pdfScreen.classList.remove('hidden');
            }

            toggleSettingsModal() {
                const isHidden = this.elements.settingsModal.classList.contains('hidden');
                if (isHidden) {
                    this.showSettingsModal();
                } else {
                    this.hideSettingsModal();
                }
            }

            showSettingsModal() {
                this.elements.settingsModal.classList.remove('hidden');
                this.updateModalForCurrentTool();
                this.updatePreview(this.currentTool);
                this.updateColorSelection();
            }

            hideSettingsModal() {
                this.elements.settingsModal.classList.add('hidden');
            }

            setColor(color) {
                this.strokeColor = color;
                this.updateColorSelection();
            }

            updateColorSelection() {
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.classList.toggle('ring-2', btn.dataset.color === this.strokeColor);
                    btn.classList.toggle('ring-primary', btn.dataset.color === this.strokeColor);
                });
            }

            updateModalForCurrentTool() {
                const penSettings = document.getElementById('penSettings');
                const eraserSettings = document.getElementById('eraserSettings');
                
                penSettings.classList.toggle('hidden', this.currentTool !== 'pen');
                eraserSettings.classList.toggle('hidden', this.currentTool !== 'eraser');
            }

            updatePreview(tool) {
                if (tool === 'pen') {
                    this.updatePenSizePreview();
                } else if (tool === 'eraser') {
                    this.updateEraserSizePreview();
                }
            }

            updatePenSizePreview() {
                const preview = document.getElementById('penSizePreview');
                const size = this.penSize;
                preview.style.width = size + 'px';
                preview.style.height = size + 'px';
            }

            updateEraserSizePreview() {
                const preview = document.getElementById('eraserSizePreview');
                const size = this.eraserSize;
                preview.style.width = size + 'px';
                preview.style.height = size + 'px';
            }

            updateEraserCursor() {
                const cursor = this.elements.eraserCursor;
                cursor.style.width = this.eraserSize + 'px';
                cursor.style.height = this.eraserSize + 'px';
            }

            positionEraserCursor(x, y) {
                const cursor = this.elements.eraserCursor;
                cursor.style.left = x + 'px';
                cursor.style.top = y + 'px';
            }

            showEraserCursor() {
                if (this.currentTool === 'eraser') {
                    this.elements.eraserCursor.style.display = 'block';
                }
            }

            hideEraserCursor() {
                this.elements.eraserCursor.style.display = 'none';
            }

            togglePressureSensitivity() {
                this.pressureSensitive = !this.pressureSensitive;
                const toggle = document.getElementById('pressureToggle');
                const slider = toggle.querySelector('span');
                
                toggle.classList.toggle('bg-primary', this.pressureSensitive);
                toggle.classList.toggle('bg-gray-200', !this.pressureSensitive);
                toggle.classList.toggle('dark:bg-gray-600', !this.pressureSensitive);
                
                slider.classList.toggle('translate-x-5', this.pressureSensitive);
                slider.classList.toggle('translate-x-1', !this.pressureSensitive);
            }

            toggleTiltSensitivity() {
                this.tiltSensitive = !this.tiltSensitive;
                const toggle = document.getElementById('tiltToggle');
                const slider = toggle.querySelector('span');
                
                toggle.classList.toggle('bg-primary', this.tiltSensitive);
                toggle.classList.toggle('bg-gray-200', !this.tiltSensitive);
                toggle.classList.toggle('dark:bg-gray-600', !this.tiltSensitive);
                
                slider.classList.toggle('translate-x-5', this.tiltSensitive);
                slider.classList.toggle('translate-x-1', !this.tiltSensitive);
            }

            updateInkStatus() {
                // Update all ink status displays
                this.updateInkStatusDisplay(this.supportsWebInk, this.inkPresenter !== null);
            }

            // Performance preset methods
            applyPerformancePreset(preset) {
                // Update preset button states
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.classList.remove('bg-primary', 'text-white');
                    btn.classList.add('bg-gray-200', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                });

                if (preset === 'performance') {
                    // Maximum performance - minimal features
                    this.performanceMode = true;
                    this.smoothingEnabled = false;
                    this.velocityFiltering = false;
                    this.stabilization = 0;
                    this.strokeSmoothing = 0;
                    this.pressureCurve = 1.0;
                    this.velocityRange = { min: 1.0, max: 1.0 };
                    document.getElementById('performancePreset').classList.remove('bg-gray-200', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                    document.getElementById('performancePreset').classList.add('bg-primary', 'text-white');
                } else if (preset === 'balanced') {
                    // Balanced performance and quality
                    this.performanceMode = false;
                    this.smoothingEnabled = true;
                    this.velocityFiltering = true;
                    this.stabilization = 0.1;
                    this.strokeSmoothing = 0.4;
                    this.pressureCurve = 1.8;
                    this.velocityRange = { min: 0.7, max: 1.5 };
                    document.getElementById('balancedPreset').classList.remove('bg-gray-200', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                    document.getElementById('balancedPreset').classList.add('bg-primary', 'text-white');
                } else if (preset === 'quality') {
                    // Maximum quality features
                    this.performanceMode = false;
                    this.smoothingEnabled = true;
                    this.velocityFiltering = true;
                    this.stabilization = 0.3;
                    this.strokeSmoothing = 0.7;
                    this.pressureCurve = 2.5;
                    this.velocityRange = { min: 0.5, max: 2.0 };
                    document.getElementById('qualityPreset').classList.remove('bg-gray-200', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                    document.getElementById('qualityPreset').classList.add('bg-primary', 'text-white');
                }

                // Update all UI controls to reflect the new values
                this.updateAllControls();
            }

            toggleSmoothing() {
                this.smoothingEnabled = !this.smoothingEnabled;
                const toggle = document.getElementById('smoothingToggle');
                const slider = toggle.querySelector('span');
                
                toggle.classList.toggle('bg-primary', this.smoothingEnabled);
                toggle.classList.toggle('bg-gray-200', !this.smoothingEnabled);
                toggle.classList.toggle('dark:bg-gray-600', !this.smoothingEnabled);
                
                slider.classList.toggle('translate-x-5', this.smoothingEnabled);
                slider.classList.toggle('translate-x-1', !this.smoothingEnabled);
            }

            toggleVelocityFiltering() {
                this.velocityFiltering = !this.velocityFiltering;
                const toggle = document.getElementById('velocityToggle');
                const slider = toggle.querySelector('span');
                
                toggle.classList.toggle('bg-primary', this.velocityFiltering);
                toggle.classList.toggle('bg-gray-200', !this.velocityFiltering);
                toggle.classList.toggle('dark:bg-gray-600', !this.velocityFiltering);
                
                slider.classList.toggle('translate-x-5', this.velocityFiltering);
                slider.classList.toggle('translate-x-1', !this.velocityFiltering);
            }

            togglePerformanceMode() {
                this.performanceMode = !this.performanceMode;
                const toggle = document.getElementById('performanceModeToggle');
                const slider = toggle.querySelector('span');
                
                toggle.classList.toggle('bg-primary', this.performanceMode);
                toggle.classList.toggle('bg-gray-200', !this.performanceMode);
                toggle.classList.toggle('dark:bg-gray-600', !this.performanceMode);
                
                slider.classList.toggle('translate-x-5', this.performanceMode);
                slider.classList.toggle('translate-x-1', !this.performanceMode);

                if (this.performanceMode) {
                    // When performance mode is enabled, disable some quality features
                    this.smoothingEnabled = false;
                    this.velocityFiltering = false;
                    this.updateAllControls();
                }
            }

            updateAllControls() {
                // Update all sliders and toggles to reflect current values
                document.getElementById('pressureCurveSlider').value = this.pressureCurve.toFixed(1);
                document.getElementById('pressureCurveValue').textContent = this.pressureCurve.toFixed(1);
                
                // NEW: Update pressure sensitivity controls
                document.getElementById('pressureSensitivitySlider').value = Math.round(this.pressureSensitivity * 100);
                document.getElementById('pressureSensitivityValue').textContent = Math.round(this.pressureSensitivity * 100) + '%';
                
                document.getElementById('pressureDeadzoneSlider').value = Math.round(this.pressureDeadzone * 100);
                document.getElementById('pressureDeadzoneValue').textContent = Math.round(this.pressureDeadzone * 100) + '%';
                
                document.getElementById('stabilizationSlider').value = Math.round(this.stabilization * 100);
                document.getElementById('stabilizationValue').textContent = Math.round(this.stabilization * 100) + '%';
                
                document.getElementById('smoothingLevelSlider').value = Math.round(this.strokeSmoothing * 100);
                document.getElementById('smoothingLevelValue').textContent = Math.round(this.strokeSmoothing * 100) + '%';
                
                document.getElementById('velocityMinSlider').value = Math.round(this.velocityRange.min * 100);
                document.getElementById('velocityMinValue').textContent = Math.round(this.velocityRange.min * 100) + '%';
                
                document.getElementById('velocityMaxSlider').value = Math.round(this.velocityRange.max * 100);
                document.getElementById('velocityMaxValue').textContent = Math.round(this.velocityRange.max * 100) + '%';

                // Update toggle states
                this.updateToggleState('smoothingToggle', this.smoothingEnabled);
                this.updateToggleState('velocityToggle', this.velocityFiltering);
                this.updateToggleState('performanceModeToggle', this.performanceMode);
            }

            updateToggleState(toggleId, state) {
                const toggle = document.getElementById(toggleId);
                const slider = toggle.querySelector('span');
                
                toggle.classList.toggle('bg-primary', state);
                toggle.classList.toggle('bg-gray-200', !state);
                toggle.classList.toggle('dark:bg-gray-600', !state);
                
                slider.classList.toggle('translate-x-5', state);
                slider.classList.toggle('translate-x-1', !state);
            }

            updateUI() {
                this.updatePreview(this.currentTool);
                this.updateColorSelection();
                this.updateEraserCursor();
                this.updateInkStatus();
                this.updateAllControls();
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new PDFAnnotator();
        });
    </script>

</body>
</html>
