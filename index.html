<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Annotator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            color: black;
            overflow: hidden;
        }

        .homescreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }

        .load-button {
            padding: 16px 32px;
            font-size: 18px;
            background: black;
            color: white;
            border: none;
            cursor: pointer;
            font-family: inherit;
            margin-bottom: 20px;
        }

        .load-button:hover {
            background: #333;
        }

        .file-input {
            display: none;
        }

        .pdf-viewer {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .pdf-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: white;
        }

        .ink-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            touch-action: none;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: black;
            font-size: 14px;
            z-index: 1000;
        }

        .clear-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: black;
            color: white;
            border: none;
            padding: 8px;
            cursor: pointer;
            font-family: inherit;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .clear-button:hover {
            background: #333;
        }

        .eraser-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 1px dashed black;
            border-radius: 50%;
            background-color: rgba(128, 128, 128, 0.2);
            pointer-events: none;
            z-index: 1001;
            display: none;
            transform: translate(-50%, -50%);
        }

        .menu-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: black;
            color: white;
            border: none;
            padding: 8px;
            cursor: pointer;
            font-family: inherit;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .menu-button:hover {
            background: #333;
        }

        .drawer {
            position: fixed;
            top: 0;
            left: -280px;
            width: 280px;
            height: 100vh;
            background: white;
            border-right: 2px solid black;
            z-index: 2000;
            transition: left 0.3s ease;
            overflow-y: auto;
            padding: 60px 15px 15px 15px;
        }

        .drawer.open {
            left: 0;
        }

        /* Custom thin scrollbar */
        .drawer::-webkit-scrollbar {
            width: 3px;
        }

        .drawer::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .drawer::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 2px;
        }

        .drawer::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Firefox scrollbar */
        .drawer {
            scrollbar-width: thin;
            scrollbar-color: #888 #f1f1f1;
        }

        .drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: transparent;
            z-index: 1999;
            display: none;
        }

        .drawer-overlay.visible {
            display: block;
        }

        .stroke-control {
            margin-bottom: 20px;
        }

        .stroke-control h3 {
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 8px;
            color: black;
        }

        .stepper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stepper-button {
            width: 32px;
            height: 32px;
            background: black;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stepper-button:hover {
            background: #333;
        }

        .stepper-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .stepper-value {
            font-size: 14px;
            font-weight: bold;
            min-width: 35px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="homescreen" id="homescreen">
        <h1 style="margin-bottom: 40px; font-weight: normal;">PDF Annotator</h1>
        <button class="load-button" onclick="document.getElementById('fileInput').click()">
            Load PDF
        </button>
        <input type="file" id="fileInput" class="file-input" accept=".pdf" onchange="loadPDF(event)">
        <p style="margin-top: 20px; color: #666; font-size: 14px;">Select a PDF file to start annotating</p>
    </div>

    <div class="pdf-viewer" id="pdfViewer">
        <button class="menu-button" onclick="toggleDrawer()" title="Settings">
            <i data-lucide="menu"></i>
        </button>
        <button class="clear-button" onclick="clearAnnotations()" title="Clear annotations">
            <i data-lucide="trash-2"></i>
        </button>
        <div class="instructions">Use arrow keys to navigate • Surface Pen to annotate • Barrel button to erase</div>
        

        
        <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
        <canvas id="inkCanvas" class="ink-canvas"></canvas>
        <div id="eraserIndicator" class="eraser-indicator"></div>
    </div>

    <div class="drawer-overlay" id="drawerOverlay" onclick="closeDrawer()"></div>
    <div class="drawer" id="drawer">
        <div class="stroke-control">
            <h3>Stroke Size</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseStrokeSize()" id="decreaseBtn">-</button>
                <div class="stepper-value" id="strokeSizeValue">2</div>
                <button class="stepper-button" onclick="increaseStrokeSize()" id="increaseBtn">+</button>
            </div>
        </div>
        
        <div class="stroke-control">
            <h3>Smoothing Type</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseSmoothingType()" id="decreaseSmoothingTypeBtn">-</button>
                <div class="stepper-value" id="smoothingTypeValue" style="font-size: 12px; min-width: 100px;">Natural Curves</div>
                <button class="stepper-button" onclick="increaseSmoothingType()" id="increaseSmoothingTypeBtn">+</button>
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;" id="smoothingTypeDesc">Catmull-Rom splines, smooth natural feel</div>
            <button class="stepper-button" onclick="resetSmoothingType()" id="resetSmoothingTypeBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
        
        <div class="stroke-control">
            <h3>Smoothing Intensity</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseSmoothingIntensity()" id="decreaseSmoothingIntensityBtn">-</button>
                <div class="stepper-value" id="smoothingIntensityValue">3</div>
                <button class="stepper-button" onclick="increaseSmoothingIntensity()" id="increaseSmoothingIntensityBtn">+</button>
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">Strength of smoothing effect (0 = off, 10 = maximum)</div>
            <button class="stepper-button" onclick="resetSmoothingIntensity()" id="resetSmoothingIntensityBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
        
        <div class="stroke-control">
            <h3>Eraser Threshold</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseThreshold()" id="decreaseThresholdBtn">-</button>
                <div class="stepper-value" id="thresholdValue">10</div>
                <button class="stepper-button" onclick="increaseThreshold()" id="increaseThresholdBtn">+</button>
            </div>
            <button class="stepper-button" onclick="resetThreshold()" id="resetThresholdBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
        
        <div class="stroke-control">
            <h3>Eraser Sensitivity</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreaseSensitivity()" id="decreaseSensitivityBtn">-</button>
                <div class="stepper-value" id="sensitivityValue">5</div>
                <button class="stepper-button" onclick="increaseSensitivity()" id="increaseSensitivityBtn">+</button>
            </div>
            <button class="stepper-button" onclick="resetSensitivity()" id="resetSensitivityBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
        
        <div class="stroke-control">
            <h3>Pressure Sensitivity</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="togglePressureSensitivity()" id="pressureSwitchBtn" style="width: 100%;">OFF</button>
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">Varies stroke width based on pen pressure</div>
        </div>
        
        <div class="stroke-control">
            <h3>Pressure Low</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreasePressureLow()" id="decreasePressureLowBtn">-</button>
                <div class="stepper-value" id="pressureLowValue">2</div>
                <button class="stepper-button" onclick="increasePressureLow()" id="increasePressureLowBtn">+</button>
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">Minimum stroke width at light pressure (1-10)</div>
            <button class="stepper-button" onclick="resetPressureLow()" id="resetPressureLowBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
        
        <div class="stroke-control">
            <h3>Pressure High</h3>
            <div class="stepper">
                <button class="stepper-button" onclick="decreasePressureHigh()" id="decreasePressureHighBtn">-</button>
                <div class="stepper-value" id="pressureHighValue">8</div>
                <button class="stepper-button" onclick="increasePressureHigh()" id="increasePressureHighBtn">+</button>
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">Maximum stroke width at hard pressure (1-10)</div>
            <button class="stepper-button" onclick="resetPressureHigh()" id="resetPressureHighBtn" style="width: 100%; margin-top: 10px; font-size: 14px;">Reset</button>
        </div>
    </div>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDocument = null;
        let currentPage = 1;
        let totalPages = 0;
        let pageAnnotations = new Map(); // Store annotations per page
        let isDrawing = false;
        let lastPoint = null;
        let isErasing = false;
        let inkPresenter = null;
        let lastTimestamp = 0;
        let currentSpeed = 0;
        let currentEraserSize = 20; // Default eraser size
        const minEraserSize = 10;
        const maxEraserSize = 130;
        let speedThreshold = 10; // Threshold before size starts increasing (adjustable)
        const defaultSpeedThreshold = 10; // Default threshold value
        let eraserSensitivity = 5; // How quickly eraser grows (1-10 scale)
        const defaultEraserSensitivity = 5; // Default sensitivity value
        let eraserDecreaseTimer = null;
        let smoothingType = 2; // Smoothing algorithm type (0-4)
        const defaultSmoothingType = 2; // Default to Natural Curves
        let smoothingIntensity = 3; // Smoothing intensity level (0 = off, 1-10 = strength)
        const defaultSmoothingIntensity = 3; // Default intensity value
        let smoothingBuffer = []; // Buffer for points used in smoothing
        let pressureSensitivity = false; // Pressure sensitivity on/off
        const defaultPressureSensitivity = false; // Default pressure sensitivity
        let pressureLow = 2; // Minimum pressure threshold (1-10)
        const defaultPressureLow = 2; // Default low pressure
        let pressureHigh = 8; // Maximum pressure threshold (1-10) 
        const defaultPressureHigh = 8; // Default high pressure
        
        // Smoothing algorithm definitions
        const smoothingAlgorithms = [
            { name: "None", description: "Raw pen input, no smoothing" },
            { name: "Light Smoothing", description: "Simple averaging, fast performance" },
            { name: "Natural Curves", description: "Catmull-Rom splines, smooth natural feel" },
            { name: "Artistic Curves", description: "Bezier curves, artistic drawing style" },
            { name: "Anti-Shake", description: "Kalman filter, reduces hand tremor" }
        ];
        
        // Stroke size settings
        let currentStrokeSize = 2;
        const minStrokeSize = 1;
        const maxStrokeSize = 20;

        const pdfCanvas = document.getElementById('pdfCanvas');
        const inkCanvas = document.getElementById('inkCanvas');
        const eraserIndicator = document.getElementById('eraserIndicator');
        const pdfCtx = pdfCanvas.getContext('2d');
        const inkCtx = inkCanvas.getContext('2d');

        // Ink canvas setup
        inkCtx.strokeStyle = 'black';
        inkCtx.lineWidth = 2;
        inkCtx.lineCap = 'round';
        inkCtx.lineJoin = 'round';

        function resizeCanvases() {
            const rect = document.getElementById('pdfViewer').getBoundingClientRect();
            pdfCanvas.width = rect.width;
            pdfCanvas.height = rect.height;
            inkCanvas.width = rect.width;
            inkCanvas.height = rect.height;
        }

        async function loadPDF(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDocument = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = pdfDocument.numPages;
                currentPage = 1;
                
                document.getElementById('homescreen').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                resizeCanvases();
                renderPage(currentPage);
                setupInkEvents();
                
                // Initialize Lucide icons
                lucide.createIcons();
            } catch (error) {
                console.error('Error loading PDF:', error);
            }
        }

        async function renderPage(pageNum) {
            if (!pdfDocument) return;

            const page = await pdfDocument.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1 });
            
            // Calculate scale to fit the page to screen
            const scaleX = pdfCanvas.width / viewport.width;
            const scaleY = pdfCanvas.height / viewport.height;
            const scale = Math.min(scaleX, scaleY);
            
            const scaledViewport = page.getViewport({ scale });
            
            // Center the page
            const offsetX = (pdfCanvas.width - scaledViewport.width) / 2;
            const offsetY = (pdfCanvas.height - scaledViewport.height) / 2;
            
            // Clear and render PDF
            pdfCtx.fillStyle = 'white';
            pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            
            pdfCtx.save();
            pdfCtx.translate(offsetX, offsetY);
            
            await page.render({
                canvasContext: pdfCtx,
                viewport: scaledViewport
            }).promise;
            
            pdfCtx.restore();
            
            // Restore annotations for this page
            restorePageAnnotations(pageNum);
        }

        function savePageAnnotations(pageNum) {
            const imageData = inkCtx.getImageData(0, 0, inkCanvas.width, inkCanvas.height);
            pageAnnotations.set(pageNum, imageData);
        }

        function restorePageAnnotations(pageNum) {
            // Clear ink canvas
            inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
            
            // Restore annotations if they exist
            const annotations = pageAnnotations.get(pageNum);
            if (annotations) {
                inkCtx.putImageData(annotations, 0, 0);
            }
        }

        async function initWebInkAPI() {
            // Initialize Web Ink API if available
            if ('ink' in navigator) {
                try {
                    inkPresenter = await navigator.ink.requestPresenter({ 
                        presentationArea: inkCanvas 
                    });
                    console.log('Web Ink API initialized successfully');
                } catch (error) {
                    console.log('Web Ink API not available, falling back to canvas rendering:', error);
                    inkPresenter = null;
                }
            } else {
                console.log('Web Ink API not supported, using canvas fallback');
                inkPresenter = null;
            }
        }

        function setupInkEvents() {
            // Initialize Web Ink API
            initWebInkAPI();
            
            // Disable context menu
            inkCanvas.addEventListener('contextmenu', e => e.preventDefault());
            
            // Pointer events for Surface Pen
            inkCanvas.addEventListener('pointerdown', startDrawing);
            inkCanvas.addEventListener('pointermove', draw);
            inkCanvas.addEventListener('pointerup', stopDrawing);
            inkCanvas.addEventListener('pointerout', stopDrawing);
        }

        function calculateSpeed(currentPoint, currentTime) {
            if (!lastPoint || !lastTimestamp) {
                lastTimestamp = currentTime;
                return 0;
            }
            
            const distance = Math.sqrt(
                Math.pow(currentPoint.x - lastPoint.x, 2) + 
                Math.pow(currentPoint.y - lastPoint.y, 2)
            );
            
            const timeDelta = currentTime - lastTimestamp;
            const speed = timeDelta > 0 ? distance / (timeDelta / 16.67) : 0; // Pixels per frame (~60fps)
            
            lastTimestamp = currentTime;
            
            // Debug logging to see actual speed values
            console.log('Speed:', speed.toFixed(2), 'Distance:', distance.toFixed(2), 'TimeDelta:', timeDelta.toFixed(2));
            
            return speed;
        }

        function calculateEraserSize(speed) {
            // Much more responsive thresholds
            if (speed <= speedThreshold) {
                return minEraserSize;
            }
            
            // Map speed above threshold to size range
            const speedRange = Math.max(speed - speedThreshold, 0);
            const maxSpeedForMapping = 50; // Much lower max speed for easier triggering
            const normalizedSpeed = Math.min(speedRange / maxSpeedForMapping, 1);
            
            const size = minEraserSize + (normalizedSpeed * (maxEraserSize - minEraserSize));
            console.log('Calculated size:', size.toFixed(2), 'from speed:', speed.toFixed(2));
            
            return size;
        }

        function updateEraserSize(speed) {
            const targetSize = calculateEraserSize(speed);
            
            // Calculate sensitivity-based growth rate
            // Sensitivity 1 = 30% new size, Sensitivity 10 = 90% new size
            const sensitivityFactor = 0.2 + (eraserSensitivity / 10) * 0.7; // Maps 1-10 to 0.3-0.9
            
            // Asymmetric smoothing: adjustable increase, slow decrease when moving
            if (targetSize > currentEraserSize) {
                // Sensitivity-based response when size should increase
                currentEraserSize = currentEraserSize * (1 - sensitivityFactor) + targetSize * sensitivityFactor;
            } else if (speed > 1) {
                // Very slow response when size should decrease while moving
                currentEraserSize = currentEraserSize * 0.99 + targetSize * 0.01;
            } else {
                // Faster decrease when pen is stopped (speed near zero)
                currentEraserSize = currentEraserSize * 0.95 + minEraserSize * 0.05;
            }
            
            // Always update canvas line width immediately during erasing
            if (isErasing) {
                inkCtx.lineWidth = currentEraserSize;
            }
            
            // Update visual indicator to match the exact eraser area
            // For canvas strokes with round lineCap, the effective diameter is lineWidth
            const exactSize = Math.round(currentEraserSize);
            eraserIndicator.style.width = exactSize + 'px';
            eraserIndicator.style.height = exactSize + 'px';
            eraserIndicator.style.borderRadius = '50%';
            
            console.log('Current eraser size:', currentEraserSize.toFixed(2), 'Speed:', speed.toFixed(2), 'Sensitivity:', eraserSensitivity, 'Factor:', sensitivityFactor.toFixed(2), 'Canvas lineWidth:', inkCtx.lineWidth, 'Visual indicator:', exactSize);
        }

        function showEraserIndicator(x, y) {
            eraserIndicator.style.left = x + 'px';
            eraserIndicator.style.top = y + 'px';
            eraserIndicator.style.display = 'block';
        }

        function hideEraserIndicator() {
            eraserIndicator.style.display = 'none';
        }

        function updateEraserIndicator(e) {
            if (e.pointerType !== 'pen') return;
            
            const isBarrelPressed = (e.buttons & 32) !== 0;
            
            if (isBarrelPressed) {
                const rect = inkCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left + rect.left;
                const y = e.clientY - rect.top + rect.top;
                showEraserIndicator(x, y);
            } else {
                hideEraserIndicator();
            }
        }

        function startDrawing(e) {
            // Only allow pen input, disable finger/mouse
            if (e.pointerType !== 'pen') return;
            
            e.preventDefault();
            isDrawing = true;
            
            // Check if barrel button is pressed (button 32 = bit 5)
            isErasing = (e.buttons & 32) !== 0;
            
            const rect = inkCanvas.getBoundingClientRect();
            lastPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            // Reset speed tracking for new stroke
            lastTimestamp = performance.now();
            currentSpeed = 0;
            
            // Clear smoothing buffer for new stroke
            smoothingBuffer = [];
            
            // Set up drawing context based on mode
            if (isErasing) {
                inkCtx.globalCompositeOperation = 'destination-out';
                currentEraserSize = minEraserSize; // Start with minimum size
                inkCtx.lineWidth = currentEraserSize;
                showEraserIndicator(e.clientX, e.clientY);
                updateEraserSize(0); // Initialize size
            } else {
                inkCtx.globalCompositeOperation = 'source-over';
                inkCtx.strokeStyle = 'black';
                
                // Set line width based on pressure if enabled
                const pressureWidth = calculatePressureStrokeWidth(e.pressure);
                inkCtx.lineWidth = pressureWidth;
                
                // Add starting point to smoothing buffer for drawing mode
                if (smoothingIntensity > 0) {
                    smoothingBuffer.push(lastPoint);
                }
            }
            
            inkCtx.beginPath();
            inkCtx.moveTo(lastPoint.x, lastPoint.y);
        }

        // Moving Average smoothing
        function movingAverageSmooth(points, windowSize) {
            if (points.length < windowSize) return points;
            
            const smoothed = [];
            for (let i = windowSize - 1; i < points.length; i++) {
                let avgX = 0, avgY = 0;
                for (let j = 0; j < windowSize; j++) {
                    avgX += points[i - j].x;
                    avgY += points[i - j].y;
                }
                smoothed.push({
                    x: avgX / windowSize,
                    y: avgY / windowSize
                });
            }
            return smoothed;
        }

        // Catmull-Rom spline interpolation function
        function catmullRomSpline(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            
            return {
                x: 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                y: 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)
            };
        }

        // Bezier curve interpolation
        function bezierCurve(p0, p1, p2, p3, t) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;
            const uuu = uu * u;
            const ttt = tt * t;
            
            return {
                x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
                y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
            };
        }

        // Kalman filter for Anti-Shake smoothing
        let kalmanState = { x: 0, y: 0, vx: 0, vy: 0 };
        let kalmanP = { x: 1, y: 1, vx: 1, vy: 1 };
        
        function kalmanFilter(measurement, intensity) {
            const processNoise = 0.01 / intensity; // Less noise = more smoothing
            const measurementNoise = 1;
            
            // Predict
            kalmanState.x += kalmanState.vx;
            kalmanState.y += kalmanState.vy;
            kalmanP.x += processNoise;
            kalmanP.y += processNoise;
            
            // Update
            const kx = kalmanP.x / (kalmanP.x + measurementNoise);
            const ky = kalmanP.y / (kalmanP.y + measurementNoise);
            
            kalmanState.x += kx * (measurement.x - kalmanState.x);
            kalmanState.y += ky * (measurement.y - kalmanState.y);
            kalmanState.vx = (measurement.x - kalmanState.x) * 0.1;
            kalmanState.vy = (measurement.y - kalmanState.y) * 0.1;
            
            kalmanP.x *= (1 - kx);
            kalmanP.y *= (1 - ky);
            
            return { x: kalmanState.x, y: kalmanState.y };
        }

        // Main smoothing function that dispatches to the selected algorithm
        function applySmoothingAlgorithm(currentPoint) {
            if (smoothingIntensity === 0) return currentPoint; // No smoothing
            
            switch (smoothingType) {
                case 0: // None
                    return currentPoint;
                    
                case 1: // Light Smoothing (Moving Average)
                    smoothingBuffer.push(currentPoint);
                    if (smoothingBuffer.length > 10) smoothingBuffer.shift();
                    
                    const windowSize = Math.min(smoothingIntensity, smoothingBuffer.length);
                    const smoothed = movingAverageSmooth(smoothingBuffer, windowSize);
                    return smoothed.length > 0 ? smoothed[smoothed.length - 1] : currentPoint;
                    
                case 2: // Natural Curves (Catmull-Rom)
                    smoothingBuffer.push(currentPoint);
                    if (smoothingBuffer.length > 6) smoothingBuffer.shift();
                    
                    if (smoothingBuffer.length >= 4) {
                        const p0 = smoothingBuffer[smoothingBuffer.length - 4];
                        const p1 = smoothingBuffer[smoothingBuffer.length - 3];
                        const p2 = smoothingBuffer[smoothingBuffer.length - 2];
                        const p3 = smoothingBuffer[smoothingBuffer.length - 1];
                        
                        const t = Math.min(smoothingIntensity / 10, 0.8);
                        return catmullRomSpline(p0, p1, p2, p3, t);
                    }
                    return currentPoint;
                    
                case 3: // Artistic Curves (Bezier)
                    smoothingBuffer.push(currentPoint);
                    if (smoothingBuffer.length > 6) smoothingBuffer.shift();
                    
                    if (smoothingBuffer.length >= 4) {
                        const p0 = smoothingBuffer[smoothingBuffer.length - 4];
                        const p1 = smoothingBuffer[smoothingBuffer.length - 3];
                        const p2 = smoothingBuffer[smoothingBuffer.length - 2];
                        const p3 = smoothingBuffer[smoothingBuffer.length - 1];
                        
                        // Create control points for more artistic curves
                        const cp1 = { x: p1.x + (p2.x - p0.x) * 0.3, y: p1.y + (p2.y - p0.y) * 0.3 };
                        const cp2 = { x: p2.x - (p3.x - p1.x) * 0.3, y: p2.y - (p3.y - p1.y) * 0.3 };
                        
                        const t = Math.min(smoothingIntensity / 10, 0.8);
                        return bezierCurve(p1, cp1, cp2, p2, t);
                    }
                    return currentPoint;
                    
                case 4: // Anti-Shake (Kalman Filter)
                    return kalmanFilter(currentPoint, smoothingIntensity);
                    
                default:
                    return currentPoint;
            }
        }

        // Draw smooth curve using the selected algorithm
        function drawSmoothedStroke(currentPoint) {
            const smoothedPoint = applySmoothingAlgorithm(currentPoint);
            
            if (smoothingType === 2 || smoothingType === 3) { // Spline-based algorithms
                if (smoothingBuffer.length >= 4) {
                    const numSegments = smoothingIntensity * 2;
                    const p0 = smoothingBuffer[smoothingBuffer.length - 4];
                    const p1 = smoothingBuffer[smoothingBuffer.length - 3];
                    const p2 = smoothingBuffer[smoothingBuffer.length - 2];
                    const p3 = smoothingBuffer[smoothingBuffer.length - 1];
                    
                    inkCtx.beginPath();
                    inkCtx.moveTo(p1.x, p1.y);
                    
                    for (let i = 1; i <= numSegments; i++) {
                        const t = i / numSegments;
                        let point;
                        
                        if (smoothingType === 2) {
                            point = catmullRomSpline(p0, p1, p2, p3, t);
                        } else {
                            const cp1 = { x: p1.x + (p2.x - p0.x) * 0.3, y: p1.y + (p2.y - p0.y) * 0.3 };
                            const cp2 = { x: p2.x - (p3.x - p1.x) * 0.3, y: p2.y - (p3.y - p1.y) * 0.3 };
                            point = bezierCurve(p1, cp1, cp2, p2, t);
                        }
                        
                        inkCtx.lineTo(point.x, point.y);
                    }
                    
                    inkCtx.stroke();
                }
            } else {
                // Point-based algorithms (Moving Average, Kalman Filter)
                inkCtx.lineTo(smoothedPoint.x, smoothedPoint.y);
                inkCtx.stroke();
            }
        }

        function draw(e) {
            if (!isDrawing || e.pointerType !== 'pen') return;
            
            e.preventDefault();
            
            const rect = inkCanvas.getBoundingClientRect();
            const currentPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            // Calculate speed and update eraser size if in eraser mode
            if (isErasing) {
                const currentTime = performance.now();
                currentSpeed = calculateSpeed(currentPoint, currentTime);
                updateEraserSize(currentSpeed);
                showEraserIndicator(e.clientX, e.clientY);
                
                // End current path and start new one with updated line width
                inkCtx.stroke();
                inkCtx.beginPath();
                inkCtx.moveTo(lastPoint.x, lastPoint.y);
                
                // For erasing, use direct drawing (no smoothing)
                inkCtx.lineTo(currentPoint.x, currentPoint.y);
                inkCtx.stroke();
            } else {
                // Drawing mode - update pressure-based line width if enabled
                if (pressureSensitivity && e.pressure !== undefined) {
                    const pressureWidth = calculatePressureStrokeWidth(e.pressure);
                    if (Math.abs(pressureWidth - inkCtx.lineWidth) > 0.5) {
                        // End current path and start new one with updated line width
                        inkCtx.stroke();
                        inkCtx.lineWidth = pressureWidth;
                        inkCtx.beginPath();
                        inkCtx.moveTo(lastPoint.x, lastPoint.y);
                    }
                }
                
                // Apply smoothing if enabled
                if (smoothingIntensity > 0) {
                    drawSmoothedStroke(currentPoint);
                } else {
                    // No smoothing - direct drawing
                    inkCtx.lineTo(currentPoint.x, currentPoint.y);
                    inkCtx.stroke();
                }
            }
            
            lastPoint = currentPoint;
        }

        function continueEraserDecrease() {
            if (currentEraserSize > minEraserSize + 0.5) {
                // Continue decreasing size more aggressively when stopped
                currentEraserSize = currentEraserSize * 0.95;
                
                // Update visual indicator
                const exactSize = Math.round(currentEraserSize);
                eraserIndicator.style.width = exactSize + 'px';
                eraserIndicator.style.height = exactSize + 'px';
                
                // Continue the animation
                eraserDecreaseTimer = requestAnimationFrame(continueEraserDecrease);
            } else {
                // Reached minimum size, hide indicator
                currentEraserSize = minEraserSize;
                hideEraserIndicator();
                eraserDecreaseTimer = null;
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            
            isDrawing = false;
            lastPoint = null;
            
            // Hide eraser indicator immediately when pen is lifted
            hideEraserIndicator();
            
            // Save annotations for current page
            savePageAnnotations(currentPage);
        }

        function nextPage() {
            if (currentPage < totalPages) {
                savePageAnnotations(currentPage);
                currentPage++;
                renderPage(currentPage);
            }
        }

        function prevPage() {
            if (currentPage > 1) {
                savePageAnnotations(currentPage);
                currentPage--;
                renderPage(currentPage);
            }
        }

        function clearAnnotations() {
            // Clear annotations for current page
            inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
            // Remove from stored annotations
            pageAnnotations.delete(currentPage);
        }

        function goHome() {
            document.getElementById('pdfViewer').style.display = 'none';
            document.getElementById('homescreen').style.display = 'flex';
            
            // Reset
            pdfDocument = null;
            currentPage = 1;
            totalPages = 0;
            pageAnnotations.clear();
            document.getElementById('fileInput').value = '';
        }

        // Drawer functions
        function toggleDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawerOverlay');
            
            if (drawer.classList.contains('open')) {
                closeDrawer();
            } else {
                openDrawer();
            }
        }

        function openDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawerOverlay');
            
            drawer.classList.add('open');
            overlay.classList.add('visible');
        }

        function closeDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawerOverlay');
            
            drawer.classList.remove('open');
            overlay.classList.remove('visible');
        }

        // Stroke size functions
        function increaseStrokeSize() {
            if (currentStrokeSize < maxStrokeSize) {
                currentStrokeSize++;
                updateStrokeSize();
            }
        }

        function decreaseStrokeSize() {
            if (currentStrokeSize > minStrokeSize) {
                currentStrokeSize--;
                updateStrokeSize();
            }
        }

        function updateStrokeSize() {
            // Update the display
            document.getElementById('strokeSizeValue').textContent = currentStrokeSize;
            
            // Update button states
            document.getElementById('decreaseBtn').disabled = currentStrokeSize <= minStrokeSize;
            document.getElementById('increaseBtn').disabled = currentStrokeSize >= maxStrokeSize;
            
            // Apply the new stroke size to drawing (not erasing)
            if (!isErasing && inkCtx) {
                inkCtx.lineWidth = currentStrokeSize;
            }
        }

        // Eraser threshold functions
        function increaseThreshold() {
            if (speedThreshold < 50) { // Max threshold of 50
                speedThreshold++;
                updateThreshold();
            }
        }

        function decreaseThreshold() {
            if (speedThreshold > 1) { // Min threshold of 1
                speedThreshold--;
                updateThreshold();
            }
        }

        function resetThreshold() {
            speedThreshold = defaultSpeedThreshold;
            updateThreshold();
        }

        function updateThreshold() {
            // Update the display
            document.getElementById('thresholdValue').textContent = speedThreshold;
            
            // Update button states
            document.getElementById('decreaseThresholdBtn').disabled = speedThreshold <= 1;
            document.getElementById('increaseThresholdBtn').disabled = speedThreshold >= 50;
        }

        // Eraser sensitivity functions
        function increaseSensitivity() {
            if (eraserSensitivity < 10) { // Max sensitivity of 10
                eraserSensitivity++;
                updateSensitivity();
            }
        }

        function decreaseSensitivity() {
            if (eraserSensitivity > 1) { // Min sensitivity of 1
                eraserSensitivity--;
                updateSensitivity();
            }
        }

        function resetSensitivity() {
            eraserSensitivity = defaultEraserSensitivity;
            updateSensitivity();
        }

        function updateSensitivity() {
            // Update the display
            document.getElementById('sensitivityValue').textContent = eraserSensitivity;
            
            // Update button states
            document.getElementById('decreaseSensitivityBtn').disabled = eraserSensitivity <= 1;
            document.getElementById('increaseSensitivityBtn').disabled = eraserSensitivity >= 10;
        }

        // Smoothing type functions
        function increaseSmoothingType() {
            if (smoothingType < smoothingAlgorithms.length - 1) {
                smoothingType++;
                updateSmoothingType();
            }
        }

        function decreaseSmoothingType() {
            if (smoothingType > 0) {
                smoothingType--;
                updateSmoothingType();
            }
        }

        function resetSmoothingType() {
            smoothingType = defaultSmoothingType;
            updateSmoothingType();
        }

        function updateSmoothingType() {
            // Update the display
            document.getElementById('smoothingTypeValue').textContent = smoothingAlgorithms[smoothingType].name;
            document.getElementById('smoothingTypeDesc').textContent = smoothingAlgorithms[smoothingType].description;
            
            // Update button states
            document.getElementById('decreaseSmoothingTypeBtn').disabled = smoothingType <= 0;
            document.getElementById('increaseSmoothingTypeBtn').disabled = smoothingType >= smoothingAlgorithms.length - 1;
        }

        // Smoothing intensity functions
        function increaseSmoothingIntensity() {
            if (smoothingIntensity < 10) {
                smoothingIntensity++;
                updateSmoothingIntensity();
            }
        }

        function decreaseSmoothingIntensity() {
            if (smoothingIntensity > 0) {
                smoothingIntensity--;
                updateSmoothingIntensity();
            }
        }

        function resetSmoothingIntensity() {
            smoothingIntensity = defaultSmoothingIntensity;
            updateSmoothingIntensity();
        }

        function updateSmoothingIntensity() {
            // Update the display
            document.getElementById('smoothingIntensityValue').textContent = smoothingIntensity;
            
            // Update button states
            document.getElementById('decreaseSmoothingIntensityBtn').disabled = smoothingIntensity <= 0;
            document.getElementById('increaseSmoothingIntensityBtn').disabled = smoothingIntensity >= 10;
        }

        // Pressure sensitivity functions
        function togglePressureSensitivity() {
            pressureSensitivity = !pressureSensitivity;
            updatePressureSensitivity();
        }

        function updatePressureSensitivity() {
            // Update the display
            document.getElementById('pressureSwitchBtn').textContent = pressureSensitivity ? 'ON' : 'OFF';
            document.getElementById('pressureSwitchBtn').style.backgroundColor = pressureSensitivity ? '#4CAF50' : '#000';
        }

        // Pressure low functions
        function increasePressureLow() {
            if (pressureLow < 10 && pressureLow < pressureHigh) {
                pressureLow++;
                updatePressureLow();
            }
        }

        function decreasePressureLow() {
            if (pressureLow > 1) {
                pressureLow--;
                updatePressureLow();
            }
        }

        function resetPressureLow() {
            pressureLow = defaultPressureLow;
            updatePressureLow();
        }

        function updatePressureLow() {
            // Update the display
            document.getElementById('pressureLowValue').textContent = pressureLow;
            
            // Update button states
            document.getElementById('decreasePressureLowBtn').disabled = pressureLow <= 1;
            document.getElementById('increasePressureLowBtn').disabled = pressureLow >= 10 || pressureLow >= pressureHigh;
        }

        // Pressure high functions
        function increasePressureHigh() {
            if (pressureHigh < 10) {
                pressureHigh++;
                updatePressureHigh();
                updatePressureLow(); // Update low buttons in case they were disabled
            }
        }

        function decreasePressureHigh() {
            if (pressureHigh > 1 && pressureHigh > pressureLow) {
                pressureHigh--;
                updatePressureHigh();
            }
        }

        function resetPressureHigh() {
            pressureHigh = defaultPressureHigh;
            updatePressureHigh();
            updatePressureLow(); // Update low buttons in case they were disabled
        }

        function updatePressureHigh() {
            // Update the display
            document.getElementById('pressureHighValue').textContent = pressureHigh;
            
            // Update button states
            document.getElementById('decreasePressureHighBtn').disabled = pressureHigh <= 1 || pressureHigh <= pressureLow;
            document.getElementById('increasePressureHighBtn').disabled = pressureHigh >= 10;
        }

        // Calculate pressure-based stroke width
        function calculatePressureStrokeWidth(pressure) {
            if (!pressureSensitivity || pressure === undefined || pressure === 0) {
                return currentStrokeSize;
            }
            
            // Map pressure (0-1) to our pressure range (pressureLow - pressureHigh)
            const minWidth = pressureLow;
            const maxWidth = pressureHigh;
            
            // Clamp pressure between 0 and 1
            const clampedPressure = Math.max(0, Math.min(1, pressure));
            
            // Linear interpolation between min and max width
            const pressureWidth = minWidth + (clampedPressure * (maxWidth - minWidth));
            
            return Math.round(pressureWidth);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('pdfViewer').style.display === 'block') {
                switch(e.key) {
                    case 'ArrowRight':
                    case 'ArrowDown':
                        e.preventDefault();
                        nextPage();
                        break;
                    case 'ArrowLeft':
                    case 'ArrowUp':
                        e.preventDefault();
                        prevPage();
                        break;
                    case 'Escape':
                        goHome();
                        break;
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (pdfDocument && document.getElementById('pdfViewer').style.display === 'block') {
                resizeCanvases();
                renderPage(currentPage);
            }
        });
    </script>
</body>
</html>
