<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pressure Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .drawing-canvas {
            touch-action: none;
            user-select: none;
        }
        
        .pressure-indicator {
            transition: all 0.1s ease;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <!-- Toolbar -->
    <div class="border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm">
        <div class="flex items-center justify-between max-w-6xl mx-auto">
            <div class="flex items-center space-x-4">
                <!-- Brush Size -->
                <div class="flex items-center space-x-2">
                    <label class="text-sm font-medium">Size:</label>
                    <input 
                        type="range" 
                        id="brushSize" 
                        min="1" 
                        max="50" 
                        value="5" 
                        class="w-20"
                    >
                    <span id="sizeDisplay" class="text-sm w-8">5px</span>
                </div>
                
                <!-- Color Picker -->
                <div class="flex items-center space-x-2">
                    <label class="text-sm font-medium">Color:</label>
                    <input 
                        type="color" 
                        id="colorPicker" 
                        value="#000000" 
                        class="w-10 h-8 rounded border border-gray-300 dark:border-gray-600"
                    >
                </div>
                
                <!-- Pressure Indicator -->
                <div class="flex items-center space-x-2">
                    <label class="text-sm font-medium">Pressure:</label>
                    <div class="w-16 h-3 bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden">
                        <div id="pressureBar" class="h-full bg-[#5D5CDE] transition-all duration-100 ease-out" style="width: 0%"></div>
                    </div>
                    <span id="pressureDisplay" class="text-xs w-8">0%</span>
                </div>
                
                <!-- Stroke Size Display -->
                <div class="flex items-center space-x-2">
                    <label class="text-sm font-medium">Stroke:</label>
                    <span id="strokeSizeDisplay" class="text-sm w-12 font-mono">0px</span>
                    <div class="flex items-center">
                        <div id="strokePreview" class="bg-gray-800 dark:bg-gray-200 rounded-full transition-all duration-100 ease-out" style="width: 2px; height: 2px;"></div>
                    </div>
                </div>
            </div>
            
            <div class="flex items-center space-x-2">
                <!-- Clear Button -->
                <button 
                    id="clearBtn" 
                    class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg text-sm font-medium transition-colors"
                >
                    Clear
                </button>
                
                <!-- Download Button -->
                <button 
                    id="downloadBtn" 
                    class="px-4 py-2 bg-[#5D5CDE] hover:bg-[#4a49c7] text-white rounded-lg text-sm font-medium transition-colors"
                >
                    Download SVG
                </button>
            </div>
        </div>
    </div>

    <!-- Drawing Area -->
    <div class="flex-1 overflow-hidden">
        <div id="canvasContainer" class="w-full h-screen relative">
            <svg 
                id="drawingSvg" 
                class="drawing-canvas w-full h-full cursor-crosshair"
                style="background: white;"
            >
                <defs>
                    <filter id="smoothing" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur in="SourceGraphic" stdDeviation="0.5"/>
                    </filter>
                </defs>
            </svg>
            <!-- Eraser Area Indicator -->
            <div 
                id="eraserIndicator" 
                class="absolute pointer-events-none rounded-full border-2 border-pink-500 bg-pink-200 hidden"
                style="opacity: 0.7; z-index: 1000; top: 0; left: 0; transform: translate3d(-50%, -50%, 0);"
            ></div>
        </div>
    </div>

    <script>
        // Dark mode support
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        class PressureDrawingApp {
            constructor() {
                this.svg = document.getElementById('drawingSvg');
                this.brushSize = document.getElementById('brushSize');
                this.colorPicker = document.getElementById('colorPicker');
                this.sizeDisplay = document.getElementById('sizeDisplay');
                this.pressureBar = document.getElementById('pressureBar');
                this.pressureDisplay = document.getElementById('pressureDisplay');
                this.strokeSizeDisplay = document.getElementById('strokeSizeDisplay');
                this.strokePreview = document.getElementById('strokePreview');
                this.clearBtn = document.getElementById('clearBtn');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.eraserIndicator = document.getElementById('eraserIndicator');
                
                this.isDrawing = false;
                this.isErasing = false;
                this.currentStroke = null;
                this.strokePoints = [];
                this.lastPoint = null;
                this.pathCounter = 0;
                this.smoothingFactor = 0.4;
                
                // Dynamic eraser properties (from working code)
                this.eraserMinSize = 10;
                this.eraserMaxSize = 50;
                this.eraserSpeedThreshold = 150;
                this.currentEraserSize = this.eraserMinSize;
                this.targetEraserSize = this.eraserMinSize;
                this.lastEraserPoint = null;
                this.lastEraserTime = 0;
                this.eraserSpeed = 0;
                
                // Protective erase system
                this.eraserProtectionActive = false;
                this.strokeJustErased = false;
                this.highSpeedOverrideThreshold = 225; // px/s - high speed to override protection (1.5x normal speed)
                this.erasedStrokesCount = 0;
                
                // Store all strokes with their actual points
                this.allStrokes = [];
                
                this.initializeEvents();
                this.updateCanvasSize();
            }
            
            initializeEvents() {
                // Pointer events for pressure sensitivity
                this.svg.addEventListener('pointerdown', this.startDrawing.bind(this));
                this.svg.addEventListener('pointermove', this.draw.bind(this));
                this.svg.addEventListener('pointerup', this.stopDrawing.bind(this));
                this.svg.addEventListener('pointercancel', this.stopDrawing.bind(this));
                
                // Prevent context menu on right click
                this.svg.addEventListener('contextmenu', e => e.preventDefault());
                
                // Brush size control
                this.brushSize.addEventListener('input', () => {
                    this.sizeDisplay.textContent = this.brushSize.value + 'px';
                });
                
                // Clear button
                this.clearBtn.addEventListener('click', this.clearCanvas.bind(this));
                
                // Download button
                this.downloadBtn.addEventListener('click', this.downloadSVG.bind(this));
                
                // Window resize
                window.addEventListener('resize', this.updateCanvasSize.bind(this));
            }
            
            updateCanvasSize() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();
                this.svg.setAttribute('width', rect.width);
                this.svg.setAttribute('height', rect.height);
                this.svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
            }
            
            getPointerPosition(e) {
                const rect = this.svg.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    pressure: e.pressure || 0.5 // Fallback for devices without pressure
                };
            }
            
            updatePressureIndicator(pressure) {
                const percentage = Math.round(pressure * 100);
                this.pressureBar.style.width = percentage + '%';
                this.pressureDisplay.textContent = percentage + '%';
                
                // Update real-time stroke size display
                this.updateStrokeSizeDisplay(pressure);
            }
            
            updateStrokeSizeDisplay(pressure) {
                // Calculate the same stroke size that's being drawn
                const baseSize = parseInt(this.brushSize.value);
                const strokeSize = Math.max(1, baseSize * this.calculatePressureCurve(pressure));
                const roundedSize = Math.round(strokeSize * 10) / 10; // Round to 1 decimal
                
                // Update text display
                this.strokeSizeDisplay.textContent = roundedSize + 'px';
                
                // Update visual preview (max 16px for UI, but cap minimum at 2px for visibility)
                const previewSize = Math.min(Math.max(strokeSize, 2), 16);
                this.strokePreview.style.width = previewSize + 'px';
                this.strokePreview.style.height = previewSize + 'px';
                
                // Update preview color to match current color
                this.strokePreview.style.backgroundColor = this.colorPicker.value;
            }
            
            // Custom pressure curve: gentle 0-40%, aggressive 45-95%, gentle 95-100%
            calculatePressureCurve(pressure) {
                if (pressure <= 0.4) {
                    // Gentle curve from 0-40%: 20% to 35% of base size
                    return 0.2 + (pressure / 0.4) * 0.15; // 15% range over 40% pressure
                } else if (pressure <= 0.45) {
                    // Smooth transition from 40-45%: 35% to 40% of base size
                    return 0.35 + ((pressure - 0.4) / 0.05) * 0.05; // 5% range over 5% pressure
                } else if (pressure <= 0.95) {
                    // Very aggressive curve from 45-95%: 40% to 90% of base size
                    return 0.4 + ((pressure - 0.45) / 0.5) * 0.5; // 50% range over 50% pressure (1% per 1% pressure!)
                } else {
                    // Gentle end from 95-100%: 90% to 100% of base size
                    return 0.9 + ((pressure - 0.95) / 0.05) * 0.1; // 10% range over 5% pressure
                }
            }
            
            startDrawing(e) {
                // Only allow pen/stylus input, ignore finger touches
                if (e.pointerType === 'touch') {
                    return;
                }
                
                e.preventDefault();
                
                // Check if eraser is being used (Microsoft Surface Pen button 5 or buttons 32)
                if (e.button === 5 || e.buttons === 32 || (e.pointerType === 'pen' && e.button === 2)) {
                    this.isErasing = true;
                    this.isDrawing = false;
                    this.svg.classList.add('eraser-mode');
                    this.svg.style.cursor = 'none'; // Hide cursor, we'll use custom indicator
                    this.startErasing(e);
                    return;
                }
                
                this.isDrawing = true;
                this.isErasing = false;
                this.svg.classList.remove('eraser-mode');
                this.svg.style.cursor = 'crosshair';
                
                const point = this.getPointerPosition(e);
                this.updatePressureIndicator(point.pressure);
                
                // Create new stroke group
                this.currentStroke = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.currentStroke.setAttribute('fill', this.colorPicker.value);
                this.currentStroke.setAttribute('filter', 'url(#smoothing)');
                this.svg.appendChild(this.currentStroke);
                
                // Initialize stroke points array
                this.strokePoints = [];
                
                // Add first point with pressure
                const baseSize = parseInt(this.brushSize.value);
                const pressureSize = Math.max(1, baseSize * (0.2 + point.pressure * 0.8));
                
                this.strokePoints.push({
                    x: point.x,
                    y: point.y,
                    pressure: point.pressure,
                    width: pressureSize
                });
                
                this.lastPoint = point;
                this.pathCounter++;
            }
            
            draw(e) {
                e.preventDefault();
                
                if (this.isErasing) {
                    this.erase(e);
                    return;
                }
                
                if (!this.isDrawing || !this.currentStroke) return;
                
                const point = this.getPointerPosition(e);
                this.updatePressureIndicator(point.pressure);
                
                if (this.lastPoint) {
                    // Calculate distance to determine if we should add a point
                    const distance = Math.sqrt(
                        Math.pow(point.x - this.lastPoint.x, 2) + 
                        Math.pow(point.y - this.lastPoint.y, 2)
                    );
                    
                    if (distance > 2) { // Only add point if moved enough
                        const baseSize = parseInt(this.brushSize.value);
                        const pressureSize = Math.max(1, baseSize * (0.2 + point.pressure * 0.8));
                        
                        // Add new point with current pressure
                        this.strokePoints.push({
                            x: point.x,
                            y: point.y,
                            pressure: point.pressure,
                            width: pressureSize
                        });
                        
                        // Redraw the entire stroke with variable widths
                        this.redrawStroke();
                        
                        this.lastPoint = point;
                    }
                }
            }
            
            getSmoothedPoint(points, index, tension = 0.5) {
                if (index <= 0 || index >= points.length - 1) {
                    return points[index];
                }
                
                const p0 = points[index - 1] || points[index];
                const p1 = points[index];
                const p2 = points[index + 1] || points[index];
                const p3 = points[index + 2] || p2;
                
                return {
                    x: p1.x + tension * (p2.x - p0.x),
                    y: p1.y + tension * (p2.y - p0.y),
                    width: p1.width,
                    pressure: p1.pressure
                };
            }
            
            createSmoothStrokePath() {
                if (this.strokePoints.length < 2) return;
                
                const smoothPoints = [];
                
                // Create smoothed points using Catmull-Rom interpolation
                for (let i = 0; i < this.strokePoints.length; i++) {
                    if (i === 0 || i === this.strokePoints.length - 1) {
                        smoothPoints.push(this.strokePoints[i]);
                    } else {
                        // Add multiple interpolated points between each pair
                        const steps = 3;
                        for (let t = 0; t < steps; t++) {
                            const ratio = t / steps;
                            const p1 = this.strokePoints[i];
                            const p2 = this.strokePoints[i + 1];
                            
                            smoothPoints.push({
                                x: p1.x + (p2.x - p1.x) * ratio,
                                y: p1.y + (p2.y - p1.y) * ratio,
                                width: p1.width + (p2.width - p1.width) * ratio,
                                pressure: p1.pressure + (p2.pressure - p1.pressure) * ratio
                            });
                        }
                    }
                }
                
                return smoothPoints;
            }
            
            redrawStroke() {
                if (this.strokePoints.length < 2) {
                    // For single point, just draw a circle
                    if (this.strokePoints.length === 1) {
                        this.currentStroke.innerHTML = '';
                        const point = this.strokePoints[0];
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', point.width / 2);
                        circle.setAttribute('fill', this.colorPicker.value);
                        this.currentStroke.appendChild(circle);
                    }
                    return;
                }
                
                // Clear current stroke content
                this.currentStroke.innerHTML = '';
                
                // Create smooth outline path with variable width
                this.createSmoothVariableWidthPath();
            }
            
            createSmoothVariableWidthPath() {
                const points = this.strokePoints;
                if (points.length < 2) return;
                
                // Calculate smooth outline points for both sides of the stroke
                const leftPoints = [];
                const rightPoints = [];
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const halfWidth = point.width / 2;
                    
                    // Calculate direction vector
                    let dirX = 0, dirY = 0;
                    
                    if (i === 0 && points.length > 1) {
                        // First point: use direction to next point
                        dirX = points[i + 1].x - point.x;
                        dirY = points[i + 1].y - point.y;
                    } else if (i === points.length - 1) {
                        // Last point: use direction from previous point
                        dirX = point.x - points[i - 1].x;
                        dirY = point.y - points[i - 1].y;
                    } else {
                        // Middle point: average of both directions for smoothness
                        const prevDirX = point.x - points[i - 1].x;
                        const prevDirY = point.y - points[i - 1].y;
                        const nextDirX = points[i + 1].x - point.x;
                        const nextDirY = points[i + 1].y - point.y;
                        dirX = (prevDirX + nextDirX) / 2;
                        dirY = (prevDirY + nextDirY) / 2;
                    }
                    
                    // Normalize direction and get perpendicular
                    const length = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (length > 0) {
                        dirX /= length;
                        dirY /= length;
                    }
                    
                    // Perpendicular vector
                    const perpX = -dirY;
                    const perpY = dirX;
                    
                    // Calculate left and right edge points
                    leftPoints.push({
                        x: point.x + perpX * halfWidth,
                        y: point.y + perpY * halfWidth
                    });
                    
                    rightPoints.push({
                        x: point.x - perpX * halfWidth,
                        y: point.y - perpY * halfWidth
                    });
                }
                
                // Create smooth path using the outline points
                let pathData = '';
                
                // Start with the first left point
                pathData += `M ${leftPoints[0].x} ${leftPoints[0].y}`;
                
                // Draw smooth curve along left side
                for (let i = 1; i < leftPoints.length; i++) {
                    const prevPoint = leftPoints[i - 1];
                    const currentPoint = leftPoints[i];
                    const controlX = (prevPoint.x + currentPoint.x) / 2;
                    const controlY = (prevPoint.y + currentPoint.y) / 2;
                    pathData += ` Q ${prevPoint.x} ${prevPoint.y} ${controlX} ${controlY}`;
                }
                
                // Add the last left point
                const lastLeft = leftPoints[leftPoints.length - 1];
                pathData += ` L ${lastLeft.x} ${lastLeft.y}`;
                
                // Connect to right side at the end
                const lastRight = rightPoints[rightPoints.length - 1];
                pathData += ` L ${lastRight.x} ${lastRight.y}`;
                
                // Draw smooth curve along right side (in reverse)
                for (let i = rightPoints.length - 2; i >= 0; i--) {
                    const currentPoint = rightPoints[i];
                    const nextPoint = rightPoints[i + 1];
                    const controlX = (currentPoint.x + nextPoint.x) / 2;
                    const controlY = (currentPoint.y + nextPoint.y) / 2;
                    pathData += ` Q ${nextPoint.x} ${nextPoint.y} ${controlX} ${controlY}`;
                }
                
                // Close the path
                pathData += ` Z`;
                
                // Create the final stroke path
                const strokePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                strokePath.setAttribute('d', pathData);
                strokePath.setAttribute('fill', this.colorPicker.value);
                strokePath.setAttribute('stroke', 'none');
                
                this.currentStroke.appendChild(strokePath);
            }
            
            updateEraserIndicator(x, y) {
                // Use transform3d for hardware acceleration and best performance
                this.eraserIndicator.style.transform = `translate3d(${x}px, ${y}px, 0) translate3d(-50%, -50%, 0)`;
            }
            
            showEraserIndicator() {
                // Set the indicator size to match the dynamic eraser size
                this.eraserIndicator.style.width = this.currentEraserSize + 'px';
                this.eraserIndicator.style.height = this.currentEraserSize + 'px';
                this.eraserIndicator.classList.remove('hidden');
            }
            
            hideEraserIndicator() {
                this.eraserIndicator.classList.add('hidden');
            }
            
            startErasing(e) {
                const point = this.getPointerPosition(e);
                this.showEraserIndicator();
                this.updateEraserIndicator(point.x, point.y);
                this.erase(e);
            }
            
            erase(e) {
                const point = this.getPointerPosition(e);
                
                // Calculate dynamic eraser size based on speed
                this.calculateEraserSpeed(point);
                
                // Update indicator size dynamically
                this.eraserIndicator.style.width = this.currentEraserSize + 'px';
                this.eraserIndicator.style.height = this.currentEraserSize + 'px';
                
                // Update indicator position
                this.updateEraserIndicator(point.x, point.y);
                
                // Use the proven point-based collision detection from working code
                this.eraseAtPoint(point.x, point.y);
            }
            
            // Dynamic eraser sizing (from working code)
            calculateEraserSpeed(point) {
                const currentTime = Date.now();

                if (this.lastEraserPoint && this.lastEraserTime) {
                    const distance = Math.sqrt(
                        (point.x - this.lastEraserPoint.x) ** 2 + 
                        (point.y - this.lastEraserPoint.y) ** 2
                    );
                    const timeDelta = currentTime - this.lastEraserTime;

                    if (timeDelta > 0) {
                        const speed = (distance / timeDelta) * 1000;
                        this.eraserSpeed = this.eraserSpeed * 0.7 + speed * 0.3;
                    }
                }

                this.lastEraserPoint = point;
                this.lastEraserTime = currentTime;
                this.updateDynamicEraserSize();
            }

            updateDynamicEraserSize() {
                let speedFactor = 0;

                if (this.eraserSpeed > this.eraserSpeedThreshold) {
                    const speedOverThreshold = this.eraserSpeed - this.eraserSpeedThreshold;
                    const maxSpeedRange = 300;
                    speedFactor = Math.min(speedOverThreshold / maxSpeedRange, 1);
                }

                this.targetEraserSize = this.eraserMinSize + 
                    (this.eraserMaxSize - this.eraserMinSize) * speedFactor;

                this.targetEraserSize = Math.max(this.eraserMinSize, 
                    Math.min(this.eraserMaxSize, this.targetEraserSize));

                const lerpFactor = 0.15;
                this.currentEraserSize = this.currentEraserSize + 
                    (this.targetEraserSize - this.currentEraserSize) * lerpFactor;
            }

            resetEraserTracking() {
                this.lastEraserPoint = null;
                this.lastEraserTime = 0;
                this.eraserSpeed = 0;
                this.currentEraserSize = this.eraserMinSize;
                
                // Reset protective erase system
                this.resetProtectiveErase();
            }
            
            resetProtectiveErase() {
                this.eraserProtectionActive = false;
                this.strokeJustErased = false;
                this.erasedStrokesCount = 0;
                
                console.log('ðŸ”„ Protective erase reset - ready to erase');
            }
            
            // Point-based eraser collision with protective erase
            eraseAtPoint(x, y) {
                // Check if protection should be overridden
                this.checkProtectionOverride();
                
                // If protection is active and no override, don't erase
                if (this.eraserProtectionActive) {
                    this.updateEraserIndicatorProtectionState(true);
                    return;
                }
                
                this.updateEraserIndicatorProtectionState(false);
                
                const eraserRadius = this.currentEraserSize / 2;
                const strokesToRemove = [];

                for (let i = 0; i < this.allStrokes.length; i++) {
                    const stroke = this.allStrokes[i];
                    let shouldRemove = false;

                    for (const point of stroke.points) {
                        const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                        if (distance <= eraserRadius) {
                            shouldRemove = true;
                            break;
                        }
                    }

                    if (shouldRemove) {
                        if (stroke.element && stroke.element.parentNode) {
                            stroke.element.parentNode.removeChild(stroke.element);
                        }
                        strokesToRemove.push(i);
                    }
                }

                // If strokes were actually erased
                if (strokesToRemove.length > 0) {
                    for (let i = strokesToRemove.length - 1; i >= 0; i--) {
                        this.allStrokes.splice(strokesToRemove[i], 1);
                    }
                    
                    // Activate protection after first erase
                    this.activateEraserProtection();
                }
            }
            
            // Activate protective erase after first stroke is erased
            activateEraserProtection() {
                if (!this.strokeJustErased) {
                    this.strokeJustErased = true;
                    this.eraserProtectionActive = true;
                    this.erasedStrokesCount++;
                    
                    console.log('ðŸ›¡ï¸ Protective erase activated - move fast to override or lift eraser to erase more strokes');
                }
            }
            
            // Check conditions to override protection
            checkProtectionOverride() {
                if (!this.eraserProtectionActive) return;
                
                // Only override condition: High speed (broad erasing intent)
                const highSpeedIntent = this.eraserSpeed > this.highSpeedOverrideThreshold;
                
                if (highSpeedIntent) {
                    this.eraserProtectionActive = false;
                    console.log(`ðŸ”“ Protection override: high speed detected (${Math.round(this.eraserSpeed)}px/s)`);
                }
            }
            
            // Visual feedback for protection state
            updateEraserIndicatorProtectionState(isProtected) {
                if (isProtected) {
                    // Change indicator to show it's protected (red border)
                    this.eraserIndicator.style.borderColor = '#ef4444';
                    this.eraserIndicator.style.backgroundColor = 'rgba(239, 68, 68, 0.2)';
                } else {
                    // Normal pink indicator
                    this.eraserIndicator.style.borderColor = '#ec4899';
                    this.eraserIndicator.style.backgroundColor = 'rgba(236, 72, 153, 0.2)';
                }
            }
            
            stopDrawing(e) {
                e.preventDefault();
                
                if (this.isErasing) {
                    this.isErasing = false;
                    this.svg.classList.remove('eraser-mode');
                    this.svg.style.cursor = 'crosshair';
                    this.hideEraserIndicator();
                    this.resetEraserTracking();
                    return;
                }
                
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                // Finalize the stroke and store it with points
                if (this.currentStroke && this.strokePoints.length > 0) {
                    this.redrawStroke();
                    
                    // Store stroke with its points for eraser collision
                    this.allStrokes.push({
                        element: this.currentStroke,
                        points: [...this.strokePoints] // Copy the points
                    });
                }
                
                this.currentStroke = null;
                this.strokePoints = [];
                this.lastPoint = null;
                
                // Reset pressure indicator
                this.updatePressureIndicator(0);
            }
            
            clearCanvas() {
                // Clear the allStrokes array
                this.allStrokes = [];
                
                // Remove all stroke groups from SVG
                const groups = this.svg.querySelectorAll('g');
                groups.forEach(group => group.remove());
                this.pathCounter = 0;
            }
            
            downloadSVG() {
                const svgData = new XMLSerializer().serializeToString(this.svg);
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `drawing-${Date.now()}.svg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
            }
        }
        
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new PressureDrawingApp();
        });
    </script>
</body>
</html>
