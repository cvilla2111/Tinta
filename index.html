<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Drawing App - Stylus Only</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script>
    <style>
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 10;
            touch-action: none; /* Prevent default touch behaviors */
        }
        .pdf-page-container {
            position: relative;
            margin: 0 auto;
        }
        .tool-active {
            background-color: #E5E7EB !important;
            color: #374151 !important;
        }
        .dark .tool-active {
            background-color: #4B5563 !important;
            color: #F3F4F6 !important;
        }
        .selected-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-size {
            background-color: #4B5563 !important;
        }
        .selected-eraser-size {
            background-color: #E5E7EB !important;
        }
        .dark .selected-eraser-size {
            background-color: #4B5563 !important;
        }
        
        /* Page transition effects */
        .page-transition {
            transition: opacity 0.3s ease-in-out;
        }
        .page-fade-out {
            opacity: 0;
        }
        .page-fade-in {
            opacity: 1;
        }

        /* Page thumbnail modal */
        .page-thumbnail-modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        .page-thumbnail-modal.open {
            transform: translateX(0);
        }
        .page-thumbnail {
            transition: all 0.2s ease;
        }
        .page-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        .page-thumbnail.current {
            border-color: #5D5CDE !important;
            box-shadow: 0 0 0 2px #5D5CDE;
        }

        /* Enhanced eraser indicator with speed-based sizing - no transition for instant response */
        #eraserIndicator {
            /* Removed transitions for instant response at high speeds */
        }

        /* Presentation mode styles for receiver */
        .presentation-mode {
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        .presentation-content {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .presentation-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script><script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body class="bg-white dark:bg-gray-900 min-h-screen">
    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
                <h1 class="text-2xl font-bold text-gray-900 dark:text-white">PDF Drawing App</h1>
                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">Stylus-only drawing | 2-finger swipe navigation | MPP stylus with pressure &amp; speed-responsive eraser</p>
            </div>
            
            <!-- File Upload and Theme Toggle -->
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                <!-- Theme Toggle -->
                <div class="flex items-center gap-2">
                    <i data-lucide="sun" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="themeToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-gray-600"></div>
                    </label>
                    <i data-lucide="moon" class="w-4 h-4 text-gray-600 dark:text-gray-400"></i>
                </div>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 hidden sm:block"></div>
                
                <input type="file" id="pdfUpload" accept=".pdf" class="hidden">
                <button onclick="document.getElementById('pdfUpload').click()" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-base">
                    Upload PDF
                </button>
                <button id="downloadBtn" onclick="downloadPDF()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-base" disabled="">
                    Download
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div id="mainContent" class="max-w-7xl mx-auto">
        <!-- Initial Upload Area -->
        <div id="uploadArea" class="p-4">
            <div class="text-center">
                <div class="bg-gray-50 dark:bg-gray-800 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-12">
                    <div class="text-gray-400 dark:text-gray-500">
                        <svg class="mx-auto h-12 w-12 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        <p class="text-lg font-medium">No PDF loaded</p>
                        <p class="text-sm mt-2">Upload a PDF file to start drawing with stylus</p>
                        <div class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <p class="text-sm text-blue-700 dark:text-blue-300">
                                <strong>Note:</strong> Stylus-only drawing | Supports MPP stylus with pressure sensitivity and speed-responsive eraser.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Viewer Area (Full Screen) -->
        <div id="pdfViewer" class="hidden fixed inset-0 bg-white">
            <!-- Settings Modal -->
            <div id="settingsModal" class="fixed bottom-20 left-4 z-40 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-4 hidden">
                <!-- Pen Settings -->
                <div id="penSettings" class="hidden">
                    <!-- Brush Size Dots and Pressure Switch in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setBrushSize(0.5)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="0.5">
                            <div style="width: 1px; height: 1px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(1)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="1">
                            <div style="width: 1px; height: 1px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(1.3)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="1.3">
                            <div style="width: 1.3px; height: 1.3px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(2)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="2">
                            <div style="width: 2px; height: 2px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(4)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="4">
                            <div style="width: 4px; height: 4px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(6)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="6">
                            <div style="width: 6px; height: 6px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(8)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="8">
                            <div style="width: 8px; height: 8px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(11)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="11">
                            <div style="width: 11px; height: 11px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(14)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="14">
                            <div style="width: 14px; height: 14px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(16)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="16">
                            <div style="width: 16px; height: 16px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(18)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="18">
                            <div style="width: 18px; height: 18px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setBrushSize(20)" class="brush-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-size="20">
                            <div style="width: 20px; height: 20px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        
                        <div class="w-px h-6 bg-gray-300 dark:bg-gray-600 mx-2"></div>
                        
                        <!-- Pressure Switch -->
                        <div class="flex items-center gap-2">
                            <i data-lucide="zap" class="w-3 h-3 text-gray-600 dark:text-gray-400"></i>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="pressureSwitch" class="sr-only peer" checked="">
                                <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Pressure</span>
                        </div>
                    </div>
                </div>

                <!-- Color Settings -->
                <div id="colorSettings" class="hidden flex items-center gap-4">
                    <!-- Color Grid -->
                    <div class="grid grid-cols-10 gap-1">
                        <button onclick="setColor('#000000')" class="w-5 h-5 rounded-full bg-black border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#FFFFFF')" class="w-5 h-5 rounded-full bg-white border border-gray-400 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#6B7280')" class="w-5 h-5 rounded-full bg-gray-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EF4444')" class="w-5 h-5 rounded-full bg-red-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F97316')" class="w-5 h-5 rounded-full bg-orange-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F59E0B')" class="w-5 h-5 rounded-full bg-yellow-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#84CC16')" class="w-5 h-5 rounded-full bg-lime-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#10B981')" class="w-5 h-5 rounded-full bg-emerald-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#06B6D4')" class="w-5 h-5 rounded-full bg-cyan-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#3B82F6')" class="w-5 h-5 rounded-full bg-blue-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        
                        <button onclick="setColor('#6366F1')" class="w-5 h-5 rounded-full bg-indigo-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#8B5CF6')" class="w-5 h-5 rounded-full bg-violet-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#A855F7')" class="w-5 h-5 rounded-full bg-purple-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#EC4899')" class="w-5 h-5 rounded-full bg-pink-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#F43F5E')" class="w-5 h-5 rounded-full bg-rose-500 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#DC2626')" class="w-5 h-5 rounded-full bg-red-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#059669')" class="w-5 h-5 rounded-full bg-emerald-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#2563EB')" class="w-5 h-5 rounded-full bg-blue-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#7C3AED')" class="w-5 h-5 rounded-full bg-violet-600 border border-gray-300 hover:scale-110 transition-transform"></button>
                        <button onclick="setColor('#92400E')" class="w-5 h-5 rounded-full bg-yellow-800 border border-gray-300 hover:scale-110 transition-transform"></button>
                    </div>
                </div>

                <!-- Eraser Settings -->
                <div id="eraserSettings" class="hidden">
                    <!-- Eraser Size Dots in Horizontal Pill -->
                    <div class="flex items-center gap-2">
                        <button onclick="setEraserSize(8)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors selected-eraser-size relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="8">
                            <div style="width: 8px; height: 8px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(12)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="12">
                            <div style="width: 12px; height: 12px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(13)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="13">
                            <div style="width: 13px; height: 13px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(25)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="25">
                            <div style="width: 25px; height: 25px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(35)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="35">
                            <div style="width: 35px; height: 35px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                        <button onclick="setEraserSize(50)" class="eraser-size-dot hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors relative flex items-center justify-center w-8 h-8 border border-gray-300 dark:border-gray-600" data-eraser-size="50">
                            <div style="width: 50px; height: 50px;" class="bg-gray-800 dark:bg-gray-200 rounded-full"></div>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Page Navigation -->
            <div id="pageNavigation" class="fixed top-4 right-4 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-3 py-1.5 flex items-center gap-2">
                <button onclick="changePage(-1)" id="prevPageBtn" class="w-6 h-6 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="chevron-left" class="w-3 h-3 text-gray-700 dark:text-gray-300"></i>
                </button>
                
                <button onclick="openPageThumbnailModal()" class="flex items-center gap-1 px-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors">
                    <span id="currentPageNum" class="text-xs font-medium text-gray-900 dark:text-gray-100">1</span>
                    <span class="text-xs text-gray-500 dark:text-gray-400">/</span>
                    <span id="totalPagesNum" class="text-xs text-gray-500 dark:text-gray-400">1</span>
                </button>
                
                <button onclick="changePage(1)" id="nextPageBtn" class="w-6 h-6 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="chevron-right" class="w-3 h-3 text-gray-700 dark:text-gray-300"></i>
                </button>
            </div>

            <!-- Bottom Left Toolbar -->
            <div id="floatingToolbar" class="fixed bottom-4 left-4 z-50 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700 px-6 py-3 flex items-center gap-4">
                <!-- Tool Selection -->
                <button id="penTool" onclick="setTool('pen')" class="w-8 h-8 rounded-full flex items-center justify-center tool-active hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="pen-tool" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="eraserTool" onclick="setTool('eraser')" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="eraser" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button id="colorTool" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <div id="colorIndicator" class="w-5 h-5 rounded-full border-2 border-gray-400 dark:border-gray-500" style="background-color: #000000;"></div>
                </button>
                
                <div class="w-px h-6 bg-gray-300 dark:bg-gray-600"></div>
                
                <!-- Actions -->
                <button onclick="openPresentationMode()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="cast" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button onclick="toggleFullscreen()" id="fullscreenBtn" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="maximize" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                </button>
                <button onclick="clearCanvas()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i data-lucide="trash-2" class="w-4 h-4 text-red-600 dark:text-red-400"></i>
                </button>
            </div>

            <!-- Page Thumbnail Modal -->
            <div id="pageThumbnailModal" class="page-thumbnail-modal fixed inset-y-0 right-0 w-80 bg-white dark:bg-gray-800 shadow-2xl z-[70] border-l border-gray-200 dark:border-gray-700">
                <div class="h-full flex flex-col">
                    <!-- Header -->
                    <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
                        <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Pages</h3>
                        <button onclick="closePageThumbnailModal()" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                            <i data-lucide="x" class="w-4 h-4 text-gray-700 dark:text-gray-300"></i>
                        </button>
                    </div>
                    
                    <!-- Thumbnails Container -->
                    <div id="thumbnailContainer" class="flex-1 overflow-y-auto p-4 space-y-3">
                        <!-- Thumbnails will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Modal Backdrop -->
            <div id="modalBackdrop" class="fixed inset-0 bg-black bg-opacity-50 z-[65] hidden" onclick="closePageThumbnailModal()"></div>

            <!-- PDF Content -->
            <div id="pdfContent" class="w-full h-full flex items-center justify-center overflow-auto"></div>
            

        </div>
    </div>

    <script>
        // Initialize PDF.js globally first
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Check if this is the presentation receiver
        if (window.location.hash === '#receiver') {
            console.log('Initializing presentation receiver...');
            document.body.className = 'presentation-mode';
            setupPresentationReceiver();
        } else {
            // Initialize main app
            initializeMainApp();
        }

        function setupPresentationReceiver() {
            console.log('Setting up presentation receiver...');
            
            // Hide all UI elements except content
            try {
                document.querySelector('header').style.display = 'none';
                document.getElementById('mainContent').style.display = 'none';
            } catch (e) {
                console.log('Error hiding elements:', e);
            }
            
            // Create presentation content container
            const presentationContainer = document.createElement('div');
            presentationContainer.className = 'presentation-content';
            presentationContainer.id = 'presentationContent';
            presentationContainer.style.cssText = `
                width: 100vw;
                height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
                background: #000;
                color: #fff;
            `;
            
            // Add loading message
            presentationContainer.innerHTML = '<div style="text-align: center;"><h2>Waiting for presentation data...</h2><p>Connecting to controller...</p></div>';
            
            document.body.appendChild(presentationContainer);
            console.log('Presentation container created');
            
            // Setup message handling - try multiple approaches
            setupMessageHandling();
            
            // Send ready signal to controller after a short delay
            setTimeout(() => {
                sendReadySignal();
            }, 500);
        }

        function setupMessageHandling() {
            console.log('Setting up message handling...');
            
            // Method 1: Presentation API receiver
            if (navigator.presentation && navigator.presentation.receiver) {
                console.log('Using Presentation API receiver...');
                navigator.presentation.receiver.connectionList.then(list => {
                    console.log('Got connection list, connections:', list.connections.length);
                    
                    // Handle existing connections
                    list.connections.forEach(connection => {
                        console.log('Setting up existing connection');
                        connection.onmessage = event => {
                            console.log('Received message via existing connection:', event.data);
                            try {
                                const data = JSON.parse(event.data);
                                handlePresentationMessage(data);
                            } catch (error) {
                                console.error('Error parsing presentation message:', error);
                            }
                        };
                    });
                    
                    // Handle new connections
                    list.addEventListener('connectionavailable', event => {
                        console.log('New connection available');
                        const connection = event.connection;
                        connection.onmessage = event => {
                            console.log('Received message via new connection:', event.data);
                            try {
                                const data = JSON.parse(event.data);
                                handlePresentationMessage(data);
                            } catch (error) {
                                console.error('Error parsing presentation message:', error);
                            }
                        };
                    });
                }).catch(error => {
                    console.error('Error getting connection list:', error);
                    setupFallbackMessageHandling();
                });
            } else {
                console.log('Presentation API not available, using fallback');
                setupFallbackMessageHandling();
            }
        }

        function setupFallbackMessageHandling() {
            console.log('Setting up fallback message handling...');
            
            // Method 2: PostMessage fallback
            window.addEventListener('message', event => {
                console.log('Received postMessage:', event.data);
                try {
                    if (typeof event.data === 'string') {
                        const data = JSON.parse(event.data);
                        handlePresentationMessage(data);
                    } else if (typeof event.data === 'object') {
                        handlePresentationMessage(event.data);
                    }
                } catch (error) {
                    console.error('Error handling fallback message:', error);
                }
            });
            
            // Method 3: Try to communicate with opener window
            if (window.opener) {
                console.log('Window opener detected, requesting data...');
                window.opener.postMessage({ type: 'RECEIVER_READY' }, '*');
            }
            
            // Method 4: Check for shared data in sessionStorage/localStorage
            const checkForData = () => {
                try {
                    const data = sessionStorage.getItem('presentationData');
                    if (data) {
                        console.log('Found data in sessionStorage');
                        const parsedData = JSON.parse(data);
                        handlePresentationMessage(parsedData);
                        sessionStorage.removeItem('presentationData');
                    }
                } catch (e) {
                    console.log('SessionStorage not available or error:', e);
                }
            };
            
            // Check periodically for data
            const interval = setInterval(checkForData, 500);
            setTimeout(() => clearInterval(interval), 10000); // Stop after 10 seconds
        }

        let presentationPdfDoc = null;
        let presentationDrawingData = {};
        
        // Send ready signal to controller
        function sendReadySignal() {
            console.log('Sending ready signal to controller...');
            
            // Try multiple methods to signal readiness
            if (navigator.presentation && navigator.presentation.receiver) {
                navigator.presentation.receiver.connectionList.then(list => {
                    list.connections.forEach(connection => {
                        try {
                            connection.send(JSON.stringify({ type: 'RECEIVER_READY' }));
                            console.log('Ready signal sent via Presentation API');
                        } catch (e) {
                            console.log('Failed to send ready signal via Presentation API:', e);
                        }
                    });
                });
            }
            
            // Fallback: try postMessage to opener
            if (window.opener) {
                try {
                    window.opener.postMessage(JSON.stringify({ type: 'RECEIVER_READY' }), '*');
                    console.log('Ready signal sent via postMessage');
                } catch (e) {
                    console.log('Failed to send ready signal via postMessage:', e);
                }
            }
        }

        async function handlePresentationMessage(data) {
            switch (data.type) {
                case 'INIT_PDF':
                    // Initialize PDF from array buffer
                    const uint8Array = new Uint8Array(data.pdfArrayBuffer);
                    presentationPdfDoc = await pdfjsLib.getDocument(uint8Array).promise;
                    presentationDrawingData = data.drawingData;
                    renderPresentationPage(data.currentPage);
                    break;
                    
                case 'PAGE_CHANGE':
                    presentationDrawingData = data.drawingData;
                    renderPresentationPage(data.pageNum);
                    break;
                    
                case 'DRAWING_UPDATE':
                    presentationDrawingData[data.pageNum] = data.drawingData;
                    updatePresentationDrawing(data.pageNum);
                    break;
            }
        }

        async function renderPresentationPage(pageNum) {
            if (!presentationPdfDoc) return;
            
            try {
                const page = await presentationPdfDoc.getPage(pageNum);
                const container = document.getElementById('presentationContent');
                
                // Calculate scale to fit screen
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const viewport = page.getViewport({ scale: 1 });
                
                const scaleX = windowWidth / viewport.width;
                const scaleY = windowHeight / viewport.height;
                const scale = Math.min(scaleX, scaleY) * 0.95; // Leave small margin
                
                const scaledViewport = page.getViewport({ scale });
                
                // Create page container
                const pageContainer = document.createElement('div');
                pageContainer.className = 'pdf-page-container';
                pageContainer.style.width = scaledViewport.width + 'px';
                pageContainer.style.height = scaledViewport.height + 'px';
                
                // Create PDF canvas
                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;
                pdfCanvas.height = scaledViewport.height;
                pdfCanvas.style.display = 'block';
                
                // Create drawing canvas
                const drawingCanvas = document.createElement('canvas');
                drawingCanvas.className = 'presentation-canvas';
                drawingCanvas.width = scaledViewport.width;
                drawingCanvas.height = scaledViewport.height;
                
                // Clear and setup container
                container.innerHTML = '';
                pageContainer.appendChild(pdfCanvas);
                pageContainer.appendChild(drawingCanvas);
                container.appendChild(pageContainer);
                
                // Render PDF
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;
                
                // Render drawings if available
                if (presentationDrawingData[pageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    const img = new Image();
                    img.onload = function() {
                        const scaleX = scaledViewport.width / presentationDrawingData[pageNum].canvasWidth;
                        const scaleY = scaledViewport.height / presentationDrawingData[pageNum].canvasHeight;
                        
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                    };
                    img.src = presentationDrawingData[pageNum].imageData;
                }
                
            } catch (error) {
                console.error('Error rendering presentation page:', error);
            }
        }

        function updatePresentationDrawing(pageNum) {
            const container = document.getElementById('presentationContent');
            const drawingCanvas = container.querySelector('.presentation-canvas');
            
            if (drawingCanvas && presentationDrawingData[pageNum]) {
                const ctx = drawingCanvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    
                    const scaleX = drawingCanvas.width / presentationDrawingData[pageNum].canvasWidth;
                    const scaleY = drawingCanvas.height / presentationDrawingData[pageNum].canvasHeight;
                    
                    ctx.save();
                    ctx.scale(scaleX, scaleY);
                    ctx.drawImage(img, 0, 0);
                    ctx.restore();
                };
                img.src = presentationDrawingData[pageNum].imageData;
            }
        }

        function initializeMainApp() {
            // Dark mode detection
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            // Initialize PDF.js
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

            // Application state
            let pdfDoc = null;
            let pdfArrayBuffer = null; // Store PDF data for presentation window
            let currentPage = 1;
            let totalPages = 0;
            let currentTool = 'pen';
            let currentColor = '#000000';
            let currentBrushSize = 1.3;
            let currentEraserSize = 8;
            let pressureEnabled = true;
            let isDrawing = false;
            let drawingData = {}; // Store drawing data for each page with scale info
            let originalPageDimensions = {}; // Store original PDF page dimensions
            
            // Speed-based eraser sizing variables
            let lastMoveTime = 0;
            let velocityHistory = [];
            let currentDynamicEraserSize = 8;
            let targetDynamicEraserSize = 8; // Target size for smooth transitions
            let sizeTransitionTimeout = null; // For delayed size reduction
            let isWaitingToShrink = false; // Track if we're already waiting to shrink
            const maxVelocityHistory = 5;
            const minEraserSize = 13;  // Minimum eraser size
            const maxEraserSizeMultiplier = 13.46; // Maximum size multiplier based on speed (13px -> 175px)
            
            // Presentation mode state
            let presentationConnection = null;
            
            // Stylus eraser button state
            let originalTool = 'pen'; // Track the original tool before eraser button press
            let isEraserButtonPressed = false;

            // Double-click detection
            let lastClickTime = 0;
            let lastClickTarget = null;
            const DOUBLE_CLICK_DELAY = 300; // milliseconds

            // Drawing state
            let lastX = 0;
            let lastY = 0;

            // Calculate dynamic eraser size based on velocity with delayed size reduction
            function calculateDynamicEraserSize(currentX, currentY, timestamp, canvasRect, canvasElement) {
                if (currentTool !== 'eraser') return currentEraserSize;
                
                const deltaTime = timestamp - lastMoveTime;
                if (deltaTime <= 0 || lastMoveTime === 0) {
                    lastMoveTime = timestamp;
                    currentDynamicEraserSize = currentEraserSize;
                    targetDynamicEraserSize = currentEraserSize;
                    return currentEraserSize;
                }
                
                // Calculate movement distance in normalized coordinates (independent of canvas scaling)
                const deltaX = currentX - lastX;
                const deltaY = currentY - lastY;
                
                // Normalize the distance to be independent of canvas resolution and page dimensions
                // Use the original PDF dimensions as reference for consistent velocity across pages
                const originalDimensions = originalPageDimensions[currentPage];
                let normalizedDistance;
                
                if (originalDimensions && canvasElement) {
                    // Calculate the current canvas scale relative to original PDF dimensions
                    const canvasToOriginalScaleX = canvasElement.width / originalDimensions.width;
                    const canvasToOriginalScaleY = canvasElement.height / originalDimensions.height;
                    const averageScale = (canvasToOriginalScaleX + canvasToOriginalScaleY) / 2;
                    
                    // Normalize distance back to original PDF coordinate space
                    const normalizedDeltaX = deltaX / averageScale;
                    const normalizedDeltaY = deltaY / averageScale;
                    normalizedDistance = Math.sqrt(normalizedDeltaX * normalizedDeltaX + normalizedDeltaY * normalizedDeltaY);
                } else {
                    // Fallback: use raw canvas distance
                    normalizedDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                }
                
                // Calculate velocity (normalized pixels per millisecond)
                const velocity = normalizedDistance / deltaTime;
                
                // Add to velocity history for smoothing
                velocityHistory.push(velocity);
                if (velocityHistory.length > maxVelocityHistory) {
                    velocityHistory.shift();
                }
                
                // Calculate average velocity for smoother transitions
                const avgVelocity = velocityHistory.reduce((sum, v) => sum + v, 0) / velocityHistory.length;
                

                
                // Map velocity to size multiplier (consistent thresholds across all pages)
                const velocityThreshold = 0.15; // Minimum velocity to start scaling (very sensitive)
                const maxVelocity = 2.2; // Velocity at which max size is reached (very easy to reach max)
                
                let newTargetSize;
                if (avgVelocity <= velocityThreshold) {
                    newTargetSize = currentEraserSize;
                } else {
                    const normalizedVelocity = Math.min((avgVelocity - velocityThreshold) / (maxVelocity - velocityThreshold), 1.0);
                    const sizeMultiplier = 1.0 + (normalizedVelocity * (maxEraserSizeMultiplier - 1.0));
                    newTargetSize = currentEraserSize * sizeMultiplier;
                }
                
                // Handle size increase vs decrease differently
                if (newTargetSize > currentDynamicEraserSize) {
                    // Size increase: immediate response
                    currentDynamicEraserSize = newTargetSize;
                    targetDynamicEraserSize = newTargetSize;
                    isWaitingToShrink = false;
                    
                    // Clear any pending size reduction
                    if (sizeTransitionTimeout) {
                        clearTimeout(sizeTransitionTimeout);
                        sizeTransitionTimeout = null;
                    }
                } else if (newTargetSize < currentDynamicEraserSize && !isWaitingToShrink) {
                    // Size decrease: delayed response (only set timeout once)
                    targetDynamicEraserSize = newTargetSize;
                    isWaitingToShrink = true;
                    
                    // Delay size reduction by 300ms, then smooth transition
                    sizeTransitionTimeout = setTimeout(() => {
                        // Start smooth transition to smaller size
                        const startSize = currentDynamicEraserSize;
                        const endSize = targetDynamicEraserSize;
                        const startTime = performance.now();
                        const duration = 200; // 200ms smooth transition
                        
                        function animateSize(currentTime) {
                            const elapsed = currentTime - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            
                            // Ease-out cubic for smooth deceleration
                            const easedProgress = 1 - Math.pow(1 - progress, 3);
                            
                            currentDynamicEraserSize = startSize - (startSize - endSize) * easedProgress;
                            
                            if (progress < 1 && isWaitingToShrink) {
                                requestAnimationFrame(animateSize);
                            } else {
                                // Animation complete
                                currentDynamicEraserSize = targetDynamicEraserSize;
                                sizeTransitionTimeout = null;
                                isWaitingToShrink = false;
                            }
                        }
                        
                        requestAnimationFrame(animateSize);
                    }, 300); // 300ms delay before starting smooth size reduction
                }
                
                lastMoveTime = timestamp;
                return currentDynamicEraserSize;
            }

            // Reset speed tracking when starting a new stroke
            function resetSpeedTracking() {
                velocityHistory = [];
                lastMoveTime = 0;
                currentDynamicEraserSize = currentEraserSize;
                targetDynamicEraserSize = currentEraserSize;
                isWaitingToShrink = false;
                
                // Clear any pending size reduction
                if (sizeTransitionTimeout) {
                    clearTimeout(sizeTransitionTimeout);
                    sizeTransitionTimeout = null;
                }
            }

            // File upload handler
            document.getElementById('pdfUpload').addEventListener('change', handleFileUpload);

            // Settings event listeners
            function setupSettingsListeners() {
                // Pressure switch
                const pressureSwitch = document.getElementById('pressureSwitch');
                pressureSwitch.addEventListener('change', function() {
                    pressureEnabled = this.checked;
                });

                // Theme toggle switch
                const themeToggle = document.getElementById('themeToggle');
                
                // Set initial state based on current theme
                themeToggle.checked = document.documentElement.classList.contains('dark');
                
                themeToggle.addEventListener('change', function() {
                    if (this.checked) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                });

                // Tool buttons with double-click detection
                document.getElementById('penTool').addEventListener('pointerdown', handleToolDoubleClick);
                document.getElementById('eraserTool').addEventListener('pointerdown', handleToolDoubleClick);
                document.getElementById('colorTool').addEventListener('pointerdown', handleColorSingleClick);
            }

            // Brush size selection
            window.setBrushSize = function(size) {
                currentBrushSize = size;
                
                // Update visual selection
                document.querySelectorAll('.brush-size-dot').forEach(btn => {
                    btn.classList.remove('selected-size');
                });
                document.querySelector(`[data-size="${size}"]`).classList.add('selected-size');
                
                // Close modal after selection
                hideSettingsModal();
            }

            // Eraser size selection
            window.setEraserSize = function(size) {
                currentEraserSize = size;
                currentDynamicEraserSize = size; // Reset dynamic size
                
                // Update visual selection
                document.querySelectorAll('.eraser-size-dot').forEach(btn => {
                    btn.classList.remove('selected-eraser-size');
                });
                document.querySelector(`[data-eraser-size="${size}"]`).classList.add('selected-eraser-size');
                
                // Close modal after selection
                hideSettingsModal();
            }

            // Handle double-click on tool buttons
            function handleToolDoubleClick(e) {
                if (e.pointerType !== 'pen' && e.pointerType !== 'touch') return;
                
                const currentTime = Date.now();
                const target = e.currentTarget;
                
                if (lastClickTarget === target && (currentTime - lastClickTime) < DOUBLE_CLICK_DELAY) {
                    // Double-click detected
                    e.preventDefault();
                    const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                    showSettingsModal(toolType);
                } else {
                    // Single click - set tool
                    setTimeout(() => {
                        if (Date.now() - currentTime >= DOUBLE_CLICK_DELAY) {
                            const toolType = target.id === 'penTool' ? 'pen' : 'eraser';
                            setTool(toolType);
                        }
                    }, DOUBLE_CLICK_DELAY);
                }
                
                lastClickTime = currentTime;
                lastClickTarget = target;
            }

            // Handle single-click on color button
            function handleColorSingleClick(e) {
                if (e.pointerType !== 'pen' && e.pointerType !== 'touch') return;
                
                // Immediately show color picker on single tap
                e.preventDefault();
                showSettingsModal('color');
            }

            // Modal management
            function showSettingsModal(toolType) {
                const modal = document.getElementById('settingsModal');
                const penSettings = document.getElementById('penSettings');
                const eraserSettings = document.getElementById('eraserSettings');
                const colorSettings = document.getElementById('colorSettings');
                
                // Hide all settings panels
                penSettings.classList.add('hidden');
                eraserSettings.classList.add('hidden');
                colorSettings.classList.add('hidden');
                
                // Show the appropriate settings panel
                if (toolType === 'pen') {
                    penSettings.classList.remove('hidden');
                    // Ensure the correct brush size is visually selected
                    updateBrushSizeSelection();
                } else if (toolType === 'eraser') {
                    eraserSettings.classList.remove('hidden');
                    // Ensure the correct eraser size is visually selected
                    updateEraserSizeSelection();
                } else if (toolType === 'color') {
                    colorSettings.classList.remove('hidden');
                }
                
                // Show the modal
                modal.classList.remove('hidden');
            }

            // Function to update brush size visual selection
            function updateBrushSizeSelection() {
                // Remove selection from all brush size buttons
                document.querySelectorAll('.brush-size-dot').forEach(btn => {
                    btn.classList.remove('selected-size');
                });
                // Add selection to the current brush size button
                const currentButton = document.querySelector(`[data-size="${currentBrushSize}"]`);
                if (currentButton) {
                    currentButton.classList.add('selected-size');
                }
            }

            // Function to update eraser size visual selection
            function updateEraserSizeSelection() {
                // Remove selection from all eraser size buttons
                document.querySelectorAll('.eraser-size-dot').forEach(btn => {
                    btn.classList.remove('selected-eraser-size');
                });
                // Add selection to the current eraser size button
                const currentButton = document.querySelector(`[data-eraser-size="${currentEraserSize}"]`);
                if (currentButton) {
                    currentButton.classList.add('selected-eraser-size');
                }
            }

            function hideSettingsModal() {
                const modal = document.getElementById('settingsModal');
                modal.classList.add('hidden');
            }

            // Click outside modal to close
            document.addEventListener('pointerdown', function(e) {
                if (e.pointerType !== 'pen' && e.pointerType !== 'touch') return;
                
                const modal = document.getElementById('settingsModal');
                const toolbar = document.getElementById('floatingToolbar');
                
                if (!modal.contains(e.target) && !toolbar.contains(e.target) && !modal.classList.contains('hidden')) {
                    hideSettingsModal();
                }
            });

            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                if (!pdfDoc) return;
                
                if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    changePage(-1);
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    changePage(1);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closePDF();
                }
            });

            async function handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    pdfArrayBuffer = arrayBuffer.slice(); // Store a copy for presentation window
                    pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                    totalPages = pdfDoc.numPages;
                    currentPage = 1;
                    drawingData = {}; // Reset drawing data
                    
                    // Hide upload area and header, show PDF viewer
                    document.getElementById('uploadArea').style.display = 'none';
                    document.querySelector('header').style.display = 'none';
                    document.getElementById('pdfViewer').classList.remove('hidden');
                    
                    await renderPage(currentPage);
                    document.getElementById('downloadBtn').disabled = false;
                    
                    // Update page navigation UI
                    updatePageNavigation();
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    showCustomAlert('Error loading PDF file. Please try again.');
                }
            }

            async function renderPage(pageNum, withTransition = false, direction = 1) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    const container = document.getElementById('pdfContent');
                    
                    if (withTransition) {
                        await performFadeTransition(pageNum, direction);
                        return;
                    }
                    
                    // Calculate scale to fit the screen width (with small margin to prevent scrollbars)
                    const containerWidth = window.innerWidth - 20; // Small margin to prevent overflow
                    const viewport = page.getViewport({ scale: 1 });
                    
                    // Ultra-High-DPI rendering: Scale to fill the width, then render at 4x resolution for maximum quality
                    const displayScale = containerWidth / viewport.width;
                    const renderScale = displayScale * 4; // 4x resolution for ultra-high quality
                    const scaledViewport = page.getViewport({ scale: renderScale });
                    
                    // Calculate display dimensions (what user sees)
                    const displayWidth = Math.floor(containerWidth);
                    const displayHeight = Math.floor(viewport.height * displayScale);

                    // Create page container with display dimensions
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'pdf-page-container';
                    pageContainer.style.width = displayWidth + 'px';
                    pageContainer.style.height = displayHeight + 'px';

                    // Create and setup PDF canvas with high resolution
                    const pdfCanvas = document.createElement('canvas');
                    pdfCanvas.width = scaledViewport.width;  // High resolution (2x)
                    pdfCanvas.height = scaledViewport.height; // High resolution (2x)
                    pdfCanvas.style.width = displayWidth + 'px';  // Display size
                    pdfCanvas.style.height = displayHeight + 'px'; // Display size
                    pdfCanvas.style.display = 'block';

                    // Create and setup drawing canvas with CONSISTENT HIGH resolution across all pages
                    const drawingCanvas = document.createElement('canvas');
                    drawingCanvas.className = 'drawing-canvas';
                    
                    // Use CONSISTENT resolution scaling based on display size to ensure uniform pen thickness
                    // This ensures the same pen size across all pages regardless of PDF page dimensions
                    const targetResolutionMultiplier = 2; // Consistent 2x resolution for all pages
                    drawingCanvas.width = displayWidth * targetResolutionMultiplier;   // Consistent high resolution
                    drawingCanvas.height = displayHeight * targetResolutionMultiplier; // Consistent high resolution
                    
                    drawingCanvas.style.width = displayWidth + 'px';  // Display size
                    drawingCanvas.style.height = displayHeight + 'px'; // Display size

                    // Setup drawing event listeners
                    setupDrawingEvents(drawingCanvas);

                    // Clear container and add new elements
                    container.innerHTML = '';
                    pageContainer.appendChild(pdfCanvas);
                    pageContainer.appendChild(drawingCanvas);
                    container.appendChild(pageContainer);

                    // Store original page dimensions for first render or if not stored
                    if (!originalPageDimensions[pageNum]) {
                        originalPageDimensions[pageNum] = {
                            width: viewport.width,
                            height: viewport.height
                        };
                    }

                    // Render PDF page
                    const renderContext = {
                        canvasContext: pdfCanvas.getContext('2d'),
                        viewport: scaledViewport
                    };
                    await page.render(renderContext).promise;

                    // Restore drawing data for this page with perfect quality preservation
                    if (drawingData[pageNum]) {
                        const ctx = drawingCanvas.getContext('2d');
                        
                        // Set optimal image rendering settings for crisp quality
                        ctx.imageSmoothingEnabled = false; // Disable smoothing for pixel-perfect restoration
                        
                        const img = new Image();
                        img.onload = function() {
                            // Calculate scaling factors based on canvas size changes (use drawing canvas dimensions)
                            const scaleX = drawingCanvas.width / drawingData[pageNum].canvasWidth;
                            const scaleY = drawingCanvas.height / drawingData[pageNum].canvasHeight;
                            
                            // Scale and draw the image to fit the new canvas size
                            ctx.save();
                            ctx.scale(scaleX, scaleY);
                            ctx.drawImage(img, 0, 0);
                            ctx.restore();
                            
                            // Re-enable smoothing for future drawing operations
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                        };
                        img.src = drawingData[pageNum].imageData;
                    }

                    // Update modal visual selections to reflect current settings
                    updateBrushSizeSelection();
                    updateEraserSizeSelection();

                    // Reset any transition styles
                    container.style.transition = '';
                    container.style.transform = '';

                } catch (error) {
                    console.error('Error rendering page:', error);
                    // Reset styles on error
                    const container = document.getElementById('pdfContent');
                    container.style.transition = '';
                    container.style.transform = '';
                }
            }

            async function performFadeTransition(targetPageNum, direction) {
                const container = document.getElementById('pdfContent');
                const currentPageElement = container.firstElementChild;
                
                // Calculate scale for consistent sizing with ultra-high quality
                const containerWidth = window.innerWidth - 20;
                const targetPage = await pdfDoc.getPage(targetPageNum);
                const viewport = targetPage.getViewport({ scale: 1 });
                
                // Ultra-High-DPI rendering: Same 4x scaling as main render
                const displayScale = containerWidth / viewport.width;
                const renderScale = displayScale * 4; // 4x resolution for ultra-high quality
                const scaledViewport = targetPage.getViewport({ scale: renderScale });
                
                // Calculate display dimensions (what user sees)
                const displayWidth = Math.floor(containerWidth);
                const displayHeight = Math.floor(viewport.height * displayScale);

                // Create new page container
                const newPageContainer = document.createElement('div');
                newPageContainer.className = 'pdf-page-container';
                newPageContainer.style.cssText = `
                    width: ${displayWidth}px;
                    height: ${displayHeight}px;
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    opacity: 0;
                    transition: opacity 0.4s ease-in-out;
                `;

                // Create PDF canvas with ultra-high resolution
                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.width = scaledViewport.width;  // Ultra-high resolution (4x)
                pdfCanvas.height = scaledViewport.height; // Ultra-high resolution (4x)
                pdfCanvas.style.width = displayWidth + 'px';  // Display size
                pdfCanvas.style.height = displayHeight + 'px'; // Display size
                pdfCanvas.style.display = 'block';

                // Create drawing canvas with CONSISTENT HIGH resolution (same as main render)
                const drawingCanvas = document.createElement('canvas');
                drawingCanvas.className = 'drawing-canvas';
                const targetResolutionMultiplier = 2; // Same multiplier as main render
                drawingCanvas.width = displayWidth * targetResolutionMultiplier;   // Consistent high resolution
                drawingCanvas.height = displayHeight * targetResolutionMultiplier; // Consistent high resolution
                drawingCanvas.style.width = displayWidth + 'px';  // Display size
                drawingCanvas.style.height = displayHeight + 'px'; // Display size

                newPageContainer.appendChild(pdfCanvas);
                newPageContainer.appendChild(drawingCanvas);

                // Render the new page
                const renderContext = {
                    canvasContext: pdfCanvas.getContext('2d'),
                    viewport: scaledViewport
                };
                await targetPage.render(renderContext).promise;

                // Restore drawing data for new page
                if (drawingData[targetPageNum]) {
                    const ctx = drawingCanvas.getContext('2d');
                    const img = new Image();
                    img.onload = function() {
                        // Calculate scaling factors based on canvas size changes (use drawing canvas dimensions)
                        const scaleX = drawingCanvas.width / drawingData[targetPageNum].canvasWidth;
                        const scaleY = drawingCanvas.height / drawingData[targetPageNum].canvasHeight;
                        
                        ctx.save();
                        ctx.scale(scaleX, scaleY);
                        ctx.drawImage(img, 0, 0);
                        ctx.restore();
                    };
                    img.src = drawingData[targetPageNum].imageData;
                }

                // Position current page absolutely and prepare for fade out
                if (currentPageElement) {
                    currentPageElement.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        opacity: 1;
                        transition: opacity 0.5s ease-in-out;
                    `;
                }

                // Add new page to container (behind current page)
                container.appendChild(newPageContainer);

                // Force reflow
                newPageContainer.offsetHeight;

                // Start fade transition
                if (currentPageElement) {
                    currentPageElement.style.opacity = '0';
                }
                newPageContainer.style.opacity = '1';

                // Wait for fade animation to complete
                await new Promise(resolve => setTimeout(resolve, 400));

                // Clean up: remove old page and reset container
                container.innerHTML = '';
                
                // Reset new page styles to normal positioning
                newPageContainer.style.cssText = `
                    width: ${displayWidth}px;
                    height: ${displayHeight}px;
                    position: relative;
                    margin: 0 auto;
                    opacity: 1;
                `;
                
                container.appendChild(newPageContainer);

                // Setup drawing events for new page
                setupDrawingEvents(drawingCanvas);
            }

            function setupDrawingEvents(canvas) {
                const ctx = canvas.getContext('2d');
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Enhanced ink quality settings
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Stroke smoothing variables
                let points = [];
                let pressureHistory = [];
                const maxHistoryLength = 5;

                // 2-finger gesture variables
                let gestureStartTouches = [];
                let gestureCurrentTouches = [];
                let isGestureActive = false;
                let gestureStartTime = 0;
                const SWIPE_MIN_DISTANCE = 20; // Minimum swipe distance in pixels (very easy to trigger)
                const SWIPE_MAX_TIME = 2000; // Maximum time for swipe gesture in ms (very generous timing)

                // Create eraser indicator
                const eraserIndicator = document.createElement('div');
                eraserIndicator.id = 'eraserIndicator';
                eraserIndicator.style.cssText = `
                    position: absolute;
                    border: 2px dashed #666;
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 15;
                    display: none;
                    background: rgba(255, 255, 255, 0.1);
                `;
                document.body.appendChild(eraserIndicator);

                // Pointer events for stylus detection
                canvas.addEventListener('pointerdown', startDrawing);
                canvas.addEventListener('pointermove', draw);
                canvas.addEventListener('pointerup', stopDrawing);
                canvas.addEventListener('pointercancel', stopDrawing);
                
                // Only stop drawing on pointerout if we're actually drawing and the pointer leaves the document
                canvas.addEventListener('pointerout', (e) => {
                    // Only stop if we're actually drawing and the pointer is leaving the entire viewport
                    if (isDrawing && (e.clientX < 0 || e.clientY < 0 || 
                        e.clientX > window.innerWidth || e.clientY > window.innerHeight)) {
                        stopDrawing(e);
                    }
                });

                // Prevent default mouse behaviors to avoid conflicts (allow touch for finger input)
                canvas.addEventListener('mousedown', e => e.preventDefault());
                canvas.addEventListener('mousemove', e => e.preventDefault());
                canvas.addEventListener('mouseup', e => e.preventDefault());

                // 2-finger gesture detection with touch events
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

                function handleTouchStart(e) {
                    if (e.touches.length === 2) {
                        // 2-finger gesture detected - prevent drawing and start gesture tracking
                        e.preventDefault();
                        isGestureActive = true;
                        gestureStartTime = Date.now();
                        
                        // Store initial touch positions
                        gestureStartTouches = Array.from(e.touches).map(touch => ({
                            x: touch.clientX,
                            y: touch.clientY
                        }));
                        
                        // Stop any ongoing drawing
                        if (isDrawing) {
                            isDrawing = false;
                            hideEraserIndicator();
                            updatePressureIndicator(0);
                            resetSpeedTracking();
                        }
                    } else if (e.touches.length === 1 && !isGestureActive) {
                        // Allow single touch drawing to continue normally
                        // (the pointerdown handler will take care of this)
                    }
                }

                function handleTouchMove(e) {
                    if (isGestureActive && e.touches.length === 2) {
                        // Prevent scrolling/zooming while gesture is active
                        e.preventDefault();
                        
                        // Update current touch positions for gesture calculation
                        gestureCurrentTouches = Array.from(e.touches).map(touch => ({
                            x: touch.clientX,
                            y: touch.clientY
                        }));
                    } else if (e.touches.length !== 2) {
                        // Reset gesture if touch count changes
                        isGestureActive = false;
                        gestureStartTouches = [];
                        gestureCurrentTouches = [];
                    }
                }

                function handleTouchEnd(e) {
                    if (isGestureActive) {
                        // 2-finger gesture completed (even if not both fingers up simultaneously)
                        e.preventDefault();
                        
                        const gestureEndTime = Date.now();
                        const gestureTime = gestureEndTime - gestureStartTime;
                        
                        // Much more forgiving conditions - check if we have any gesture data
                        if (gestureTime <= SWIPE_MAX_TIME && gestureStartTouches.length >= 2) {
                            
                            // Use the last known positions if we don't have current positions
                            let endTouches = gestureCurrentTouches;
                            if (endTouches.length < 2 && gestureStartTouches.length >= 2) {
                                // If we lost tracking, try to estimate from remaining touches
                                if (e.touches.length > 0) {
                                    // Use current touch positions as approximation
                                    endTouches = Array.from(e.touches).map(touch => ({
                                        x: touch.clientX,
                                        y: touch.clientY
                                    }));
                                    // Duplicate if only one finger left
                                    while (endTouches.length < 2) {
                                        endTouches.push(endTouches[0]);
                                    }
                                } else {
                                    // Use start positions as fallback (no movement detected)
                                    endTouches = [...gestureStartTouches];
                                }
                            }
                            
                            if (endTouches.length >= 2) {
                                // Calculate average movement 
                                const avgStartX = (gestureStartTouches[0].x + gestureStartTouches[1].x) / 2;
                                const avgEndX = (endTouches[0].x + endTouches[1].x) / 2;
                                
                                const deltaX = avgEndX - avgStartX;
                                const absX = Math.abs(deltaX);
                                
                                // Very generous distance check
                                if (absX >= SWIPE_MIN_DISTANCE) {
                                    if (deltaX > 0) {
                                        changePage(-1);
                                    } else {
                                        changePage(1);
                                    }
                                }
                            }
                        }
                        
                        // Always reset gesture state when any touch ends during an active gesture
                        isGestureActive = false;
                        gestureStartTouches = [];
                        gestureCurrentTouches = [];
                    }
                }

                function startDrawing(e) {
                    // Only allow pen/stylus input for drawing
                    if (e.pointerType !== 'pen') {
                        return;
                    }

                    // Prevent drawing if 2-finger gesture is active
                    if (isGestureActive) {
                        return;
                    }

                    // Enhanced eraser detection for multiple stylus types
                    // MPP Stylus: button 2 (right click) or button 5 (eraser), buttons bitmask bit 2 = 4
                    const eraserButtonPressed = 
                        e.button === 2 ||           // Standard right-click/barrel button
                        e.button === 5 ||           // Standard eraser button
                        (e.buttons & 2) !== 0 ||    // Right button bitmask
                        (e.buttons & 4) !== 0 ||    // Middle/barrel button bitmask
                        (e.buttons & 32) !== 0;     // Eraser button bitmask (some devices)
                    
                    if (eraserButtonPressed && !isEraserButtonPressed) {
                        // Store original tool and switch to eraser
                        originalTool = currentTool;
                        isEraserButtonPressed = true;
                        if (currentTool !== 'eraser') {
                            setTool('eraser');
                        }
                    } else if (!eraserButtonPressed && isEraserButtonPressed) {
                        // Restore original tool when eraser button is released
                        isEraserButtonPressed = false;
                        setTool(originalTool);
                    }

                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    
                    // Calculate coordinates accounting for high-DPI scaling
                    const displayX = e.clientX - rect.left;
                    const displayY = e.clientY - rect.top;
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    
                    lastX = displayX * scaleX;
                    lastY = displayY * scaleY;
                    
                    // Reset stroke history for new stroke
                    points = [];
                    pressureHistory = [];
                    
                    // Reset speed tracking for new stroke
                    resetSpeedTracking();
                    
                    // Add initial point
                    const pressure = e.pressure || 0.5;
                    points.push({ x: lastX, y: lastY, pressure: pressure });
                    pressureHistory.push(pressure);
                    
                    // Show eraser indicator if using eraser tool
                    if (currentTool === 'eraser') {
                        showEraserIndicator(e.clientX, e.clientY, currentEraserSize);
                    }
                    
                    // Update pressure indicator
                    updatePressureIndicator(pressure);
                }

                function draw(e) {
                    // Only allow pen/stylus input for drawing
                    if (e.pointerType !== 'pen' || !isDrawing) {
                        return;
                    }

                    // Prevent drawing if 2-finger gesture is active
                    if (isGestureActive) {
                        return;
                    }
                    
                    const rect = canvas.getBoundingClientRect();
                    
                    // Calculate coordinates accounting for high-DPI scaling
                    const displayX = e.clientX - rect.left;
                    const displayY = e.clientY - rect.top;
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    
                    const currentX = displayX * scaleX;
                    const currentY = displayY * scaleY;

                    // Calculate dynamic eraser size based on speed using canvas coordinates (like the working version)
                    let dynamicEraserSize = currentEraserSize;
                    if (currentTool === 'eraser') {
                        // Check if there's actual movement before calculating dynamic size
                        const deltaX = currentX - lastX;
                        const deltaY = currentY - lastY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        // Only calculate dynamic sizing and update indicator if there's meaningful movement (more than 1 pixel)
                        if (distance > 1) {
                            dynamicEraserSize = calculateDynamicEraserSize(currentX, currentY, e.timeStamp, rect, canvas);
                            
                            // Calculate the screen size for the indicator to match actual eraser area
                            const originalDimensions = originalPageDimensions[currentPage];
                            let indicatorSize;
                            if (originalDimensions) {
                                const canvasToOriginalScale = canvas.width / originalDimensions.width;
                                const toolSizeInCanvas = dynamicEraserSize * canvasToOriginalScale;
                                indicatorSize = toolSizeInCanvas / Math.min(scaleX, scaleY);
                            } else {
                                indicatorSize = dynamicEraserSize;
                            }
                            
                            updateEraserIndicator(e.clientX, e.clientY, indicatorSize);
                        } else {
                            // Just update position without changing size for tiny movements
                            updateEraserIndicator(e.clientX, e.clientY);
                        }
                    }

                    // Get pressure value
                    const pressure = e.pressure || 0.5;
                    
                    // Add current point to history for smoothing
                    points.push({ x: currentX, y: currentY, pressure: pressure });
                    pressureHistory.push(pressure);
                    
                    // Keep history within limits
                    if (points.length > maxHistoryLength) {
                        points.shift();
                        pressureHistory.shift();
                    }

                    // Use CONSISTENT tool size scaling based on fixed resolution multiplier
                    // This ensures identical pen thickness across all pages regardless of PDF dimensions
                    const targetResolutionMultiplier = 2; // Same multiplier used for canvas creation
                    const toolSize = (currentTool === 'eraser' ? dynamicEraserSize : currentBrushSize) * targetResolutionMultiplier;
                    
                    if (currentTool === 'eraser') {
                        // Eraser: Use destination-out to remove pixels
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.lineWidth = toolSize;
                        
                        // Draw eraser stroke - color doesn't matter for destination-out, but set it anyway
                        ctx.strokeStyle = 'rgba(0,0,0,1)';
                        
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(currentX, currentY);
                        ctx.stroke();
                        
                        // Reset composite operation for next draw
                        ctx.globalCompositeOperation = 'source-over';
                    } else {
                        // Pen: Enhanced ink rendering with smoothing and pressure
                        ctx.globalCompositeOperation = 'source-over';
                        drawSmoothStroke(ctx, points, pressureHistory, toolSize);
                    }

                    // Update presentation display in real-time
                    updatePresentationDrawingRealtime(currentPage);

                    lastX = currentX;
                    lastY = currentY;
                    
                    // Update pressure indicator (but only for pen tool)
                    if (currentTool === 'pen') {
                        updatePressureIndicator(pressure);
                    }
                }
                
                // Advanced smooth stroke rendering function
                function drawSmoothStroke(ctx, points, pressureHistory, baseSize) {
                    if (points.length < 2) return;
                    
                    // Smooth pressure calculation
                    const avgPressure = pressureHistory.reduce((sum, p) => sum + p, 0) / pressureHistory.length;
                    const smoothPressure = pressureEnabled ? avgPressure : 0.7;
                    
                    // Calculate dynamic line width with pressure (ultra-high sensitivity)
                    const pressureMultiplier = pressureEnabled ? (0.05 + (smoothPressure * 4.5)) : 1.0;
                    const dynamicWidth = baseSize * pressureMultiplier;
                    
                    // Use solid, opaque color - no transparency
                    ctx.strokeStyle = currentColor;
                    ctx.lineWidth = dynamicWidth;
                    
                    // Smooth curve drawing using quadratic curves
                    if (points.length >= 3) {
                        const p0 = points[points.length - 3];
                        const p1 = points[points.length - 2];
                        const p2 = points[points.length - 1];
                        
                        // Calculate control point for smooth curve
                        const midPoint1 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
                        const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                        
                        ctx.beginPath();
                        ctx.moveTo(midPoint1.x, midPoint1.y);
                        ctx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
                        ctx.stroke();
                    } else if (points.length === 2) {
                        // Fallback for first stroke segment
                        const p1 = points[0];
                        const p2 = points[1];
                        
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }

                function stopDrawing(e) {
                    // Only allow pen/stylus input for drawing
                    if (e.pointerType !== 'pen') return;
                    
                    if (isDrawing) {
                        isDrawing = false;
                        
                        // Save drawing data at current canvas resolution for perfect quality preservation
                        // No scaling = no quality loss
                        drawingData[currentPage] = {
                            imageData: canvas.toDataURL('image/png', 1.0), // Maximum quality PNG
                            canvasWidth: canvas.width,
                            canvasHeight: canvas.height
                        };
                        
                        // Update presentation window
                        updatePresentationDrawing(currentPage);
                        
                        // Hide eraser indicator
                        hideEraserIndicator();
                        
                        // Reset pressure indicator
                        updatePressureIndicator(0);
                        
                        // Reset speed tracking
                        resetSpeedTracking();
                    }
                }

                function showEraserIndicator(clientX, clientY, size = null) {
                    const indicator = document.getElementById('eraserIndicator');
                    if (indicator) {
                        const eraserSize = size || currentDynamicEraserSize || currentEraserSize;
                        indicator.style.width = eraserSize + 'px';
                        indicator.style.height = eraserSize + 'px';
                        indicator.style.left = (clientX - eraserSize/2) + 'px';
                        indicator.style.top = (clientY - eraserSize/2) + 'px';
                        indicator.style.display = 'block';
                    }
                }

                function updateEraserIndicator(clientX, clientY, size = null) {
                    const indicator = document.getElementById('eraserIndicator');
                    if (indicator && indicator.style.display === 'block') {
                        const eraserSize = size || currentDynamicEraserSize || currentEraserSize;
                        indicator.style.width = eraserSize + 'px';
                        indicator.style.height = eraserSize + 'px';
                        indicator.style.left = (clientX - eraserSize/2) + 'px';
                        indicator.style.top = (clientY - eraserSize/2) + 'px';
                    }
                }

                function hideEraserIndicator() {
                    const indicator = document.getElementById('eraserIndicator');
                    if (indicator) {
                        indicator.style.display = 'none';
                    }
                }
            }

            function updatePressureIndicator(pressure) {
                const indicator = document.getElementById('pressureIndicator');
                if (indicator) {
                    const percentage = Math.round(pressure * 100);
                    indicator.textContent = `Pressure: ${percentage}%`;
                }
            }

            function changePage(direction) {
                const newPage = currentPage + direction;
                if (newPage >= 1 && newPage <= totalPages) {
                    currentPage = newPage;
                    
                    // Reset speed tracking when changing pages to ensure consistent eraser behavior
                    resetSpeedTracking();
                    
                    // Update page navigation UI
                    updatePageNavigation();
                    
                    // Start transitions in both windows simultaneously
                    renderPage(currentPage, true, direction); // Main window fade transition
                    
                    // Update presentation window if connected
                    if (presentationConnection) {
                        const message = {
                            type: 'PAGE_CHANGE',
                            pageNum: currentPage,
                            drawingData: drawingData
                        };
                        presentationConnection.send(JSON.stringify(message));
                    }
                }
            }

            // Update page navigation UI
            function updatePageNavigation() {
                // Update page numbers
                document.getElementById('currentPageNum').textContent = currentPage;
                document.getElementById('totalPagesNum').textContent = totalPages;
                
                // Update button states
                const prevBtn = document.getElementById('prevPageBtn');
                const nextBtn = document.getElementById('nextPageBtn');
                
                // Disable previous button if on first page
                if (currentPage <= 1) {
                    prevBtn.disabled = true;
                    prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    prevBtn.disabled = false;
                    prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                
                // Disable next button if on last page
                if (currentPage >= totalPages) {
                    nextBtn.disabled = true;
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    nextBtn.disabled = false;
                    nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                
                // Update thumbnail selection if modal is open
                updateThumbnailSelection();
            }

            // Page Thumbnail Modal Functions
            async function openPageThumbnailModal() {
                if (!pdfDoc) return;

                const modal = document.getElementById('pageThumbnailModal');
                const backdrop = document.getElementById('modalBackdrop');
                const container = document.getElementById('thumbnailContainer');

                // Show backdrop
                backdrop.classList.remove('hidden');

                // Always regenerate thumbnails for better quality (force refresh)
                await generatePageThumbnails();

                // Update current page selection
                updateThumbnailSelection();

                // Show modal with slide animation
                setTimeout(() => {
                    modal.classList.add('open');
                }, 10);

                // Scroll to current page
                scrollToCurrentThumbnail();
            }

            function closePageThumbnailModal() {
                const modal = document.getElementById('pageThumbnailModal');
                const backdrop = document.getElementById('modalBackdrop');

                // Hide modal with slide animation
                modal.classList.remove('open');

                // Hide backdrop after animation
                setTimeout(() => {
                    backdrop.classList.add('hidden');
                }, 300);
            }

            async function generatePageThumbnails() {
                const container = document.getElementById('thumbnailContainer');
                container.innerHTML = '<div class="text-center py-8"><div class="text-gray-500 dark:text-gray-400">Generating thumbnails...</div></div>';

                const thumbnails = [];

                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    try {
                        const page = await pdfDoc.getPage(pageNum);
                        // Ultra-high quality thumbnails - scale to fit width of ~400px for crisp display
                        const targetWidth = 400;
                        const viewport = page.getViewport({ scale: 1 });
                        const scale = targetWidth / viewport.width;
                        const scaledViewport = page.getViewport({ scale });

                        // Create thumbnail container
                        const thumbnailDiv = document.createElement('div');
                        thumbnailDiv.className = 'page-thumbnail bg-white dark:bg-gray-700 rounded-lg border-2 border-gray-200 dark:border-gray-600 overflow-hidden cursor-pointer';
                        thumbnailDiv.setAttribute('data-page', pageNum);
                        thumbnailDiv.onclick = () => goToPage(pageNum);

                        // Create canvas for PDF with higher resolution
                        const canvas = document.createElement('canvas');
                        canvas.width = scaledViewport.width;
                        canvas.height = scaledViewport.height;
                        canvas.className = 'w-full h-auto';

                        // Create canvas for drawings overlay with higher resolution
                        const drawingCanvas = document.createElement('canvas');
                        drawingCanvas.width = scaledViewport.width;
                        drawingCanvas.height = scaledViewport.height;
                        drawingCanvas.className = 'absolute top-0 left-0 w-full h-auto';

                        // Container for canvases
                        const canvasContainer = document.createElement('div');
                        canvasContainer.className = 'relative';
                        canvasContainer.appendChild(canvas);
                        canvasContainer.appendChild(drawingCanvas);

                        // Page number label
                        const pageLabel = document.createElement('div');
                        pageLabel.className = 'p-2 text-xs text-center text-gray-600 dark:text-gray-400 border-t border-gray-200 dark:border-gray-600';
                        pageLabel.textContent = `Page ${pageNum}`;

                        thumbnailDiv.appendChild(canvasContainer);
                        thumbnailDiv.appendChild(pageLabel);

                        // Render PDF page with higher quality
                        const renderContext = {
                            canvasContext: canvas.getContext('2d'),
                            viewport: scaledViewport
                        };
                        await page.render(renderContext).promise;

                        // Render drawings if they exist with proper scaling
                        if (drawingData[pageNum]) {
                            const ctx = drawingCanvas.getContext('2d');
                            const img = new Image();
                            img.onload = function() {
                                const scaleX = scaledViewport.width / drawingData[pageNum].canvasWidth;
                                const scaleY = scaledViewport.height / drawingData[pageNum].canvasHeight;
                                
                                ctx.save();
                                ctx.scale(scaleX, scaleY);
                                ctx.drawImage(img, 0, 0);
                                ctx.restore();
                            };
                            img.src = drawingData[pageNum].imageData;
                        }

                        thumbnails.push(thumbnailDiv);

                    } catch (error) {
                        console.error(`Error generating thumbnail for page ${pageNum}:`, error);
                    }
                }

                // Clear loading message and add all thumbnails
                container.innerHTML = '';
                thumbnails.forEach(thumb => container.appendChild(thumb));

                // Initialize icons for the thumbnails
                initializeLucideIcons();
            }

            function updateThumbnailSelection() {
                const thumbnails = document.querySelectorAll('.page-thumbnail');
                thumbnails.forEach(thumb => {
                    const pageNum = parseInt(thumb.getAttribute('data-page'));
                    if (pageNum === currentPage) {
                        thumb.classList.add('current');
                    } else {
                        thumb.classList.remove('current');
                    }
                });
            }

            function scrollToCurrentThumbnail() {
                const container = document.getElementById('thumbnailContainer');
                const currentThumbnail = container.querySelector(`[data-page="${currentPage}"]`);
                
                if (currentThumbnail) {
                    // Scroll to center the current thumbnail
                    const containerHeight = container.clientHeight;
                    const thumbnailTop = currentThumbnail.offsetTop;
                    const thumbnailHeight = currentThumbnail.offsetHeight;
                    
                    const scrollPosition = thumbnailTop - (containerHeight / 2) + (thumbnailHeight / 2);
                    container.scrollTo({
                        top: Math.max(0, scrollPosition),
                        behavior: 'smooth'
                    });
                }
            }

            function goToPage(pageNum) {
                if (pageNum >= 1 && pageNum <= totalPages && pageNum !== currentPage) {
                    const direction = pageNum > currentPage ? 1 : -1;
                    currentPage = pageNum;
                    
                    // Update page navigation UI
                    updatePageNavigation();
                    
                    // Start transitions in both windows
                    renderPage(currentPage, true, direction);
                    
                    // Update presentation window if connected
                    if (presentationConnection) {
                        const message = {
                            type: 'PAGE_CHANGE',
                            pageNum: currentPage,
                            drawingData: drawingData
                        };
                        presentationConnection.send(JSON.stringify(message));
                    }
                    
                    // Close the modal
                    closePageThumbnailModal();
                }
            }

            // Presentation Mode Functions (using Presentation API with fallbacks)
            window.openPresentationMode = function() {
                if (!pdfDoc || !pdfArrayBuffer) {
                    showCustomAlert('Please load a PDF first before opening presentation mode.');
                    return;
                }

                // Check if presentation is already active
                if (presentationConnection) {
                    showConfirmDialog('Close the presentation?', () => {
                        console.log('Closing presentation connection...');
                        try {
                            // Store reference before nullifying
                            const connectionToClose = presentationConnection;
                            presentationConnection = null;
                            
                            // Try different methods to close the connection/window
                            if (connectionToClose.close) {
                                connectionToClose.close();
                            } else if (connectionToClose.terminate) {
                                connectionToClose.terminate();
                            }
                            
                            // For popup window fallback, close the window directly
                            if (connectionToClose.popupWindow && !connectionToClose.popupWindow.closed) {
                                connectionToClose.popupWindow.close();
                            }
                            
                        } catch (error) {
                            console.log('Error closing connection:', error);
                        }
                        console.log('Presentation connection closed');
                    });
                    return;
                }

                console.log('Starting presentation mode...');

                // Method 1: Use Presentation API for casting to secondary monitor
                if ('PresentationRequest' in window) {
                    try {
                        const presentationRequest = new PresentationRequest(window.location.href + '#receiver');
                        
                        presentationRequest.start()
                            .then(connection => {
                                console.log('Presentation API connection established');
                                presentationConnection = connection;
                                
                                // Handle connection close
                                connection.addEventListener('close', () => {
                                    console.log('Presentation connection closed');
                                    presentationConnection = null;
                                });
                                
                                connection.addEventListener('terminate', () => {
                                    console.log('Presentation connection terminated');
                                    presentationConnection = null;
                                });
                                
                                // Send data immediately and with retries - simplified approach
                                const sendData = () => {
                                    try {
                                        const initData = {
                                            type: 'INIT_PDF',
                                            pdfArrayBuffer: Array.from(new Uint8Array(pdfArrayBuffer)),
                                            currentPage: currentPage,
                                            totalPages: totalPages,
                                            drawingData: drawingData
                                        };
                                        
                                        console.log('Sending PDF data to presentation...', {
                                            dataSize: initData.pdfArrayBuffer.length,
                                            currentPage: initData.currentPage,
                                            totalPages: initData.totalPages
                                        });
                                        
                                        connection.send(JSON.stringify(initData));
                                        console.log('Data sent successfully!');
                                    } catch (error) {
                                        console.error('Error sending data:', error);
                                    }
                                };
                                
                                // Send immediately
                                sendData();
                                
                                // Retry after delays
                                setTimeout(sendData, 500);
                                setTimeout(sendData, 1500);
                                setTimeout(sendData, 3000);
                                
                                // Keep trying every 2 seconds for the first 10 seconds
                                const retryInterval = setInterval(() => {
                                    console.log('Retrying data send...');
                                    sendData();
                                }, 2000);
                                
                                setTimeout(() => {
                                    clearInterval(retryInterval);
                                    console.log('Stopped retrying data send');
                                }, 10000);
                            })
                            .catch(error => {
                                console.error('Presentation API failed:', error);
                                // Fallback to popup window method
                                openPresentationFallback();
                            });
                            
                    } catch (error) {
                        console.error('Error creating PresentationRequest:', error);
                        openPresentationFallback();
                    }
                } else {
                    console.log('Presentation API not available, using fallback');
                    openPresentationFallback();
                }
            }

            // Helper function to send PDF data to receiver
            function sendPDFDataToReceiver(connection) {
                try {
                    const initData = {
                        type: 'INIT_PDF',
                        pdfArrayBuffer: Array.from(new Uint8Array(pdfArrayBuffer)),
                        currentPage: currentPage,
                        totalPages: totalPages,
                        drawingData: drawingData
                    };
                    
                    console.log('Attempting to send PDF data...', {
                        dataSize: initData.pdfArrayBuffer.length,
                        currentPage: initData.currentPage,
                        totalPages: initData.totalPages
                    });
                    
                    connection.send(JSON.stringify(initData));
                    console.log('PDF data sent successfully!');
                } catch (error) {
                    console.error('Error sending PDF data:', error);
                }
            }

            // Fallback method using popup window with postMessage
            function openPresentationFallback() {
                console.log('Using popup window fallback...');
                
                // Try to store data in sessionStorage for the popup to access
                try {
                    const fallbackData = {
                        type: 'INIT_PDF',
                        pdfArrayBuffer: Array.from(new Uint8Array(pdfArrayBuffer)),
                        currentPage: currentPage,
                        totalPages: totalPages,
                        drawingData: drawingData
                    };
                    sessionStorage.setItem('presentationData', JSON.stringify(fallbackData));
                } catch (e) {
                    console.log('SessionStorage not available');
                }
                
                // Open popup window
                const popupWindow = window.open(
                    window.location.href + '#receiver',
                    'presentation',
                    'width=1280,height=720,resizable=yes,scrollbars=no,status=no,menubar=no,toolbar=no'
                );
                
                if (popupWindow) {
                    // Create a fake connection object for consistency
                    presentationConnection = {
                        send: (data) => {
                            if (!popupWindow.closed) {
                                popupWindow.postMessage(data, '*');
                            }
                        },
                        close: () => {
                            if (!popupWindow.closed) {
                                popupWindow.close();
                            }
                            presentationConnection = null;
                        },
                        popupWindow: popupWindow // Store reference for proper closing
                    };
                    
                    // Handle popup close
                    const checkClosed = setInterval(() => {
                        if (popupWindow.closed) {
                            clearInterval(checkClosed);
                            presentationConnection = null;
                        }
                    }, 1000);
                    
                    // Send initial data after popup loads
                    setTimeout(() => {
                        if (!popupWindow.closed) {
                            const initData = {
                                type: 'INIT_PDF',
                                pdfArrayBuffer: Array.from(new Uint8Array(pdfArrayBuffer)),
                                currentPage: currentPage,
                                totalPages: totalPages,
                                drawingData: drawingData
                            };
                            
                            console.log('Sending init data to popup...');
                            popupWindow.postMessage(JSON.stringify(initData), '*');
                        }
                    }, 2000);
                    
                } else {
                    showCustomAlert('Unable to open presentation window. Please allow popups and try again.');
                }
            }

            // Throttling variables for real-time updates
            let lastRealtimeUpdate = 0;
            let realtimeUpdatePending = false;
            const REALTIME_THROTTLE_MS = 50; // Limit to 20 updates per second (much less network traffic)

            // Update presentation drawing in real-time with throttling
            function updatePresentationDrawingRealtime(pageNum) {
                // Send real-time drawing updates during ink strokes with throttling to reduce latency
                if (!presentationConnection) return;
                
                const now = performance.now();
                
                // If enough time has passed, send update immediately
                if (now - lastRealtimeUpdate >= REALTIME_THROTTLE_MS) {
                    sendRealtimeUpdate(pageNum);
                    lastRealtimeUpdate = now;
                } else if (!realtimeUpdatePending) {
                    // Schedule a delayed update if one isn't already pending
                    realtimeUpdatePending = true;
                    const remainingTime = REALTIME_THROTTLE_MS - (now - lastRealtimeUpdate);
                    
                    setTimeout(() => {
                        sendRealtimeUpdate(pageNum);
                        lastRealtimeUpdate = performance.now();
                        realtimeUpdatePending = false;
                    }, remainingTime);
                }
            }
            
            function sendRealtimeUpdate(pageNum) {
                if (!presentationConnection) return;
                
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    const currentDrawingData = {
                        imageData: canvas.toDataURL('image/png', 1.0),
                        canvasWidth: canvas.width,
                        canvasHeight: canvas.height
                    };
                    
                    const message = {
                        type: 'DRAWING_UPDATE',
                        pageNum: pageNum,
                        drawingData: currentDrawingData
                    };
                    
                    // Send real-time update
                    try {
                        presentationConnection.send(JSON.stringify(message));
                    } catch (error) {
                        // Ignore errors during real-time updates to avoid spam
                    }
                }
            }

            function updatePresentationDrawing(pageNum) {
                if (presentationConnection && drawingData[pageNum]) {
                    const message = {
                        type: 'DRAWING_UPDATE',
                        pageNum: pageNum,
                        drawingData: drawingData[pageNum]
                    };
                    presentationConnection.send(JSON.stringify(message));
                }
            }

            function closePDF() {
                // Show upload area and header, hide PDF viewer
                document.getElementById('uploadArea').style.display = 'block';
                document.querySelector('header').style.display = 'block';
                document.getElementById('pdfViewer').classList.add('hidden');
                
                // Reset state
                pdfDoc = null;
                currentPage = 1;
                totalPages = 0;
                drawingData = {};
                document.getElementById('downloadBtn').disabled = true;
                document.getElementById('pdfUpload').value = '';
            }

            window.setTool = function(tool) {
                currentTool = tool;
                
                // Update tool buttons
                document.querySelectorAll('#penTool, #eraserTool').forEach(btn => {
                    btn.classList.remove('tool-active');
                });
                
                if (tool === 'pen') {
                    document.getElementById('penTool').classList.add('tool-active');
                } else if (tool === 'eraser') {
                    document.getElementById('eraserTool').classList.add('tool-active');
                }

                // Update cursor
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
                }
                
                // Reset speed tracking when changing tools
                resetSpeedTracking();
            }

            window.setColor = function(color) {
                currentColor = color;
                
                // Update color indicator
                const colorIndicator = document.getElementById('colorIndicator');
                if (colorIndicator) {
                    colorIndicator.style.backgroundColor = color;
                }
                
                // Close modal after selection
                hideSettingsModal();
            }

            window.clearCanvas = function() {
                showConfirmDialog('Are you sure you want to clear all drawings on this page?', () => {
                    const canvas = document.querySelector('.drawing-canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        delete drawingData[currentPage];
                        
                        // Update presentation window
                        if (presentationConnection) {
                            const message = {
                                type: 'DRAWING_UPDATE',
                                pageNum: currentPage,
                                drawingData: null
                            };
                            presentationConnection.send(JSON.stringify(message));
                        }
                    }
                });
            }

            window.downloadPDF = async function() {
                if (!pdfDoc) return;

                try {
                    if (drawingData[currentPage]) {
                        const link = document.createElement('a');
                        link.download = `pdf-drawing-page-${currentPage}.png`;
                        link.href = drawingData[currentPage].imageData;
                        link.click();
                    } else {
                        showCustomAlert('No drawings found on current page to download.');
                    }
                    
                } catch (error) {
                    console.error('Error downloading:', error);
                    showCustomAlert('Error downloading the file.');
                }
            }

            // Fullscreen functionality for Android devices
            window.toggleFullscreen = function() {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    const element = document.documentElement;
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        // Safari
                        element.webkitRequestFullscreen();
                    } else if (element.msRequestFullscreen) {
                        // IE/Edge
                        element.msRequestFullscreen();
                    } else if (element.mozRequestFullScreen) {
                        // Firefox
                        element.mozRequestFullScreen();
                    }
                    
                    // Update icon to minimize
                    updateFullscreenIcon(true);
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    }
                    
                    // Update icon to maximize
                    updateFullscreenIcon(false);
                }
            }

            function updateFullscreenIcon(isFullscreen) {
                const icon = document.querySelector('#fullscreenBtn i');
                if (icon) {
                    if (isFullscreen) {
                        icon.setAttribute('data-lucide', 'minimize');
                    } else {
                        icon.setAttribute('data-lucide', 'maximize');
                    }
                    // Reinitialize icons to update the display
                    initializeLucideIcons();
                }
            }

            // Listen for fullscreen changes to update the icon
            document.addEventListener('fullscreenchange', () => {
                updateFullscreenIcon(!!document.fullscreenElement);
            });
            document.addEventListener('webkitfullscreenchange', () => {
                updateFullscreenIcon(!!document.webkitFullscreenElement);
            });
            document.addEventListener('msfullscreenchange', () => {
                updateFullscreenIcon(!!document.msFullscreenElement);
            });
            document.addEventListener('mozfullscreenchange', () => {
                updateFullscreenIcon(!!document.mozFullScreenElement);
            });

            // Custom dialog functions (replacing alert/confirm)
            window.showCustomAlert = function(message) {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
                modal.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
                        <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                        <div class="flex justify-end">
                            <button class="px-4 py-2 bg-primary text-white hover:bg-primary/90 rounded text-base" onclick="this.closest('.fixed').remove()">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            window.showConfirmDialog = function(message, onConfirm) {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full';
                
                const messageP = document.createElement('p');
                messageP.className = 'text-gray-700 dark:text-gray-300 mb-4';
                messageP.textContent = message;
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex justify-end space-x-3';
                
                const cancelButton = document.createElement('button');
                cancelButton.className = 'px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-base';
                cancelButton.textContent = 'Cancel';
                cancelButton.onclick = () => {
                    document.body.removeChild(modal);
                };
                
                const confirmButton = document.createElement('button');
                confirmButton.className = 'px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded text-base';
                confirmButton.textContent = 'Confirm';
                confirmButton.onclick = () => {
                    document.body.removeChild(modal);
                    if (typeof onConfirm === 'function') {
                        onConfirm();
                    }
                };
                
                buttonContainer.appendChild(cancelButton);
                buttonContainer.appendChild(confirmButton);
                modalContent.appendChild(messageP);
                modalContent.appendChild(buttonContainer);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
            }

            // Make functions globally available
            window.openPageThumbnailModal = openPageThumbnailModal;
            window.closePageThumbnailModal = closePageThumbnailModal;
            window.goToPage = goToPage;
            window.changePage = changePage;

            // Initialize Lucide icons
            function initializeLucideIcons() {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    // Retry after a short delay if Lucide isn't loaded yet
                    setTimeout(initializeLucideIcons, 100);
                }
            }

            // Initialize icons when DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                initializeLucideIcons();
                setupSettingsListeners();
                // Initialize brush and eraser size visual selections
                updateBrushSizeSelection();
                updateEraserSizeSelection();
            });

            // Handle window resize for responsive behavior with debouncing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                if (pdfDoc) {
                    // Clear existing timeout
                    clearTimeout(resizeTimeout);
                    
                    // Set new timeout to prevent excessive re-rendering
                    resizeTimeout = setTimeout(() => {
                        renderPage(currentPage);
                    }, 250); // Wait 250ms after resize stops
                }
            });
        }
    </script>


</body></html>
