<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotation App</title>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Monaco, Inconsolata, "Roboto Mono", monospace;
            background: #ffffff;
            color: #000000;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 3rem;
            background: white;
            border-bottom: 1px solid #d1d5db;
            z-index: 20;
            display: flex;
            align-items: center;
            padding: 0 1rem;
        }

        .header-title {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Hamburger menu */
        .hamburger {
            padding: 0.5rem;
            margin-right: 0.75rem;
            background: none;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }

        .hamburger:hover {
            background: #f3f4f6;
        }

        .hamburger.open {
            transform: rotate(90deg);
        }

        .hamburger-line {
            width: 1.25rem;
            height: 0.125rem;
            background: black;
            margin-bottom: 0.25rem;
        }

        .hamburger-line:last-child {
            margin-bottom: 0;
        }

        /* Side menu */
        .side-menu {
            position: fixed;
            left: 0;
            top: 3rem;
            bottom: 0;
            width: 16rem;
            background: white;
            border-right: 1px solid #d1d5db;
            z-index: 10;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform 0.2s ease;
            will-change: transform;
        }

        .side-menu.open {
            transform: translateX(0);
        }

        .menu-content {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-section h3 {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .section-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Tool buttons */
        .tool-btn {
            width: 100%;
            text-align: left;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.25rem;
            border: 1px solid #e5e7eb;
            background: white;
            cursor: pointer;
            transition: background-color 0.1s ease;
        }

        .tool-btn:hover {
            background-color: #f5f5f5;
        }

        .tool-btn.active {
            background-color: #e5e5e5;
        }

        /* Range input */
        .range-container {
            display: flex;
            flex-direction: column;
        }

        .range-input {
            width: 100%;
            height: 0.25rem;
            background: #d1d5db;
            border-radius: 0.5rem;
            appearance: none;
            cursor: pointer;
            outline: none;
        }

        .range-input::-webkit-slider-thumb {
            appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        .range-input::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }

        .range-value {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        /* Status indicators */
        .status-text {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .input-details {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-indicator {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background: #9ca3af;
        }

        .input-info {
            font-size: 0.75rem;
            color: #6b7280;
            font-family: ui-monospace, monospace;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .device-type {
            color: #6b7280;
        }

        .button-state {
            color: #9ca3af;
        }

        /* Canvas area */
        .canvas-container {
            position: fixed;
            top: 3rem;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            overflow: hidden;
        }

        #canvas {
            touch-action: none;
            cursor: crosshair;
            display: block;
        }

        /* Eraser indicator */
        .eraser-indicator {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            border: 1px solid #9ca3af;
            transform: translate(-50%, -50%);
        }

        .hidden {
            display: none;
        }

        /* Input filter status */
        .filter-status {
            font-size: 0.75rem;
            color: #6b7280;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Color variants for indicators */
        .bg-red-500 { background: #ef4444; }
        .bg-blue-500 { background: #3b82f6; }
        .bg-green-500 { background: #10b981; }
        .bg-orange-500 { background: #f59e0b; }
        .bg-gray-400 { background: #9ca3af; }

        /* Responsive design */
        @media (max-width: 768px) {
            .side-menu {
                width: 20rem;
            }
            
            .header {
                padding: 0 0.5rem;
            }
            
            .header-title {
                font-size: 0.75rem;
            }
            
            .input-info {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <button id="menuToggle" class="hamburger">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </button>
        <span class="header-title">Annotation Tool</span>
        <div class="header-right">
            <span id="statusText" class="status-text">Ready</span>
            <div id="inputDetails" class="input-details">
                <div id="inputIndicator" class="input-indicator"></div>
                <div id="inputInfo" class="input-info">
                    <div id="deviceType" class="device-type">-</div>
                    <div id="buttonState" class="button-state">-</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="sideMenu" class="side-menu">
        <div class="menu-content">
            <!-- Tools -->
            <div class="menu-section">
                <h3>Tools</h3>
                <div class="section-content">
                    <button id="penTool" class="tool-btn active">Pen</button>
                    <button id="eraserTool" class="tool-btn">Eraser</button>
                </div>
            </div>

            <!-- Stroke Width -->
            <div class="menu-section">
                <h3>Stroke Width</h3>
                <div class="range-container">
                    <input type="range" id="strokeWidth" min="1" max="20" value="2" class="range-input">
                    <div class="range-value">
                        <span id="strokeWidthValue">2</span>px
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="menu-section">
                <h3>Actions</h3>
                <div class="section-content">
                    <button id="clearBtn" class="tool-btn">Clear All</button>
                    <button id="undoBtn" class="tool-btn">Undo</button>
                </div>
            </div>

            <!-- Input Filter Status -->
            <div class="menu-section">
                <h3>Input Filter</h3>
                <div class="filter-status">
                    <div>✓ Pen Enabled</div>
                    <div>✓ Mouse Enabled</div>
                    <div>✗ Touch Disabled</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div id="canvasContainer" class="canvas-container">
        <canvas id="canvas"></canvas>
        <div id="eraserIndicator" class="eraser-indicator hidden"></div>
    </div>

    <script>
        class AnnotationApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.menuToggle = document.getElementById('menuToggle');
                this.sideMenu = document.getElementById('sideMenu');
                this.statusText = document.getElementById('statusText');
                this.inputIndicator = document.getElementById('inputIndicator');
                
                this.isDrawing = false;
                this.currentStroke = null;
                this.currentTool = 'pen';
                this.strokeWidth = 2;
                this.strokes = [];
                this.undoStack = [];
                
                // Web Worker setup
                this.worker = null;
                this.workerSupported = false;
                this.initWorker();
                
                this.init();
            }
            
            initWorker() {
                if (typeof Worker !== 'undefined') {
                    try {
                        // Use separate worker file instead of blob
                        this.worker = new Worker('./src/worker.js');
                        this.workerSupported = true;
                        
                        // Set up worker message handler
                        this.worker.onmessage = (e) => this.handleWorkerMessage(e);
                        
                        // Worker task queue
                        this.workerTasks = new Map();
                        
                        console.log('✅ Web Worker initialized successfully');
                        this.updateStatus('Worker ready');
                        
                    } catch (error) {
                        console.warn('Web Worker initialization failed:', error);
                        this.workerSupported = false;
                        this.updateStatus('Worker failed, using fallback');
                    }
                } else {
                    console.warn('Web Workers not supported');
                    this.workerSupported = false;
                    this.updateStatus('Workers not supported');
                }
            }
            
            init() {
                this.setupEventListeners();
                this.updateCanvasSize();
                this.setupCanvas();
                window.addEventListener('resize', () => this.updateCanvasSize());
            }
            
            setupCanvas() {
                this.setupCanvasQuality();
                
                // Clear canvas
                this.clearCanvas(false); // Don't save to undo stack
            }
            
            setupCanvasQuality() {
                // Essential anti-aliasing settings
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                // Maximum quality anti-aliasing
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Enhanced compositing for smoother strokes
                this.ctx.globalCompositeOperation = 'source-over';
                
                // Cross-browser anti-aliasing
                if (this.ctx.webkitImageSmoothingEnabled !== undefined) {
                    this.ctx.webkitImageSmoothingEnabled = true;
                }
                if (this.ctx.mozImageSmoothingEnabled !== undefined) {
                    this.ctx.mozImageSmoothingEnabled = true;
                }
                if (this.ctx.msImageSmoothingEnabled !== undefined) {
                    this.ctx.msImageSmoothingEnabled = true;
                }
                
                // Additional quality settings
                this.ctx.miterLimit = 10;
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
            }
            
            setupEventListeners() {
                // Menu toggle
                this.menuToggle.addEventListener('click', () => this.toggleMenu());
                
                // Tool selection
                document.getElementById('penTool').addEventListener('click', () => this.setTool('pen'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                
                // Stroke width
                const strokeWidthSlider = document.getElementById('strokeWidth');
                strokeWidthSlider.addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    document.getElementById('strokeWidthValue').textContent = this.strokeWidth;
                });
                
                // Actions
                document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas(true));
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                
                // Canvas drawing events
                this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('pointercancel', (e) => this.handlePointerUp(e));
                
                // Add hover detection for pen
                this.canvas.addEventListener('pointerenter', (e) => this.handlePointerHover(e));
                this.canvas.addEventListener('pointerleave', (e) => this.handlePointerLeave(e));
                
                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            updateCanvasSize() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Super-sampling for better quality (2x resolution)
                const superSample = 2;
                const totalScale = dpr * superSample;
                
                // Set canvas size with super-sampling
                this.canvas.width = rect.width * totalScale;
                this.canvas.height = rect.height * totalScale;
                
                // Scale back down with CSS
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Scale the drawing context
                this.ctx.scale(totalScale, totalScale);
                
                // Store scaling factors
                this.devicePixelRatio = dpr;
                this.superSample = superSample;
                this.totalScale = totalScale;
                
                // Re-apply high-quality settings after scaling
                this.setupCanvasQuality();
                
                // Redraw existing strokes after resize
                this.redrawCanvas();
            }
            
            toggleMenu() {
                const isOpen = this.sideMenu.classList.toggle('open');
                this.menuToggle.classList.toggle('open', isOpen);
            }
            
            setTool(tool) {
                this.currentTool = tool;
                
                // Update UI
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                // Update cursor
                this.canvas.style.cursor = tool === 'pen' ? 'crosshair' : 'grab';
                
                this.updateStatus(`${tool.charAt(0).toUpperCase() + tool.slice(1)} selected`);
            }
            
            handlePointerDown(e) {
                // Filter input: only allow pen and mouse, block touch
                if (e.pointerType === 'touch') {
                    e.preventDefault();
                    this.updateStatus('Touch input disabled');
                    this.updateInputIndicator('touch', e);
                    setTimeout(() => {
                        this.resetInputIndicator();
                    }, 1000);
                    return;
                }
                
                // Auto-detect eraser tip for pen input
                const effectiveTool = this.getEffectiveTool(e);
                
                // Update detailed input indicator
                this.updateInputIndicator(e.pointerType, e);
                
                e.preventDefault();
                this.canvas.setPointerCapture(e.pointerId);
                
                const point = this.getCanvasPoint(e);
                this.isDrawing = true;
                
                if (effectiveTool === 'pen') {
                    this.startStroke(point);
                } else if (effectiveTool === 'eraser') {
                    this.eraseAtPoint(point);
                }
            }
            
            handlePointerMove(e) {
                // Update input indicator even when not drawing (for hover detection)
                if (e.pointerType === 'pen' && !this.isDrawing) {
                    this.updateInputIndicator(e.pointerType, e);
                }
                
                // Update eraser indicator
                this.updateEraserIndicator(e);
                
                if (!this.isDrawing || e.pointerType === 'touch') return;
                
                e.preventDefault();
                const point = this.getCanvasPoint(e);
                
                // Use effective tool (auto-detects eraser tip)
                const effectiveTool = this.getEffectiveTool(e);
                
                if (effectiveTool === 'pen') {
                    this.addPointToStroke(point);
                } else if (effectiveTool === 'eraser') {
                    this.eraseAtPoint(point);
                }
            }
            
            handlePointerHover(e) {
                if (e.pointerType === 'pen') {
                    this.updateInputIndicator(e.pointerType, e);
                }
            }
            
            handlePointerLeave(e) {
                this.resetInputIndicator();
                // Hide eraser indicator when cursor leaves canvas
                document.getElementById('eraserIndicator').classList.add('hidden');
            }
            
            handlePointerUp(e) {
                if (e.pointerType === 'touch') return;
                
                e.preventDefault();
                this.canvas.releasePointerCapture(e.pointerId);
                
                if (this.isDrawing && this.currentTool === 'pen') {
                    this.finishStroke();
                }
                
                this.isDrawing = false;
                this.resetInputIndicator();
                this.updateStatus('Ready');
            }
            
            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                // Use natural coordinates without rounding for smoothest rendering
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            startStroke(point) {
                // Save state for undo
                this.saveState();
                
                this.currentStroke = {
                    points: [point],
                    width: this.strokeWidth,
                    color: '#000000'
                };
                
                // Draw initial point
                this.ctx.strokeStyle = this.currentStroke.color;
                this.ctx.lineWidth = this.currentStroke.width;
                this.ctx.beginPath();
                this.ctx.moveTo(point.x, point.y);
            }
            
            addPointToStroke(point) {
                if (!this.currentStroke) return;
                
                this.currentStroke.points.push(point);
                
                // Apply quadratic midpoint interpolation for smooth curves
                if (this.currentStroke.points.length >= 3) {
                    this.drawQuadraticCurve();
                } else if (this.currentStroke.points.length === 2) {
                    // For the second point, draw a line
                    this.ctx.lineTo(point.x, point.y);
                    this.ctx.stroke();
                }
            }
            
            drawQuadraticCurve() {
                const points = this.currentStroke.points;
                const len = points.length;
                const p0 = points[len - 3]; // Previous point
                const p1 = points[len - 2]; // Current control point
                const p2 = points[len - 1]; // New point
                
                // Calculate midpoints for smooth interpolation
                const mid1 = this.getMidpoint(p0, p1);
                const mid2 = this.getMidpoint(p1, p2);
                
                // Draw quadratic curve
                this.ctx.quadraticCurveTo(p1.x, p1.y, mid2.x, mid2.y);
                this.ctx.stroke();
            }
            
            getMidpoint(p1, p2) {
                return {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
            }
            
            finishStroke() {
                if (!this.currentStroke) return;
                
                // Complete the stroke to the last point
                if (this.currentStroke.points.length >= 2) {
                    const lastPoint = this.currentStroke.points[this.currentStroke.points.length - 1];
                    this.ctx.lineTo(lastPoint.x, lastPoint.y);
                    this.ctx.stroke();
                }
                
                // Store completed stroke
                this.strokes.push({ ...this.currentStroke });
                this.currentStroke = null;
            }
            
            async eraseAtPoint(point) {
                const eraseRadius = this.strokeWidth * 3;
                
                try {
                    // Try Web Worker first for better performance
                    const hitIndices = await this.runWorkerTask('COLLISION_DETECTION', {
                        point,
                        strokes: this.strokes,
                        radius: eraseRadius
                    });
                    
                    if (hitIndices.length > 0) {
                        // Remove strokes by index (in reverse order to maintain indices)
                        hitIndices.sort((a, b) => b - a).forEach(index => {
                            this.strokes.splice(index, 1);
                        });
                        this.redrawCanvas();
                    }
                    
                } catch (error) {
                    // Fallback to main thread if worker fails
                    console.warn('Worker collision detection failed, using fallback:', error);
                    this.eraseAtPointFallback(point);
                }
            }
            
            eraseAtPointFallback(point) {
                const eraseRadius = this.strokeWidth * 3;
                let needsRedraw = false;
                
                // Fallback collision detection on main thread
                this.strokes = this.strokes.filter(stroke => {
                    if (this.isPointNearStroke(point, stroke, eraseRadius)) {
                        needsRedraw = true;
                        return false; // Remove this stroke
                    }
                    return true; // Keep this stroke
                });
                
                if (needsRedraw) {
                    this.redrawCanvas();
                }
            }
            
            isPointNearStroke(point, stroke, radius) {
                // Simple collision detection - check if point is near any stroke point
                for (let i = 0; i < stroke.points.length; i++) {
                    const strokePoint = stroke.points[i];
                    const distance = Math.sqrt(
                        Math.pow(point.x - strokePoint.x, 2) + 
                        Math.pow(point.y - strokePoint.y, 2)
                    );
                    if (distance < radius) {
                        return true;
                    }
                }
                return false;
            }
            
            redrawCanvas() {
                // Clear canvas with correct scaling
                this.ctx.clearRect(0, 0, this.canvas.width / this.totalScale, this.canvas.height / this.totalScale);
                
                // Redraw all strokes
                this.strokes.forEach(stroke => {
                    this.drawStroke(stroke);
                });
            }
            
            drawStroke(stroke) {
                if (!stroke.points || stroke.points.length === 0) return;
                
                // Use fractional stroke width for better anti-aliasing
                const antiAliasedWidth = stroke.width + 0.5;
                
                this.ctx.strokeStyle = stroke.color;
                this.ctx.lineWidth = antiAliasedWidth;
                
                // Use Path2D for better rendering quality
                const path = new Path2D();
                
                if (stroke.points.length === 1) {
                    // Single point - draw as circle
                    const p = stroke.points[0];
                    path.arc(p.x, p.y, antiAliasedWidth / 2, 0, Math.PI * 2);
                    this.ctx.fillStyle = stroke.color;
                    this.ctx.fill(path);
                    return;
                }
                
                // Start the path
                path.moveTo(stroke.points[0].x, stroke.points[0].y);
                
                if (stroke.points.length === 2) {
                    // Simple line
                    path.lineTo(stroke.points[1].x, stroke.points[1].y);
                } else {
                    // Enhanced quadratic curves with better smoothing
                    for (let i = 1; i < stroke.points.length - 1; i++) {
                        const current = stroke.points[i];
                        const next = stroke.points[i + 1];
                        const mid = this.getMidpoint(current, next);
                        path.quadraticCurveTo(current.x, current.y, mid.x, mid.y);
                    }
                    // Final point
                    const lastPoint = stroke.points[stroke.points.length - 1];
                    path.lineTo(lastPoint.x, lastPoint.y);
                }
                
                // Apply subtle shadow for depth without blur
                this.ctx.shadowColor = 'rgba(0,0,0,0.1)';
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;
                this.ctx.shadowBlur = 0;
                
                this.ctx.stroke(path);
                
                // Reset shadow
                this.ctx.shadowColor = 'transparent';
            }
            
            clearCanvas(saveToUndo = true) {
                if (saveToUndo) {
                    this.saveState();
                }
                
                this.strokes = [];
                this.ctx.clearRect(0, 0, this.canvas.width / this.totalScale, this.canvas.height / this.totalScale);
                
                if (saveToUndo) {
                    this.updateStatus('Canvas cleared');
                }
            }
            
            saveState() {
                // Save current strokes state for undo
                const state = JSON.parse(JSON.stringify(this.strokes));
                this.undoStack.push(state);
                
                // Limit undo stack size for performance
                if (this.undoStack.length > 20) {
                    this.undoStack.shift();
                }
            }
            
            undo() {
                if (this.undoStack.length === 0) {
                    this.updateStatus('Nothing to undo');
                    return;
                }
                
                // Restore previous state
                this.strokes = this.undoStack.pop();
                this.redrawCanvas();
                this.updateStatus('Undone');
            }
            
            updateInputIndicator(pointerType, event) {
                const deviceType = document.getElementById('deviceType');
                const buttonState = document.getElementById('buttonState');
                const indicator = this.inputIndicator;
                
                if (pointerType === 'touch') {
                    indicator.className = 'input-indicator bg-red-500';
                    deviceType.textContent = 'TOUCH';
                    buttonState.textContent = 'BLOCKED';
                    this.updateStatus('Touch input disabled');
                    return;
                }
                
                if (pointerType === 'pen') {
                    indicator.className = 'input-indicator bg-blue-500';
                    deviceType.textContent = 'PEN';
                    
                    const buttons = this.getPenButtonState(event);
                    const pressure = Math.round((event.pressure || 0) * 100);
                    const tilt = event.tiltX !== undefined ? `T:${Math.round(event.tiltX)}°,${Math.round(event.tiltY)}°` : '';
                    
                    buttonState.textContent = `${buttons} P:${pressure}% ${tilt}`.trim();
                    this.updateStatus(`Pen: ${buttons} Pressure: ${pressure}%`);
                    
                } else if (pointerType === 'mouse') {
                    indicator.className = 'input-indicator bg-green-500';
                    deviceType.textContent = 'MOUSE';
                    
                    const buttons = this.getMouseButtonState(event);
                    buttonState.textContent = buttons;
                    this.updateStatus(`Mouse: ${buttons}`);
                } else {
                    indicator.className = 'input-indicator bg-orange-500';
                    deviceType.textContent = pointerType.toUpperCase();
                    buttonState.textContent = 'Unknown';
                    this.updateStatus(`${pointerType} input detected`);
                }
            }
            
            getPenButtonState(event) {
                const buttons = event.buttons || 0;
                const pressure = event.pressure || 0;
                const parts = [];
                
                if (buttons & 32 || buttons & 4 || (buttons === 0 && pressure > 0 && event.pointerType === 'pen' && this.isEraserEnd(event))) {
                    parts.push('ERASER-TIP');
                } else if (buttons & 1) {
                    parts.push('TIP');
                }
                
                if (buttons & 2) parts.push('BARREL');
                if ((buttons & 4) && !(buttons & 32)) parts.push('AUX');
                if (buttons & 8) parts.push('BTN4');
                if (buttons & 16) parts.push('BTN5');
                
                if (event.tangentialPressure !== undefined && Math.abs(event.tangentialPressure) > 0.01) {
                    parts.push(`ROT:${Math.round(event.tangentialPressure * 360)}°`);
                }
                
                if (parts.length === 0) {
                    return pressure > 0 ? 'CONTACT' : 'HOVER';
                }
                
                return parts.join('+');
            }
            
            isEraserEnd(event) {
                if (event.twist !== undefined && Math.abs(event.twist) > 90) {
                    return true;
                }
                
                if (event.tiltX !== undefined && event.tiltY !== undefined) {
                    const tiltMagnitude = Math.sqrt(event.tiltX * event.tiltX + event.tiltY * event.tiltY);
                    if (tiltMagnitude > 60) {
                        return true;
                    }
                }
                
                return false;
            }
            
            getMouseButtonState(event) {
                const buttons = event.buttons || 0;
                const parts = [];
                
                if (buttons & 1) parts.push('L');
                if (buttons & 2) parts.push('R');
                if (buttons & 4) parts.push('M');
                if (buttons & 8) parts.push('X1');
                if (buttons & 16) parts.push('X2');
                
                return parts.length > 0 ? parts.join('+') : 'HOVER';
            }
            
            resetInputIndicator() {
                this.inputIndicator.className = 'input-indicator bg-gray-400';
                document.getElementById('deviceType').textContent = '-';
                document.getElementById('buttonState').textContent = '-';
            }
            
            getEffectiveTool(event) {
                // Check if pen eraser tip is being used
                if (event.pointerType === 'pen') {
                    const buttons = event.buttons || 0;
                    const pressure = event.pressure || 0;
                    
                    // Detect eraser tip usage
                    if (buttons & 32 || buttons & 4 || (buttons === 0 && pressure > 0 && this.isEraserEnd(event))) {
                        return 'eraser';
                    }
                }
                
                // Default to current tool selection
                return this.currentTool;
            }
            
            updateEraserIndicator(e) {
                const indicator = document.getElementById('eraserIndicator');
                const effectiveTool = this.getEffectiveTool(e);
                
                if (effectiveTool === 'eraser' && e.pointerType !== 'touch') {
                    const radius = this.strokeWidth * 3;
                    indicator.style.left = e.clientX + 'px';
                    indicator.style.top = e.clientY + 'px';
                    indicator.style.width = radius * 2 + 'px';
                    indicator.style.height = radius * 2 + 'px';
                    indicator.classList.remove('hidden');
                } else {
                    indicator.classList.add('hidden');
                }
            }
            
            handleWorkerMessage(e) {
                const { type, taskId, hits, strokes, serialized } = e.data;
                const taskResolver = this.workerTasks.get(taskId);
                
                if (!taskResolver) return;
                
                switch(type) {
                    case 'COLLISION_RESULT':
                        taskResolver.resolve(hits);
                        break;
                    case 'OPTIMIZE_RESULT':
                        taskResolver.resolve(strokes);
                        break;
                    case 'SAVE_RESULT':
                        taskResolver.resolve(serialized);
                        break;
                }
                
                this.workerTasks.delete(taskId);
            }
            
            // Async wrapper for worker tasks
            runWorkerTask(type, data) {
                return new Promise((resolve, reject) => {
                    if (!this.workerSupported) {
                        // Fallback to main thread
                        reject(new Error('Worker not supported'));
                        return;
                    }
                    
                    const taskId = Date.now() + Math.random();
                    this.workerTasks.set(taskId, { resolve, reject });
                    
                    this.worker.postMessage({
                        type,
                        taskId,
                        data
                    });
                    
                    // Timeout after 5 seconds
                    setTimeout(() => {
                        if (this.workerTasks.has(taskId)) {
                            this.workerTasks.delete(taskId);
                            reject(new Error('Worker task timeout'));
                        }
                    }, 5000);
                });
            }
            
            updateStatus(message) {
                this.statusText.textContent = message;
            }
        }
        
        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new AnnotationApp();
        });
    </script>
</body>
</html>
