import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Upload, Eraser, Edit3, Download, ZoomIn, ZoomOut } from 'lucide-react';

function PDFAnnotationApp() {
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isErasing, setIsErasing] = useState(false);
  const [zoom, setZoom] = useState(1);
  const [annotations, setAnnotations] = useState({});
  const [lastPoint, setLastPoint] = useState(null);

  // Load PDF.js
  useEffect(() => {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
    script.onload = () => {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    };
    document.head.appendChild(script);
    return () => document.head.removeChild(script);
  }, []);

  const loadPDF = async (file) => {
    if (!window.pdfjsLib) return;
    
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await window.pdfjsLib.getDocument(arrayBuffer).promise;
    setPdfDoc(pdf);
    setTotalPages(pdf.numPages);
    setCurrentPage(1);
    renderPage(pdf, 1);
  };

  const renderPage = async (pdf, pageNum) => {
    const page = await pdf.getPage(pageNum);
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    const viewport = page.getViewport({ scale: zoom });
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    
    // Clear canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Render PDF page
    await page.render({
      canvasContext: ctx,
      viewport: viewport
    }).promise;
    
    // Restore annotations for this page
    if (annotations[pageNum]) {
      annotations[pageNum].forEach(stroke => {
        drawStroke(ctx, stroke);
      });
    }
  };

  const drawStroke = (ctx, stroke) => {
    if (stroke.type === 'erase') {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = stroke.width;
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = 'black';
      ctx.lineWidth = stroke.width;
    }
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    
    if (stroke.points.length > 1) {
      ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
      for (let i = 1; i < stroke.points.length; i++) {
        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
      }
      ctx.stroke();
    }
  };

  const getPointerPosition = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (canvas.width / rect.width),
      y: (e.clientY - rect.top) * (canvas.height / rect.height)
    };
  };

  const handlePointerDown = (e) => {
    // Only allow stylus/pen input, block finger touch
    if (e.pointerType === 'touch') {
      e.preventDefault();
      return;
    }
    
    if (e.pointerType !== 'pen') return;
    
    const canvas = canvasRef.current;
    canvas.setPointerCapture(e.pointerId);
    
    setIsDrawing(true);
    const point = getPointerPosition(e);
    setLastPoint(point);
    
    // Start new stroke
    const newStroke = {
      type: isErasing ? 'erase' : 'draw',
      points: [point],
      width: isErasing ? 20 : Math.max(1, e.pressure * 5) // Pressure sensitivity
    };
    
    setAnnotations(prev => ({
      ...prev,
      [currentPage]: [...(prev[currentPage] || []), newStroke]
    }));
  };

  const handlePointerMove = (e) => {
    if (!isDrawing || e.pointerType === 'touch') return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const point = getPointerPosition(e);
    
    // Configure drawing context
    if (isErasing) {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = 20;
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = 'black';
      ctx.lineWidth = Math.max(1, e.pressure * 5); // Pressure sensitivity
    }
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Draw line segment
    if (lastPoint) {
      ctx.beginPath();
      ctx.moveTo(lastPoint.x, lastPoint.y);
      ctx.lineTo(point.x, point.y);
      ctx.stroke();
    }
    
    setLastPoint(point);
    
    // Update current stroke
    setAnnotations(prev => {
      const pageAnnotations = [...(prev[currentPage] || [])];
      if (pageAnnotations.length > 0) {
        const currentStroke = { ...pageAnnotations[pageAnnotations.length - 1] };
        currentStroke.points.push(point);
        if (!isErasing) {
          currentStroke.width = Math.max(1, e.pressure * 5);
        }
        pageAnnotations[pageAnnotations.length - 1] = currentStroke;
      }
      return { ...prev, [currentPage]: pageAnnotations };
    });
  };

  const handlePointerUp = (e) => {
    if (e.pointerType === 'touch') return;
    
    setIsDrawing(false);
    setLastPoint(null);
    const canvas = canvasRef.current;
    canvas.releasePointerCapture(e.pointerId);
  };

  const changePage = (direction) => {
    if (!pdfDoc) return;
    
    const newPage = currentPage + direction;
    if (newPage >= 1 && newPage <= totalPages) {
      setCurrentPage(newPage);
      renderPage(pdfDoc, newPage);
    }
  };

  const handleZoom = (delta) => {
    const newZoom = Math.max(0.5, Math.min(3, zoom + delta));
    setZoom(newZoom);
    if (pdfDoc) {
      renderPage(pdfDoc, currentPage);
    }
  };

  const clearPage = () => {
    setAnnotations(prev => ({
      ...prev,
      [currentPage]: []
    }));
    if (pdfDoc) {
      renderPage(pdfDoc, currentPage);
    }
  };

  useEffect(() => {
    if (pdfDoc) {
      renderPage(pdfDoc, currentPage);
    }
  }, [zoom, currentPage]);

  return (
    <div className="min-h-screen bg-white flex flex-col">
      {/* Header */}
      <header className="border-b border-gray-200 p-4">
        <div className="flex items-center justify-between max-w-6xl mx-auto">
          <h1 className="text-xl font-semibold">PDF Annotator</h1>
          
          <div className="flex items-center gap-4">
            {/* File Upload */}
            <button
              onClick={() => fileInputRef.current?.click()}
              className="flex items-center gap-2 px-4 py-2 border border-gray-300 hover:bg-gray-50 transition-colors"
            >
              <Upload size={16} />
              Load PDF
            </button>
            
            {/* Tools */}
            {pdfDoc && (
              <>
                <button
                  onClick={() => setIsErasing(false)}
                  className={`p-2 border transition-colors ${
                    !isErasing ? 'bg-black text-white' : 'border-gray-300 hover:bg-gray-50'
                  }`}
                >
                  <Edit3 size={16} />
                </button>
                
                <button
                  onClick={() => setIsErasing(true)}
                  className={`p-2 border transition-colors ${
                    isErasing ? 'bg-black text-white' : 'border-gray-300 hover:bg-gray-50'
                  }`}
                >
                  <Eraser size={16} />
                </button>
                
                <button
                  onClick={() => handleZoom(-0.2)}
                  className="p-2 border border-gray-300 hover:bg-gray-50 transition-colors"
                >
                  <ZoomOut size={16} />
                </button>
                
                <button
                  onClick={() => handleZoom(0.2)}
                  className="p-2 border border-gray-300 hover:bg-gray-50 transition-colors"
                >
                  <ZoomIn size={16} />
                </button>
                
                <button
                  onClick={clearPage}
                  className="px-3 py-2 border border-gray-300 hover:bg-gray-50 transition-colors text-sm"
                >
                  Clear
                </button>
              </>
            )}
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="flex-1 flex flex-col items-center p-4">
        <input
          ref={fileInputRef}
          type="file"
          accept=".pdf"
          onChange={(e) => e.target.files[0] && loadPDF(e.target.files[0])}
          className="hidden"
        />
        
        {!pdfDoc ? (
          <div className="flex-1 flex items-center justify-center">
            <div className="text-center">
              <Upload size={48} className="mx-auto mb-4 text-gray-400" />
              <p className="text-gray-600 mb-4">Load a PDF to start annotating</p>
              <button
                onClick={() => fileInputRef.current?.click()}
                className="px-6 py-3 bg-black text-white hover:bg-gray-800 transition-colors"
              >
                Choose PDF File
              </button>
            </div>
          </div>
        ) : (
          <div className="flex flex-col items-center gap-4 w-full max-w-4xl">
            {/* Canvas */}
            <div className="border border-gray-300 shadow-lg overflow-auto max-w-full max-h-screen">
              <canvas
                ref={canvasRef}
                onPointerDown={handlePointerDown}
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
                className="display-block touch-none select-none"
                style={{ 
                  cursor: isErasing ? 'crosshair' : 'crosshair',
                  touchAction: 'none'
                }}
              />
            </div>
            
            {/* Page Controls */}
            <div className="flex items-center gap-4">
              <button
                onClick={() => changePage(-1)}
                disabled={currentPage <= 1}
                className="px-4 py-2 border border-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                Previous
              </button>
              
              <span className="text-sm font-medium">
                Page {currentPage} of {totalPages}
              </span>
              
              <button
                onClick={() => changePage(1)}
                disabled={currentPage >= totalPages}
                className="px-4 py-2 border border-gray-300 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                Next
              </button>
            </div>
          </div>
        )}
      </main>

      {/* PWA Manifest */}
      <div style={{ display: 'none' }}>
        {JSON.stringify({
          name: "PDF Annotator",
          short_name: "PDFAnnotator",
          start_url: "/",
          display: "standalone",
          background_color: "#ffffff",
          theme_color: "#000000",
          icons: [
            {
              src: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z'/%3E%3Cpolyline points='14,2 14,8 20,8'/%3E%3C/svg%3E",
              sizes: "192x192",
              type: "image/svg+xml"
            }
          ]
        })}
      </div>
    </div>
  );
}

export default PDFAnnotationApp;
