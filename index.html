<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Presentation Drawing App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .controller {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }

        .presentation-display {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            touch-action: none;
            overflow: hidden;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: #5D5CDE;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #4A49C7;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .hidden {
            display: none !important;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status.connected {
            background: #e8f5e8;
            color: #2d5016;
            border: 1px solid #a3d977;
        }

        .status.disconnected {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .drawing-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .color-picker {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: #333;
            transform: scale(1.2);
        }

        .stroke-width {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="range"] {
            width: 100px;
        }

        .instructions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions ul {
            list-style-position: inside;
            color: #666;
            line-height: 1.5;
        }

        .canvas-container {
            width: 100%;
            aspect-ratio: 16 / 9;
            margin: 20px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            overflow: hidden;
        }

        .main-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .render-mode {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .mode-toggle {
            display: flex;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            background: white;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .mode-btn:hover {
            background: #f5f5f5;
            transform: none;
        }

        .mode-btn.active {
            background: #5D5CDE;
            color: white;
        }

        .mode-btn.active:hover {
            background: #4A49C7;
        }

        .smoothing-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .smoothing-toggle {
            display: flex;
        }

        .toggle-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            min-width: 40px;
        }

        .toggle-btn:hover {
            background: #f5f5f5;
            transform: none;
        }

        .toggle-btn.active {
            background: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        .toggle-btn.active:hover {
            background: #27ae60;
        }

        .smoothing-amount {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .smoothing-amount input[type="range"] {
            width: 80px;
        }

        .smoothing-amount input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <!-- Controller Interface -->
    <div id="controller" class="controller">
        <h1>Presentation Drawing App</h1>
        
        <div id="status" class="status disconnected">
            Ready to present. Click "Start Presentation" to mirror drawing on external display.
        </div>

        <div class="controls">
            <button id="presentBtn" class="hidden">Start Presentation</button>
            <button id="reconnectBtn" class="hidden">Reconnect</button>
            <button id="disconnectBtn" class="hidden">Disconnect</button>
            <button id="stopBtn" class="hidden">Stop Presentation</button>
            <button id="clearBtn">Clear Canvas</button>
        </div>

        <div class="controls">
            <div class="color-picker">
                <label>Color:</label>
                <div class="color-option active" data-color="#000000" style="background: #000000;"></div>
                <div class="color-option" data-color="#e74c3c" style="background: #e74c3c;"></div>
                <div class="color-option" data-color="#3498db" style="background: #3498db;"></div>
                <div class="color-option" data-color="#2ecc71" style="background: #2ecc71;"></div>
                <div class="color-option" data-color="#f39c12" style="background: #f39c12;"></div>
                <div class="color-option" data-color="#9b59b6" style="background: #9b59b6;"></div>
            </div>
            
            <div class="stroke-width">
                <label>Stroke Width:</label>
                <input type="range" id="strokeWidth" min="1" max="20" value="3">
                <span id="strokeWidthValue">3</span>px
            </div>

            <div class="render-mode">
                <label>Render Mode:</label>
                <div class="mode-toggle">
                    <button id="svgMode" class="mode-btn active">SVG (Precision)</button>
                    <button id="canvasMode" class="mode-btn">Canvas (Performance)</button>
                </div>
            </div>

            <div class="smoothing-controls">
                <label>Smoothing:</label>
                <div class="smoothing-toggle">
                    <button id="smoothingToggle" class="toggle-btn">OFF</button>
                </div>
                <div class="smoothing-amount">
                    <label>Amount:</label>
                    <input type="range" id="smoothingSlider" min="0" max="100" value="50" disabled>
                    <span id="smoothingValue">50</span>%
                </div>
            </div>
        </div>

        <!-- Main Drawing Canvas -->
        <div class="canvas-container">
            <svg id="mainCanvas" class="main-canvas" xmlns="http://www.w3.org/2000/svg">
            </svg>
            <canvas id="mainCanvasHTML" class="main-canvas hidden"></canvas>
        </div>

        <div class="instructions">
            <h3>Instructions:</h3>
            <ul>
                <li>Draw on the canvas above with Microsoft Pen 1776 or mouse</li>
                <li>Touch/finger input is disabled for precision</li>
                <li>Your drawing will be mirrored on the presentation display</li>
                <li>Click "Start Presentation" to show on secondary monitor</li>
                <li>Use the controls above to change colors and stroke width</li>
            </ul>
        </div>
    </div>

    <!-- Presentation Display (hidden initially) -->
    <div id="presentation" class="presentation-display hidden">
        <svg id="drawingCanvas" class="drawing-canvas" xmlns="http://www.w3.org/2000/svg">
        </svg>
    </div>

    <script>
        class PresentationDrawingApp {
            constructor() {
                this.isPresentation = window.location.hash === '#presentation';
                this.connection = null;
                this.currentStroke = null;
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.currentStrokeWidth = 3;
                this.renderMode = 'svg'; // 'svg' or 'canvas'
                this.mainCanvasContext = null;
                this.presentationCanvasContext = null;
                this.canvasStrokes = []; // Store canvas strokes for synchronization
                
                // Performance optimization properties
                this.animationFrame = null;
                this.pendingUpdates = [];
                this.messageBatch = [];
                this.lastBatchTime = 0;
                this.batchInterval = 16; // ~60fps
                this.currentStrokePoints = [];
                this.lastSentPoint = null;
                this.simplificationTolerance = 2; // pixels
                this.isThrottling = false;
                
                // Smoothing properties
                this.smoothingEnabled = false;
                this.smoothingAmount = 50; // 0-100
                this.smoothingPoints = []; // Buffer for smoothing calculation
                
                // Eraser properties
                this.isEraserMode = false;
                this.eraserSize = 20; // Default eraser size
                
                if (this.isPresentation) {
                    this.initPresentation();
                } else {
                    this.initController();
                }
            }

            initController() {
                this.setupControllerUI();
                this.setupPresentationAPI();
                this.initCanvasContexts();
            }

            initPresentation() {
                document.getElementById('controller').classList.add('hidden');
                document.getElementById('presentation').classList.remove('hidden');
                this.setupDrawingCanvas();
                this.setupPresentationReceiver();
                this.initPresentationCanvas();
            }

            initCanvasContexts() {
                const canvas = document.getElementById('mainCanvasHTML');
                const rect = document.querySelector('.canvas-container').getBoundingClientRect();
                
                // Get device pixel ratio for high DPI displays
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas size accounting for device pixel ratio
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                // Scale canvas back down using CSS
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                
                // Hardware acceleration optimization
                this.mainCanvasContext = canvas.getContext('2d', { 
                    alpha: true, 
                    willReadFrequently: false,
                    desynchronized: true 
                });
                
                // Scale the drawing context to match device pixel ratio
                this.mainCanvasContext.scale(dpr, dpr);
                
                this.setupCanvasStyle(this.mainCanvasContext);
                // Set white background
                this.clearCanvasBackground(this.mainCanvasContext, rect.width, rect.height);
            }

            initPresentationCanvas() {
                // Create canvas for presentation mode
                const presentationContainer = document.getElementById('presentation');
                const presentationCanvas = document.createElement('canvas');
                presentationCanvas.id = 'presentationCanvasHTML';
                presentationCanvas.className = 'drawing-canvas hidden';
                
                // Get device pixel ratio for high DPI displays
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas size accounting for device pixel ratio
                presentationCanvas.width = window.innerWidth * dpr;
                presentationCanvas.height = window.innerHeight * dpr;
                
                // Scale canvas back down using CSS
                presentationCanvas.style.width = window.innerWidth + 'px';
                presentationCanvas.style.height = window.innerHeight + 'px';
                
                presentationContainer.appendChild(presentationCanvas);
                
                this.presentationCanvasContext = presentationCanvas.getContext('2d');
                
                // Scale the drawing context to match device pixel ratio
                this.presentationCanvasContext.scale(dpr, dpr);
                
                this.setupCanvasStyle(this.presentationCanvasContext);
                // Set white background for presentation canvas
                this.clearCanvasBackground(this.presentationCanvasContext, window.innerWidth, window.innerHeight);
            }

            clearCanvasBackground(ctx, width, height) {
                // Fill with white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
            }

            setupCanvasStyle(ctx) {
                // Enable high-quality anti-aliasing
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Line style settings for smooth appearance
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = this.currentStrokeWidth;
                
                // Clear any shadows that cause gray background
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Ensure full opacity for proper anti-aliasing
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
                
                // Additional anti-aliasing hint
                ctx.textRenderingOptimization = 'optimizeQuality';
            }

            setupControllerUI() {
                const presentBtn = document.getElementById('presentBtn');
                const reconnectBtn = document.getElementById('reconnectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const stopBtn = document.getElementById('stopBtn');
                const clearBtn = document.getElementById('clearBtn');
                const strokeWidth = document.getElementById('strokeWidth');
                const strokeWidthValue = document.getElementById('strokeWidthValue');
                const svgModeBtn = document.getElementById('svgMode');
                const canvasModeBtn = document.getElementById('canvasMode');
                
                // Color picker
                document.querySelectorAll('.color-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        document.querySelector('.color-option.active').classList.remove('active');
                        e.target.classList.add('active');
                        this.currentColor = e.target.dataset.color;
                        this.updateCanvasStyle();
                        this.sendMessage({
                            type: 'colorChange',
                            color: this.currentColor
                        });
                    });
                });

                // Stroke width
                strokeWidth.addEventListener('input', (e) => {
                    this.currentStrokeWidth = e.target.value;
                    strokeWidthValue.textContent = e.target.value;
                    this.updateCanvasStyle();
                    this.sendMessage({
                        type: 'strokeWidthChange',
                        width: this.currentStrokeWidth
                    });
                });

                // Mode toggle
                svgModeBtn.onclick = () => this.switchMode('svg');
                canvasModeBtn.onclick = () => this.switchMode('canvas');

                // Smoothing controls
                const smoothingToggle = document.getElementById('smoothingToggle');
                const smoothingSlider = document.getElementById('smoothingSlider');
                const smoothingValue = document.getElementById('smoothingValue');

                smoothingToggle.onclick = () => this.toggleSmoothing();
                smoothingSlider.addEventListener('input', (e) => {
                    this.smoothingAmount = parseInt(e.target.value);
                    smoothingValue.textContent = e.target.value;
                    this.sendMessage({
                        type: 'smoothingChange',
                        enabled: this.smoothingEnabled,
                        amount: this.smoothingAmount
                    });
                });

                // Buttons
                presentBtn.onclick = () => this.startPresentation();
                reconnectBtn.onclick = () => this.reconnectPresentation();
                disconnectBtn.onclick = () => this.disconnect();
                stopBtn.onclick = () => this.stop();
                clearBtn.onclick = () => this.clearCanvas();

                // Setup main drawing canvas
                this.setupMainDrawingCanvas();
            }

            updateCanvasStyle() {
                if (this.mainCanvasContext) {
                    this.mainCanvasContext.strokeStyle = this.currentColor;
                    this.mainCanvasContext.lineWidth = this.currentStrokeWidth;
                }
            }

            switchMode(mode) {
                if (this.renderMode === mode) return;
                
                this.renderMode = mode;
                
                // Update UI
                document.getElementById('svgMode').classList.toggle('active', mode === 'svg');
                document.getElementById('canvasMode').classList.toggle('active', mode === 'canvas');
                
                // Show/hide appropriate canvases
                document.getElementById('mainCanvas').classList.toggle('hidden', mode === 'canvas');
                document.getElementById('mainCanvasHTML').classList.toggle('hidden', mode === 'svg');
                
                // Clear current content
                this.clearCanvas();
                
                // Send mode change to presentation
                this.sendMessage({
                    type: 'modeChange',
                    mode: mode
                });
            }

            setupPresentationAPI() {
                const presentationUrl = window.location.href + '#presentation';
                this.request = new PresentationRequest([presentationUrl]);
                
                // Check availability
                this.request.getAvailability()
                    .then(availability => {
                        this.handleAvailabilityChange(availability.value);
                        availability.onchange = () => {
                            this.handleAvailabilityChange(availability.value);
                        };
                    })
                    .catch(() => {
                        // Assume available for simplicity
                        this.handleAvailabilityChange(true);
                    });

                // Set default request
                if (navigator.presentation) {
                    navigator.presentation.defaultRequest = this.request;
                    navigator.presentation.defaultRequest.onconnectionavailable = (evt) => {
                        this.setConnection(evt.connection);
                    };
                }

                // Auto-reconnect
                this.reconnectPresentation();
            }

            handleAvailabilityChange(available) {
                const presentBtn = document.getElementById('presentBtn');
                if (available) {
                    presentBtn.classList.remove('hidden');
                } else {
                    presentBtn.classList.add('hidden');
                }
            }

            startPresentation() {
                this.request.start()
                    .then(connection => this.setConnection(connection))
                    .catch(err => this.updateStatus('Failed to start presentation: ' + err.message, 'error'));
            }

            reconnectPresentation() {
                const presId = localStorage.getItem('presId');
                if (presId) {
                    this.request.reconnect(presId)
                        .then(connection => this.setConnection(connection))
                        .catch(() => {
                            // Could not reconnect
                            localStorage.removeItem('presId');
                        });
                }
            }

            setConnection(newConnection) {
                if (this.connection && this.connection !== newConnection && this.connection.state !== 'closed') {
                    this.connection.onclose = undefined;
                    this.connection.close();
                }

                this.connection = newConnection;
                localStorage.setItem('presId', this.connection.id);

                this.connection.onconnect = () => {
                    this.showConnectedUI();
                    this.updateStatus('Connected to presentation display', 'connected');
                    
                    // Send initial settings
                    this.sendMessage({
                        type: 'init',
                        color: this.currentColor,
                        strokeWidth: this.currentStrokeWidth,
                        mode: this.renderMode,
                        smoothingEnabled: this.smoothingEnabled,
                        smoothingAmount: this.smoothingAmount
                    });
                };

                this.connection.onclose = () => {
                    this.connection = null;
                    this.showDisconnectedUI();
                    this.updateStatus('Disconnected from presentation', 'disconnected');
                };

                this.connection.onterminate = () => {
                    localStorage.removeItem('presId');
                    this.connection = null;
                    this.showDisconnectedUI();
                    this.updateStatus('Presentation terminated', 'disconnected');
                };

                this.connection.onmessage = (message) => {
                    console.log('Received message:', message.data);
                };
            }

            showConnectedUI() {
                document.getElementById('presentBtn').classList.add('hidden');
                document.getElementById('reconnectBtn').classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');
                document.getElementById('stopBtn').classList.remove('hidden');
                document.getElementById('clearBtn').classList.remove('hidden');
            }

            showDisconnectedUI() {
                document.getElementById('disconnectBtn').classList.add('hidden');
                document.getElementById('stopBtn').classList.add('hidden');
                document.getElementById('clearBtn').classList.add('hidden');
                
                if (localStorage.getItem('presId')) {
                    document.getElementById('reconnectBtn').classList.remove('hidden');
                } else {
                    document.getElementById('presentBtn').classList.remove('hidden');
                }
            }

            disconnect() {
                if (this.connection) {
                    this.connection.close();
                }
            }

            stop() {
                if (this.connection) {
                    this.connection.terminate();
                }
            }

            clearCanvas() {
                if (this.renderMode === 'svg') {
                    this.clearDrawingCanvas('mainCanvas');
                } else {
                    this.clearCanvasDrawing('mainCanvasHTML');
                }
                this.sendMessage({ type: 'clear' });
            }

            clearCanvasDrawing(canvasId) {
                const canvas = document.getElementById(canvasId);
                if (canvas && canvas.getContext) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // Restore white background after clearing
                    this.clearCanvasBackground(ctx, canvas.width, canvas.height);
                }
                this.canvasStrokes = [];
            }

            sendMessage(message) {
                if (this.connection && this.connection.state === 'connected') {
                    this.connection.send(JSON.stringify(message));
                }
            }

            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            setupPresentationReceiver() {
                if (navigator.presentation && navigator.presentation.receiver) {
                    navigator.presentation.receiver.connectionList.then(list => {
                        list.connections.forEach(connection => {
                            this.addConnection(connection);
                        });
                        list.onconnectionavailable = (evt) => {
                            this.addConnection(evt.connection);
                        };
                    });
                }
            }

            addConnection(connection) {
                connection.onmessage = (message) => {
                    const data = JSON.parse(message.data);
                    this.handlePresentationMessage(data);
                };
            }

            handlePresentationMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.currentColor = data.color;
                        this.currentStrokeWidth = data.strokeWidth;
                        if (data.mode) {
                            this.switchPresentationMode(data.mode);
                        }
                        if (data.smoothingEnabled !== undefined) {
                            this.smoothingEnabled = data.smoothingEnabled;
                        }
                        if (data.smoothingAmount !== undefined) {
                            this.smoothingAmount = data.smoothingAmount;
                        }
                        break;
                    case 'colorChange':
                        this.currentColor = data.color;
                        if (this.presentationCanvasContext) {
                            this.presentationCanvasContext.strokeStyle = data.color;
                        }
                        break;
                    case 'strokeWidthChange':
                        this.currentStrokeWidth = data.width;
                        if (this.presentationCanvasContext) {
                            this.presentationCanvasContext.lineWidth = data.width;
                        }
                        break;
                    case 'modeChange':
                        this.switchPresentationMode(data.mode);
                        break;
                    case 'clear':
                        this.clearPresentationCanvas();
                        break;
                    case 'startStroke':
                        if (data.mode === 'svg') {
                            this.createPresentationStroke(data);
                        } else {
                            this.startCanvasStroke(data);
                        }
                        break;
                    case 'drawPoint':
                        if (data.mode === 'svg') {
                            this.addPointToPresentationStroke(data);
                        } else {
                            this.drawCanvasPoint(data);
                        }
                        break;
                    case 'drawBatch':
                        // Process optimized batch drawing
                        this.processBatchDrawing(data);
                        break;
                    case 'messageBatch':
                        // Process multiple messages in batch
                        data.messages.forEach(message => this.handlePresentationMessage(message));
                        break;
                    case 'smoothingChange':
                        this.smoothingEnabled = data.enabled;
                        this.smoothingAmount = data.amount;
                        break;
                    case 'endStroke':
                        if (data.mode === 'canvas') {
                            this.endCanvasStroke(data);
                        }
                        break;
                    case 'eraserModeChange':
                        this.isEraserMode = data.isEraserMode;
                        this.updateCursor();
                        break;
                    case 'erase':
                        this.eraseAtPoint(data.x, data.y, 'presentation');
                        break;
                }
            }

            processBatchDrawing(data) {
                if (data.mode === 'svg' && data.strokeId) {
                    const stroke = document.getElementById(data.strokeId);
                    if (stroke) {
                        if (data.smoothPath && data.smoothingEnabled) {
                            // Use the complete smooth path sent from main
                            stroke.setAttribute('d', data.smoothPath);
                        } else if (data.points) {
                            // Regular batch update SVG path
                            let currentPath = stroke.getAttribute('d');
                            for (const point of data.points) {
                                currentPath += ` L ${point.x} ${point.y}`;
                            }
                            stroke.setAttribute('d', currentPath);
                        }
                    }
                } else if (data.mode === 'canvas' && this.presentationCanvasContext) {
                    // Apply smoothing for canvas if enabled
                    if (data.points) {
                        if (this.smoothingEnabled) {
                            this.drawSmoothCanvas(this.presentationCanvasContext, data.points);
                        } else {
                            // Regular batch draw canvas points
                            for (const point of data.points) {
                                this.presentationCanvasContext.lineTo(point.x, point.y);
                            }
                        }
                        this.presentationCanvasContext.stroke();
                    }
                }
            }

            switchPresentationMode(mode) {
                this.renderMode = mode;
                document.getElementById('drawingCanvas').classList.toggle('hidden', mode === 'canvas');
                const presentationCanvasHTML = document.getElementById('presentationCanvasHTML');
                if (presentationCanvasHTML) {
                    presentationCanvasHTML.classList.toggle('hidden', mode === 'svg');
                }
                this.clearPresentationCanvas();
            }

            clearPresentationCanvas() {
                if (this.renderMode === 'svg') {
                    this.clearDrawingCanvas('drawingCanvas');
                } else {
                    this.clearCanvasDrawing('presentationCanvasHTML');
                }
            }

            createPresentationStroke(data) {
                const stroke = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                stroke.setAttribute('stroke', data.color);
                stroke.setAttribute('stroke-width', data.strokeWidth);
                stroke.setAttribute('fill', 'none');
                stroke.setAttribute('stroke-linecap', 'round');
                stroke.setAttribute('stroke-linejoin', 'round');
                stroke.setAttribute('id', data.strokeId);
                
                const pathData = `M ${data.x} ${data.y}`;
                stroke.setAttribute('d', pathData);
                
                document.getElementById('drawingCanvas').appendChild(stroke);
            }

            addPointToPresentationStroke(data) {
                const stroke = document.getElementById(data.strokeId);
                if (stroke) {
                    const currentPath = stroke.getAttribute('d');
                    const newPath = `${currentPath} L ${data.x} ${data.y}`;
                    stroke.setAttribute('d', newPath);
                }
            }

            startCanvasStroke(data) {
                if (this.presentationCanvasContext) {
                    this.presentationCanvasContext.strokeStyle = data.color;
                    this.presentationCanvasContext.lineWidth = data.strokeWidth;
                    this.presentationCanvasContext.beginPath();
                    this.presentationCanvasContext.moveTo(data.x, data.y);
                }
            }

            drawCanvasPoint(data) {
                if (this.presentationCanvasContext) {
                    this.presentationCanvasContext.lineTo(data.x, data.y);
                    this.presentationCanvasContext.stroke();
                }
            }

            endCanvasStroke(data) {
                // Canvas stroke completed
            }

            setupMainDrawingCanvas() {
                const svgCanvas = document.getElementById('mainCanvas');
                const htmlCanvas = document.getElementById('mainCanvasHTML');
                
                // SVG Canvas events
                this.setupCanvasEvents(svgCanvas);
                // HTML Canvas events
                this.setupCanvasEvents(htmlCanvas);
            }

            setupDrawingCanvas() {
                const canvas = document.getElementById('drawingCanvas');
                this.setupCanvasEvents(canvas);
            }

            setupCanvasEvents(canvas) {
                canvas.addEventListener('pointerdown', (e) => {
                    if (e.pointerType === 'pen' || e.pointerType === 'mouse') {
                        // Detect eraser mode from stylus
                        this.detectEraserMode(e);
                        this.startDrawing(e, canvas.id.includes('main') ? 'main' : 'presentation');
                    }
                });

                canvas.addEventListener('pointermove', (e) => {
                    if (e.pointerType === 'pen' || e.pointerType === 'mouse') {
                        // Update eraser detection during movement
                        this.detectEraserMode(e);
                        this.draw(e, canvas.id.includes('main') ? 'main' : 'presentation');
                    }
                });

                canvas.addEventListener('pointerup', (e) => {
                    if (e.pointerType === 'pen' || e.pointerType === 'mouse') {
                        this.stopDrawing(e, canvas.id.includes('main') ? 'main' : 'presentation');
                    }
                });

                canvas.addEventListener('touchstart', (e) => e.preventDefault());
                canvas.addEventListener('touchmove', (e) => e.preventDefault());
                canvas.addEventListener('touchend', (e) => e.preventDefault());
            }

            startDrawing(e, mode) {
                this.isDrawing = true;
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const strokeId = 'stroke_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                // Initialize stroke points buffer for SVG smoothing
                this.allStrokePoints = [{ x, y }];

                if (this.renderMode === 'svg') {
                    this.currentStroke = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    this.currentStroke.setAttribute('stroke', this.currentColor);
                    this.currentStroke.setAttribute('stroke-width', this.currentStrokeWidth);
                    this.currentStroke.setAttribute('fill', 'none');
                    this.currentStroke.setAttribute('stroke-linecap', 'round');
                    this.currentStroke.setAttribute('stroke-linejoin', 'round');
                    this.currentStroke.setAttribute('id', strokeId);
                    
                    const pathData = `M ${x} ${y}`;
                    this.currentStroke.setAttribute('d', pathData);
                    
                    if (mode === 'main') {
                        document.getElementById('mainCanvas').appendChild(this.currentStroke);
                    } else {
                        document.getElementById('drawingCanvas').appendChild(this.currentStroke);
                    }
                } else {
                    // Canvas mode
                    const ctx = mode === 'main' ? this.mainCanvasContext : this.presentationCanvasContext;
                    if (ctx) {
                        ctx.strokeStyle = this.currentColor;
                        ctx.lineWidth = this.currentStrokeWidth;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        this.currentStroke = { x, y, id: strokeId };
                    }
                }

                if (mode === 'main') {
                    this.sendMessage({
                        type: 'startStroke',
                        strokeId: strokeId,
                        x: x,
                        y: y,
                        color: this.currentColor,
                        strokeWidth: this.currentStrokeWidth,
                        mode: this.renderMode
                    });
                }
            }

            draw(e, mode) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Handle erasing - works even when not in drawing state
                if (this.isEraserMode) {
                    this.eraseAtPoint(x, y, mode);
                    
                    // Send erase command to presentation
                    if (mode === 'main') {
                        this.sendMessage({
                            type: 'erase',
                            x: x,
                            y: y,
                            eraserSize: this.eraserSize,
                            mode: this.renderMode
                        });
                    }
                    return;
                }

                // Only continue with drawing if we're in drawing state
                if (!this.isDrawing) return;

                // Add point to current stroke buffer
                this.currentStrokePoints.push({ x, y });
                
                // For SVG smoothing, also add to complete stroke points
                if (this.renderMode === 'svg') {
                    this.allStrokePoints.push({ x, y });
                }

                // Use throttling for smooth performance
                if (!this.isThrottling) {
                    this.isThrottling = true;
                    this.animationFrame = requestAnimationFrame(() => {
                        this.processDrawingUpdate(mode);
                        this.isThrottling = false;
                    });
                }
            }

            processDrawingUpdate(mode) {
                if (!this.currentStrokePoints.length) return;

                // Get simplified points to reduce data
                const simplifiedPoints = this.simplifyPath(this.currentStrokePoints);
                
                if (this.renderMode === 'svg' && this.currentStroke) {
                    if (this.smoothingEnabled) {
                        // Use all accumulated points for smooth path generation
                        const smoothedAllPoints = this.applySmoothing(this.allStrokePoints);
                        const completePath = this.generateSmoothSVGPath(smoothedAllPoints);
                        this.currentStroke.setAttribute('d', completePath);
                    } else {
                        // Regular incremental path building
                        let currentPath = this.currentStroke.getAttribute('d');
                        for (const point of simplifiedPoints) {
                            currentPath += ` L ${point.x} ${point.y}`;
                        }
                        this.currentStroke.setAttribute('d', currentPath);
                    }
                } else if (this.renderMode === 'canvas') {
                    const ctx = mode === 'main' ? this.mainCanvasContext : this.presentationCanvasContext;
                    if (ctx) {
                        // Apply smoothing to canvas drawing
                        if (this.smoothingEnabled) {
                            this.drawSmoothCanvas(ctx, this.currentStrokePoints);
                        } else {
                            // Regular line drawing
                            for (const point of this.currentStrokePoints) {
                                ctx.lineTo(point.x, point.y);
                            }
                        }
                        ctx.stroke();
                    }
                }

                if (mode === 'main') {
                    // Add to message batch for network optimization
                    let dataToSend = {
                        type: 'drawBatch',
                        strokeId: this.currentStroke ? (this.currentStroke.getAttribute ? this.currentStroke.getAttribute('id') : this.currentStroke.id) : null,
                        points: simplifiedPoints,
                        mode: this.renderMode
                    };
                    
                    // If smoothing is enabled and we're in SVG mode, send the complete smooth path
                    if (this.smoothingEnabled && this.renderMode === 'svg') {
                        const smoothedAllPoints = this.applySmoothing(this.allStrokePoints);
                        const completePath = this.generateSmoothSVGPath(smoothedAllPoints);
                        dataToSend.smoothPath = completePath;
                        dataToSend.smoothingEnabled = true;
                        dataToSend.smoothingAmount = this.smoothingAmount;
                    }
                    
                    this.addToBatch(dataToSend);
                }

                // Clear processed points
                this.currentStrokePoints = [];
            }

            // Path simplification using Douglas-Peucker algorithm (simplified version)
            simplifyPath(points) {
                if (points.length <= 2) return points;
                
                const simplified = [points[0]];
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const next = points[i + 1];
                    
                    // Calculate distance from current point to line between prev and next
                    const distance = this.pointToLineDistance(curr, prev, next);
                    
                    // Only include point if it's significant enough
                    if (distance > this.simplificationTolerance) {
                        simplified.push(curr);
                    }
                }
                simplified.push(points[points.length - 1]);
                
                return simplified;
            }

            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                const param = dot / lenSq;
                let xx, yy;

                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            addToBatch(message) {
                this.messageBatch.push(message);
                
                const now = performance.now();
                if (now - this.lastBatchTime >= this.batchInterval) {
                    this.flushBatch();
                    this.lastBatchTime = now;
                }
            }

            flushBatch() {
                if (this.messageBatch.length === 0) return;
                
                if (this.messageBatch.length === 1) {
                    this.sendMessage(this.messageBatch[0]);
                } else {
                    // Send as batch
                    this.sendMessage({
                        type: 'messageBatch',
                        messages: this.messageBatch
                    });
                }
                
                this.messageBatch = [];
            }

            toggleSmoothing() {
                this.smoothingEnabled = !this.smoothingEnabled;
                const toggle = document.getElementById('smoothingToggle');
                const slider = document.getElementById('smoothingSlider');
                
                toggle.textContent = this.smoothingEnabled ? 'ON' : 'OFF';
                toggle.classList.toggle('active', this.smoothingEnabled);
                slider.disabled = !this.smoothingEnabled;
                
                this.sendMessage({
                    type: 'smoothingChange',
                    enabled: this.smoothingEnabled,
                    amount: this.smoothingAmount
                });
            }

            applySmoothing(points) {
                if (!this.smoothingEnabled || points.length < 3) return points;
                
                const smoothed = [];
                const factor = this.smoothingAmount / 100; // Convert to 0-1
                
                // Catmull-Rom spline smoothing
                smoothed.push(points[0]); // Keep first point
                
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const next = points[i + 1];
                    
                    // Calculate smooth point using weighted average
                    const smoothX = curr.x + factor * ((prev.x + next.x) / 2 - curr.x);
                    const smoothY = curr.y + factor * ((prev.y + next.y) / 2 - curr.y);
                    
                    smoothed.push({ x: smoothX, y: smoothY });
                }
                
                smoothed.push(points[points.length - 1]); // Keep last point
                return smoothed;
            }

            generateSmoothSVGPath(points) {
                if (!this.smoothingEnabled || points.length < 3) {
                    // Regular line path
                    let path = `M ${points[0].x} ${points[0].y}`;
                    for (let i = 1; i < points.length; i++) {
                        path += ` L ${points[i].x} ${points[i].y}`;
                    }
                    return path;
                }
                
                if (points.length < 4) {
                    // Not enough points for smooth curves, use simple quadratic
                    let path = `M ${points[0].x} ${points[0].y}`;
                    const mid = points[Math.floor(points.length / 2)];
                    path += ` Q ${mid.x} ${mid.y} ${points[points.length - 1].x} ${points[points.length - 1].y}`;
                    return path;
                }
                
                // Advanced cubic Bezier smoothing
                const factor = Math.max(0.1, this.smoothingAmount / 100); // More aggressive smoothing
                let path = `M ${points[0].x} ${points[0].y}`;
                
                // Create smooth cubic bezier curves
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    
                    // Calculate control points for smoother curves
                    let cp1x, cp1y, cp2x, cp2y;
                    
                    if (i === 0) {
                        // First segment
                        const afterNext = points[i + 2] || next;
                        cp1x = current.x + factor * (next.x - current.x) * 0.5;
                        cp1y = current.y + factor * (next.y - current.y) * 0.5;
                        cp2x = next.x - factor * (afterNext.x - current.x) * 0.3;
                        cp2y = next.y - factor * (afterNext.y - current.y) * 0.3;
                    } else if (i === points.length - 2) {
                        // Last segment
                        const prev = points[i - 1];
                        cp1x = current.x + factor * (next.x - prev.x) * 0.3;
                        cp1y = current.y + factor * (next.y - prev.y) * 0.3;
                        cp2x = next.x - factor * (next.x - current.x) * 0.5;
                        cp2y = next.y - factor * (next.y - current.y) * 0.5;
                    } else {
                        // Middle segments
                        const prev = points[i - 1];
                        const afterNext = points[i + 2];
                        
                        cp1x = current.x + factor * (next.x - prev.x) * 0.25;
                        cp1y = current.y + factor * (next.y - prev.y) * 0.25;
                        cp2x = next.x - factor * (afterNext.x - current.x) * 0.25;
                        cp2y = next.y - factor * (afterNext.y - current.y) * 0.25;
                    }
                    
                    path += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${next.x} ${next.y}`;
                }
                
                return path;
            }

            drawSmoothCanvas(ctx, points) {
                if (!this.smoothingEnabled || points.length < 3) {
                    // Regular line drawing
                    for (const point of points) {
                        ctx.lineTo(point.x, point.y);
                    }
                    return;
                }
                
                // Much more aggressive smooth curve drawing
                const factor = Math.max(0.2, this.smoothingAmount / 50); // More aggressive factor
                
                if (points.length < 4) {
                    // Simple quadratic for short strokes
                    const mid = points[Math.floor(points.length / 2)];
                    ctx.quadraticCurveTo(mid.x, mid.y, points[points.length - 1].x, points[points.length - 1].y);
                    return;
                }
                
                // Advanced smooth curve using multiple control points
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    
                    if (i === 0) {
                        // First segment - smooth entry
                        const afterNext = points[i + 2] || next;
                        const cp1x = current.x + factor * (next.x - current.x) * 0.6;
                        const cp1y = current.y + factor * (next.y - current.y) * 0.6;
                        const cp2x = next.x - factor * (afterNext.x - current.x) * 0.4;
                        const cp2y = next.y - factor * (afterNext.y - current.y) * 0.4;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                    } else if (i === points.length - 2) {
                        // Last segment - smooth exit
                        const prev = points[i - 1];
                        const cp1x = current.x + factor * (next.x - prev.x) * 0.4;
                        const cp1y = current.y + factor * (next.y - prev.y) * 0.4;
                        const cp2x = next.x - factor * (next.x - current.x) * 0.6;
                        const cp2y = next.y - factor * (next.y - current.y) * 0.6;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                    } else {
                        // Middle segments - maximum smoothing
                        const prev = points[i - 1];
                        const afterNext = points[i + 2] || next;
                        
                        const cp1x = current.x + factor * (next.x - prev.x) * 0.3;
                        const cp1y = current.y + factor * (next.y - prev.y) * 0.3;
                        const cp2x = next.x - factor * (afterNext.x - current.x) * 0.3;
                        const cp2y = next.y - factor * (afterNext.y - current.y) * 0.3;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                    }
                }
            }

            detectEraserMode(e) {
                // Multiple detection methods for stylus eraser
                const wasEraserMode = this.isEraserMode;
                
                // Method 1: Check button 5 (eraser button on some styluses)
                this.isEraserMode = e.button === 5 || 
                                  // Method 2: Check buttons property for eraser
                                  (e.buttons & 32) !== 0 ||
                                  // Method 3: Check for tangentialPressure (barrel rotation on some styluses)
                                  (e.tangentialPressure !== undefined && Math.abs(e.tangentialPressure) > 0.5) ||
                                  // Method 4: Check for specific eraser properties
                                  e.pointerType === 'eraser' ||
                                  // Method 5: Check for inverted stylus (some drivers report this)
                                  (e.twist !== undefined && Math.abs(e.twist) > 90);
                
                // Update cursor based on eraser mode
                if (this.isEraserMode !== wasEraserMode) {
                    this.updateCursor();
                    
                    // Sync eraser state to presentation
                    if (!this.isPresentation) {
                        this.sendMessage({
                            type: 'eraserModeChange',
                            isEraserMode: this.isEraserMode
                        });
                    }
                }
            }

            updateCursor() {
                const canvases = [
                    document.getElementById('mainCanvas'),
                    document.getElementById('mainCanvasHTML'),
                    document.getElementById('drawingCanvas'),
                    document.getElementById('presentationCanvasHTML')
                ].filter(canvas => canvas);
                
                const cursor = this.isEraserMode ? 'grab' : 'crosshair';
                canvases.forEach(canvas => {
                    if (canvas) canvas.style.cursor = cursor;
                });
            }

            eraseAtPoint(x, y, mode) {
                if (this.renderMode === 'svg') {
                    this.eraseSVGAtPoint(x, y, mode);
                } else {
                    this.eraseCanvasAtPoint(x, y, mode);
                }
            }

            eraseSVGAtPoint(x, y, mode) {
                const canvasId = mode === 'main' ? 'mainCanvas' : 'drawingCanvas';
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;

                const paths = canvas.querySelectorAll('path');
                const eraserRadius = this.eraserSize;

                paths.forEach(path => {
                    const bbox = path.getBBox();
                    // Check if eraser point is near this path
                    if (x >= bbox.x - eraserRadius && x <= bbox.x + bbox.width + eraserRadius &&
                        y >= bbox.y - eraserRadius && y <= bbox.y + bbox.height + eraserRadius) {
                        
                        // More precise hit detection would go here
                        // For now, remove the entire path if within bounding box
                        path.remove();
                    }
                });
            }

            eraseCanvasAtPoint(x, y, mode) {
                const ctx = mode === 'main' ? this.mainCanvasContext : this.presentationCanvasContext;
                if (!ctx) return;

                // Save current composite operation
                const prevCompositeOperation = ctx.globalCompositeOperation;
                
                // Switch to erase mode
                ctx.globalCompositeOperation = 'destination-out';
                
                // Draw circular eraser
                ctx.beginPath();
                ctx.arc(x, y, this.eraserSize / 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Restore previous composite operation
                ctx.globalCompositeOperation = prevCompositeOperation;
            }

            stopDrawing(e, mode) {
                if (mode === 'main' && this.currentStroke) {
                    const strokeId = this.currentStroke.getAttribute ? this.currentStroke.getAttribute('id') : this.currentStroke.id;
                    this.sendMessage({
                        type: 'endStroke',
                        strokeId: strokeId,
                        mode: this.renderMode,
                        isEraserMode: this.isEraserMode
                    });
                }
                this.isDrawing = false;
                this.currentStroke = null;
                this.smoothingPoints = []; // Clear smoothing buffer
            }

            clearDrawingCanvas(canvasId = 'drawingCanvas') {
                const canvas = document.getElementById(canvasId);
                while (canvas.firstChild) {
                    canvas.removeChild(canvas.firstChild);
                }
            }
        }

        // Initialize the app
        const app = new PresentationDrawingApp();
    </script>
</body>
</html>
