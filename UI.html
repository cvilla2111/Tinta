<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#f3f3f3">
    <title>Vector Ink Drawing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --grid-size: 10px;
            --grid-color: rgba(180, 180, 180, 0.6);
            --grid-color-major: rgba(120, 120, 120, 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .grid-container {
            position: relative;
            width: 100%;
            min-height: 100vh;
            background-color: white;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
        }

        .grid-pattern {
            width: 100%;
            height: 100%;
            background-size: var(--grid-size) var(--grid-size);
            background-image:
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        }

        .grid-pattern-major {
            width: 100%;
            height: 100%;
            background-size: calc(var(--grid-size) * 4) calc(var(--grid-size) * 4);
            background-image:
                linear-gradient(to right, var(--grid-color-major) 2px, transparent 2px),
                linear-gradient(to bottom, var(--grid-color-major) 2px, transparent 2px);
        }

        .content-layer {
            position: relative;
            z-index: 1;
        }

        #drawingCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
            touch-action: none;
            z-index: 9997;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background-color: #f3f3f3;
            z-index: 10000;
        }

        .separator-line {
            position: fixed;
            left: 390px;
            top: 20px;
            width: 1px;
            height: 20px;
            background-color: #d0d0d0;
            z-index: 10001;
        }

        .separator-line-2 {
            position: fixed;
            left: 730px;
            top: 20px;
            width: 1px;
            height: 20px;
            background-color: #d0d0d0;
            z-index: 10001;
        }

        .separator-line-3 {
            position: fixed;
            left: 870px;
            top: 20px;
            width: 1px;
            height: 20px;
            background-color: #d0d0d0;
            z-index: 10001;
        }

        .library-icon {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 6px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .library-icon:hover {
            background-color: #ebebeb;
        }

        .fullscreen-icon {
            position: fixed;
            right: 20px;
            top: 20px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(50%, -50%);
            padding: 6px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .fullscreen-icon:hover {
            background-color: #ebebeb;
        }

        .undo-icon {
            position: fixed;
            left: 320px;
            top: 30px;
            z-index: 10001;
            color: #333;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 7px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .undo-icon:hover {
            background-color: #ebebeb;
        }

        .redo-icon {
            position: fixed;
            left: 360px;
            top: 30px;
            z-index: 10001;
            color: #333;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 7px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .redo-icon:hover {
            background-color: #ebebeb;
        }

        .pen-icon {
            position: fixed;
            left: 440px;
            top: 30px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 8px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .pen-icon:hover {
            background-color: #ebebeb;
        }

        .pen-icon.active {
            background-color: #9cc6d9;
        }

        .pen-icon.active:hover {
            background-color: #9cc6d9;
        }

        .wand-icon {
            position: fixed;
            left: 490px;
            top: 30px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 8px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .wand-icon:hover {
            background-color: #ebebeb;
        }

        .wand-icon.active {
            background-color: #9cc6d9;
        }

        .wand-icon.active:hover {
            background-color: #9cc6d9;
        }

        .eraser-icon {
            position: fixed;
            left: 540px;
            top: 30px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 8px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .eraser-icon:hover {
            background-color: #ebebeb;
        }

        .eraser-icon.active {
            background-color: #9cc6d9;
        }

        .eraser-icon.active:hover {
            background-color: #9cc6d9;
        }

        .lasso-icon {
            position: fixed;
            left: 590px;
            top: 30px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 8px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .lasso-icon:hover {
            background-color: #ebebeb;
        }

        .lasso-icon.active {
            background-color: #9cc6d9;
        }

        .lasso-icon.active:hover {
            background-color: #9cc6d9;
        }

        .black-circle, .blue-circle, .red-circle {
            position: fixed;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.2s;
        }

        .black-circle { left: 770px; top: 30px; }
        .blue-circle { left: 800px; top: 30px; }
        .red-circle { left: 830px; top: 30px; }

        .black-circle:hover,
        .blue-circle:hover,
        .red-circle:hover {
            transform: translate(-50%, -50%) scale(1.15);
        }

        .ellipsis-icon {
            position: fixed;
            left: 960px;
            top: 30px;
            z-index: 10001;
            cursor: pointer;
            transform: translate(-50%, -50%);
            padding: 8px;
            box-sizing: content-box;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .ellipsis-icon:hover {
            background-color: #ebebeb;
        }

        .menu-modal {
            position: fixed;
            left: 950px;
            top: 63px;
            width: 160px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e4e4e4;
            z-index: 10002;
            display: none;
            padding: 8px;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .menu-modal.show {
            display: block;
            animation: fadeSlideIn 0.2s ease forwards;
        }

        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .menu-item {
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            transition: background-color 0.2s;
        }

        .menu-item:hover {
            background-color: #f3f3f3;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10001;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .menu-overlay.show {
            display: block;
            animation: fadeIn 0.2s ease forwards;
        }

        .settings-modal {
            position: fixed;
            left: 340px;
            top: 160px;
            width: 550px;
            height: 370px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e4e4e4;
            z-index: 10003;
            display: none;
            padding: 20px;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .settings-modal.show {
            display: block;
            animation: fadeScaleIn 0.2s ease forwards;
        }

        @keyframes fadeScaleIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .settings-modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }

        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 10002;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .settings-overlay.show {
            display: block;
            animation: fadeIn 0.2s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .color-palette {
            position: fixed;
            left: 770px;
            top: 63px;
            width: 220px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e4e4e4;
            z-index: 10003;
            display: none;
            padding: 12px;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .color-palette.show {
            display: block;
            animation: fadeSlideIn 0.2s ease forwards;
        }

        .color-palette-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, border-color 0.1s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #9cc6d9;
        }

        .color-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-top: 8px;
            border-top: 1px solid #e4e4e4;
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .color-input {
            width: 40px;
            height: 28px;
            border: 1px solid #e4e4e4;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-hex-input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #e4e4e4;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
        }

        .color-indicator {
            position: fixed;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #333;
            z-index: 10001;
            display: none;
            transform: translateX(-50%);
        }

        .color-indicator.show {
            display: block;
        }

        .black-circle-indicator { left: 770px; top: 44px; }
        .blue-circle-indicator { left: 800px; top: 44px; }
        .red-circle-indicator { left: 830px; top: 44px; }

        .grid-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: move;
            user-select: none;
            pointer-events: auto;
        }

        .grid-controls:active {
            cursor: grabbing;
        }

        .grid-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 6px 10px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-family: monospace;
            font-size: 10px;
            color: #333;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .slider-label {
            font-size: 11px;
            font-weight: 500;
            color: #333;
        }

        input[type="range"] {
            width: 120px;
            height: 4px;
        }

        .snap-cursor {
            position: fixed;
            width: 8px;
            height: 8px;
            border: 1px solid #5D5CDE;
            background: rgba(93, 92, 222, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            transition: all 0.05s ease-out;
        }

        .snap-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
        }

        .snap-crosshair::before,
        .snap-crosshair::after {
            content: '';
            position: absolute;
            background: #5D5CDE;
        }

        .snap-crosshair::before {
            width: 1px;
            height: 4px;
            left: 1.5px;
            top: 0;
        }

        .snap-crosshair::after {
            width: 4px;
            height: 1px;
            left: 0;
            top: 1.5px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header"></div>

    <!-- Separator Lines -->
    <div class="separator-line"></div>
    <div class="separator-line-2"></div>
    <div class="separator-line-3"></div>

    <!-- Library Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-library-big-icon lucide-library-big library-icon">
        <rect width="8" height="18" x="3" y="3" rx="1"/>
        <path d="M7 3v18"/>
        <path d="M20.4 18.9c.2.5-.1 1.1-.6 1.3l-1.9.7c-.5.2-1.1-.1-1.3-.6L11.1 5.1c-.2-.5.1-1.1.6-1.3l1.9-.7c.5-.2 1.1.1 1.3.6Z"/>
    </svg>

    <!-- Fullscreen Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2-icon lucide-maximize-2 fullscreen-icon" id="fullscreenIcon">
        <path d="M15 3h6v6"/>
        <path d="m21 3-7 7"/>
        <path d="m3 21 7-7"/>
        <path d="M9 21H3v-6"/>
    </svg>

    <!-- Exit Fullscreen Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-minimize2-icon lucide-minimize-2 fullscreen-icon" id="exitFullscreenIcon" style="display: none;">
        <path d="m14 10 7-7"/>
        <path d="M20 10h-6V4"/>
        <path d="m3 21 7-7"/>
        <path d="M4 14h6v6"/>
    </svg>

    <!-- Undo Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-undo2-icon lucide-undo-2 undo-icon">
        <g transform="rotate(-45 12 12)">
            <path d="M9 14 4 9l5-5"/>
            <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11"/>
        </g>
    </svg>

    <!-- Redo Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-redo2-icon lucide-redo-2 redo-icon">
        <g transform="rotate(45 12 12)">
            <path d="m15 14 5-5-5-5"/>
            <path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13"/>
        </g>
    </svg>

    <!-- Pen Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pen-tool-icon lucide-pen-tool pen-icon">
        <g transform="rotate(-135 12 12)">
            <path d="M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z"/>
            <path d="m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18"/>
            <path d="m2.3 2.3 7.286 7.286"/>
            <circle cx="11" cy="11" r="2"/>
        </g>
    </svg>

    <!-- Highlighter Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-highlighter-icon lucide-highlighter wand-icon">
        <g transform="rotate(-45 12 12)">
            <path d="m9 11-6 6v3h9l3-3"/>
            <path d="m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4"/>
        </g>
    </svg>

    <!-- Eraser Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-eraser-icon lucide-eraser eraser-icon">
        <path d="M21 21H8a2 2 0 0 1-1.42-.587l-3.994-3.999a2 2 0 0 1 0-2.828l10-10a2 2 0 0 1 2.829 0l5.999 6a2 2 0 0 1 0 2.828L12.834 21"/>
        <path d="m5.082 11.09 8.828 8.828"/>
    </svg>

    <!-- Lasso Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-lasso-icon lucide-lasso lasso-icon">
        <path d="M3.704 14.467A10 8 0 0 1 2 10a10 8 0 0 1 20 0 10 8 0 0 1-10 8 10 8 0 0 1-5.181-1.158"/>
        <path d="M7 22a5 5 0 0 1-2-3.994"/>
        <circle cx="5" cy="16" r="2"/>
    </svg>

    <!-- Color Circles -->
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="black-circle">
        <circle cx="12" cy="12" r="12" fill="#000000"/>
    </svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="blue-circle">
        <circle cx="12" cy="12" r="12" fill="#003fff"/>
    </svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="red-circle">
        <circle cx="12" cy="12" r="12" fill="#db090c"/>
    </svg>

    <!-- Color Indicators -->
    <div class="color-indicator black-circle-indicator show" id="blackIndicator"></div>
    <div class="color-indicator blue-circle-indicator" id="blueIndicator"></div>
    <div class="color-indicator red-circle-indicator" id="redIndicator"></div>

    <!-- Ellipsis Icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-ellipsis-icon lucide-ellipsis ellipsis-icon" id="menuIcon">
        <circle cx="12" cy="12" r="1"/>
        <circle cx="19" cy="12" r="1"/>
        <circle cx="5" cy="12" r="1"/>
    </svg>

    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay"></div>

    <!-- Menu Modal -->
    <div class="menu-modal" id="menuModal">
        <div class="menu-item" id="settingsMenuItem">Settings</div>
        <div class="menu-item" id="exportMenuItem">Export</div>
        <div class="menu-item" id="clearMenuItem">Clear Canvas</div>
    </div>

    <!-- Settings Overlay -->
    <div class="settings-overlay" id="settingsOverlay"></div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-modal-header">Settings</div>
        <div class="slider-container" style="margin-bottom: 20px;">
            <label class="slider-label">Pen Size: <span id="penSizeValue">2</span>px</label>
            <input type="range" id="penSize" min="1" max="20" value="2" step="1" style="width: 100%;">
        </div>
        <div style="display: flex; flex-direction: column; gap: 12px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="showGridCheckbox" style="width: 16px; height: 16px; cursor: pointer;">
                <span style="font-size: 14px; color: #333;">Show Grid & Snap</span>
            </label>
        </div>
    </div>

    <!-- Color Palette -->
    <div class="color-palette" id="colorPalette">
        <div class="color-palette-grid" id="colorPaletteGrid"></div>
        <div class="color-input-container">
            <div class="color-input-wrapper">
                <input type="color" class="color-input" id="colorPicker">
                <input type="text" class="color-hex-input" id="colorHexInput" placeholder="#000000" maxlength="7">
            </div>
        </div>
    </div>

    <!-- Snap Cursor -->
    <div class="snap-cursor" id="snapCursor">
        <div class="snap-crosshair"></div>
    </div>

    <div class="grid-container">
        <!-- Drawing Canvas -->
        <svg id="drawingCanvas" xmlns="http://www.w3.org/2000/svg">
            <rect width="100%" height="100%" fill="#FFFFFF"/>
            <g id="drawingLayer"></g>
            <circle id="eraserCursor" r="10" fill="none" stroke="#5D5CDE" stroke-width="2" opacity="0.6" pointer-events="none" style="display: none;"/>
        </svg>

        <!-- Grid Overlay -->
        <div class="grid-overlay" id="gridOverlay">
            <div class="grid-pattern-major">
                <div class="grid-pattern"></div>
            </div>
        </div>

        <!-- Controls -->
        <div class="grid-controls">
            <div class="slider-container">
                <label class="slider-label">Grid Size: <span id="gridSizeValue">10</span>px</label>
                <input type="range" id="gridSize" min="10" max="100" value="10" step="5">
            </div>
            <div class="slider-container">
                <label class="slider-label">Grid Opacity: <span id="gridOpacityValue">100</span>%</label>
                <input type="range" id="gridOpacity" min="0" max="100" value="100" step="5">
            </div>
        </div>

        <!-- Grid Info -->
        <div class="grid-info" id="gridInfo">
            Position: (0, 0)
        </div>
    </div>

    <script>
        // Initialize SVG canvas
        const svg = document.getElementById('drawingCanvas');
        const drawingLayer = document.getElementById('drawingLayer');
        const eraserCursor = document.getElementById('eraserCursor');

        // Track all strokes for efficient erasing
        const strokes = [];
        const undoStack = [];
        const redoStack = [];

        // Quadtree for spatial indexing
        class Quadtree {
            constructor(bounds, capacity = 8, maxDepth = 8, depth = 0) {
                this.bounds = bounds; // {x, y, width, height}
                this.capacity = capacity;
                this.maxDepth = maxDepth;
                this.depth = depth;
                this.strokes = [];
                this.divided = false;
                this.northeast = null;
                this.northwest = null;
                this.southeast = null;
                this.southwest = null;
            }

            subdivide() {
                const x = this.bounds.x;
                const y = this.bounds.y;
                const w = this.bounds.width / 2;
                const h = this.bounds.height / 2;
                const nextDepth = this.depth + 1;

                this.northeast = new Quadtree({x: x + w, y: y, width: w, height: h}, this.capacity, this.maxDepth, nextDepth);
                this.northwest = new Quadtree({x: x, y: y, width: w, height: h}, this.capacity, this.maxDepth, nextDepth);
                this.southeast = new Quadtree({x: x + w, y: y + h, width: w, height: h}, this.capacity, this.maxDepth, nextDepth);
                this.southwest = new Quadtree({x: x, y: y + h, width: w, height: h}, this.capacity, this.maxDepth, nextDepth);
                this.divided = true;
            }

            insert(stroke) {
                if (!this.intersects(stroke.bounds)) {
                    return false;
                }

                // If we haven't hit capacity or max depth, store here
                if (this.strokes.length < this.capacity && !this.divided) {
                    this.strokes.push(stroke);
                    return true;
                }

                // If we're at max depth, just store it here even if over capacity
                if (this.depth >= this.maxDepth) {
                    this.strokes.push(stroke);
                    return true;
                }

                // Subdivide if not already divided
                if (!this.divided) {
                    this.subdivide();
                    // Move existing strokes to subdivisions
                    const existingStrokes = [...this.strokes];
                    this.strokes = [];
                    existingStrokes.forEach(s => {
                        // Only insert if the stroke intersects this quadrant
                        if (this.northeast.intersects(s.bounds)) this.northeast.insert(s);
                        if (this.northwest.intersects(s.bounds)) this.northwest.insert(s);
                        if (this.southeast.intersects(s.bounds)) this.southeast.insert(s);
                        if (this.southwest.intersects(s.bounds)) this.southwest.insert(s);
                    });
                }

                // Insert into intersecting quadrants only
                let inserted = false;
                if (this.northeast.intersects(stroke.bounds)) inserted = this.northeast.insert(stroke) || inserted;
                if (this.northwest.intersects(stroke.bounds)) inserted = this.northwest.insert(stroke) || inserted;
                if (this.southeast.intersects(stroke.bounds)) inserted = this.southeast.insert(stroke) || inserted;
                if (this.southwest.intersects(stroke.bounds)) inserted = this.southwest.insert(stroke) || inserted;

                return inserted;
            }

            query(range, found = []) {
                if (!this.intersectsRange(range)) {
                    return found;
                }

                // Use Set to avoid duplicates (strokes can be in multiple quadrants)
                const foundSet = found instanceof Set ? found : new Set(found);

                for (const stroke of this.strokes) {
                    if (this.intersectsRange(range, stroke.bounds)) {
                        foundSet.add(stroke);
                    }
                }

                if (this.divided) {
                    this.northeast.query(range, foundSet);
                    this.northwest.query(range, foundSet);
                    this.southeast.query(range, foundSet);
                    this.southwest.query(range, foundSet);
                }

                return foundSet instanceof Set ? Array.from(foundSet) : found;
            }

            intersects(bounds) {
                return !(bounds.x > this.bounds.x + this.bounds.width ||
                        bounds.x + bounds.width < this.bounds.x ||
                        bounds.y > this.bounds.y + this.bounds.height ||
                        bounds.y + bounds.height < this.bounds.y);
            }

            intersectsRange(range, strokeBounds = null) {
                const bounds = strokeBounds || this.bounds;
                return !(range.x > bounds.x + bounds.width ||
                        range.x + range.width < bounds.x ||
                        range.y > bounds.y + bounds.height ||
                        range.y + bounds.height < bounds.y);
            }

            clear() {
                this.strokes = [];
                this.divided = false;
                this.northeast = null;
                this.northwest = null;
                this.southeast = null;
                this.southwest = null;
            }
        }

        // Initialize quadtree
        let quadtree = new Quadtree({
            x: 0,
            y: 0,
            width: window.innerWidth,
            height: window.innerHeight
        });

        // Rebuild quadtree on resize
        window.addEventListener('resize', () => {
            const newQuadtree = new Quadtree({
                x: 0,
                y: 0,
                width: window.innerWidth,
                height: window.innerHeight
            });
            strokes.forEach(stroke => {
                if (stroke.bounds) {
                    newQuadtree.insert(stroke);
                }
            });
            quadtree = newQuadtree;
        });

        // Set SVG viewBox
        function resizeSVG() {
            svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
        }

        resizeSVG();
        window.addEventListener('resize', resizeSVG);

        // Drawing state
        let isDrawing = false;
        let currentColor = '#000000';
        let currentSize = 2;
        let currentTool = 'pen';
        let points = [];
        let currentPath = null;

        // Grid controls
        const gridSize = document.getElementById('gridSize');
        const gridSizeValue = document.getElementById('gridSizeValue');
        const gridOpacity = document.getElementById('gridOpacity');
        const gridOpacityValue = document.getElementById('gridOpacityValue');
        const gridOverlay = document.getElementById('gridOverlay');
        const gridInfo = document.getElementById('gridInfo');
        const snapCursor = document.getElementById('snapCursor');
        const gridControls = document.querySelector('.grid-controls');

        // Update grid size
        gridSize.addEventListener('input', (e) => {
            const size = e.target.value;
            gridSizeValue.textContent = size;
            document.documentElement.style.setProperty('--grid-size', `${size}px`);
        });

        // Update grid opacity
        gridOpacity.addEventListener('input', (e) => {
            const opacity = e.target.value;
            gridOpacityValue.textContent = opacity;
            gridOverlay.style.opacity = opacity / 100;
        });

        // Pen size control
        const penSize = document.getElementById('penSize');
        const penSizeValue = document.getElementById('penSizeValue');
        penSize.addEventListener('input', (e) => {
            currentSize = parseInt(e.target.value);
            penSizeValue.textContent = currentSize;
            if (currentTool === 'eraser') {
                updateEraserCursorSize();
            }
        });

        // Update eraser cursor size
        function updateEraserCursorSize() {
            eraserCursor.setAttribute('r', currentSize * 3);
        }

        // Get point coordinates
        function getPoint(e) {
            const rect = svg.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top,
                pressure: e.pressure || 0.5
            };
        }

        // Create SVG path from points using smooth quadratic curves
        function createSmoothPath(points) {
            if (points.length < 2) return '';

            let pathData = `M ${points[0].x} ${points[0].y}`;

            for (let i = 1; i < points.length - 1; i++) {
                const xc = (points[i].x + points[i + 1].x) / 2;
                const yc = (points[i].y + points[i + 1].y) / 2;
                pathData += ` Q ${points[i].x} ${points[i].y} ${xc} ${yc}`;
            }

            if (points.length > 1) {
                const lastPoint = points[points.length - 1];
                const secondLast = points[points.length - 2];
                pathData += ` Q ${secondLast.x} ${secondLast.y} ${lastPoint.x} ${lastPoint.y}`;
            }

            return pathData;
        }

        // Update current path during drawing
        function updateCurrentPath() {
            if (!currentPath || points.length < 2) return;

            const pathData = createSmoothPath(points);
            currentPath.setAttribute('d', pathData);
        }

        // Quick AABB check before expensive path sampling
        function isPointNearBounds(point, bounds, threshold) {
            return point.x >= bounds.x - threshold &&
                   point.x <= bounds.x + bounds.width + threshold &&
                   point.y >= bounds.y - threshold &&
                   point.y <= bounds.y + bounds.height + threshold;
        }

        // Performance counters
        let perfStats = {
            bboxChecks: 0,
            bboxRejections: 0,
            pathSamples: 0,
            pathHits: 0
        };

        // Get transform offset from stroke element
        function getStrokeTransform(stroke) {
            const transform = stroke.element.getAttribute('transform') || '';
            const translateMatch = transform.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
            const scaleMatch = transform.match(/scale\(([-\d.]+)\)/);

            return {
                x: translateMatch ? parseFloat(translateMatch[1]) : 0,
                y: translateMatch ? parseFloat(translateMatch[2]) : 0,
                scale: scaleMatch ? parseFloat(scaleMatch[1]) : 1
            };
        }

        // Check if a point is near a path (FAST version using stored points)
        function isPointNearPath(point, stroke, threshold) {
            try {
                perfStats.bboxChecks++;

                // NOTE: stroke.bounds is already updated to transformed position if moved
                // Quick bounding box check first (very fast)
                if (!isPointNearBounds(point, stroke.bounds, threshold)) {
                    perfStats.bboxRejections++;
                    return false;
                }

                perfStats.pathSamples++;

                // Check against stored points array (MUCH faster than SVG path methods)
                if (!stroke.points || stroke.points.length === 0) {
                    return false;
                }

                // Get stroke's transform offset for point-by-point checking
                const transform = getStrokeTransform(stroke);

                const thresholdSquared = threshold * threshold;

                // Sample every few points to keep it fast, but cap step size for large strokes
                // Min step: 1, Max step: 3 (ensures adequate coverage even for very long strokes)
                const step = Math.max(1, Math.min(3, Math.floor(stroke.points.length / 15)));

                for (let i = 0; i < stroke.points.length; i += step) {
                    const p = stroke.points[i];
                    // Apply transform to stroke points for comparison
                    // stroke.points are always in original coordinates
                    // Apply scale first, then translate
                    const transformedX = p.x * transform.scale + transform.x;
                    const transformedY = p.y * transform.scale + transform.y;
                    const dx = transformedX - point.x;
                    const dy = transformedY - point.y;
                    const distSquared = dx * dx + dy * dy;

                    // Scale the threshold too
                    const scaledThresholdSquared = thresholdSquared * transform.scale * transform.scale;

                    if (distSquared < scaledThresholdSquared) {
                        perfStats.pathHits++;
                        return true;
                    }
                }

                return false;
            } catch (e) {
                return false;
            }
        }

        // Calculate bounding box for a path element
        function calculatePathBounds(pathElement) {
            try {
                const bbox = pathElement.getBBox();
                return {
                    x: bbox.x,
                    y: bbox.y,
                    width: bbox.width,
                    height: bbox.height
                };
            } catch (e) {
                return {x: 0, y: 0, width: 0, height: 0};
            }
        }

        // Erase strokes that intersect with eraser path (optimized with quadtree)
        function eraseIntersectingStrokes(eraserPoints, eraserRadius) {
            const t0 = performance.now();
            const strokesToRemove = new Set();

            // Reset perf stats
            perfStats = {
                bboxChecks: 0,
                bboxRejections: 0,
                pathSamples: 0,
                pathHits: 0
            };

            const t1 = performance.now();
            let queryTime = 0;
            let collisionTime = 0;

            eraserPoints.forEach(eraserPoint => {
                // Query quadtree for nearby strokes
                const qt0 = performance.now();
                const range = {
                    x: eraserPoint.x - eraserRadius,
                    y: eraserPoint.y - eraserRadius,
                    width: eraserRadius * 2,
                    height: eraserRadius * 2
                };

                const nearbyStrokes = quadtree.query(range);
                queryTime += performance.now() - qt0;

                const ct0 = performance.now();
                nearbyStrokes.forEach(stroke => {
                    // Skip if already marked for removal
                    if (strokesToRemove.has(stroke)) {
                        return;
                    }

                    if (isPointNearPath(eraserPoint, stroke, eraserRadius)) {
                        strokesToRemove.add(stroke);
                    }
                });
                collisionTime += performance.now() - ct0;
            });

            const t2 = performance.now();

            // Remove strokes and rebuild quadtree only if needed
            let domRemovalTime = 0;
            let rebuildTime = 0;

            if (strokesToRemove.size > 0) {
                const dr0 = performance.now();
                // Remove from DOM and strokes array
                strokesToRemove.forEach(stroke => {
                    stroke.element.remove();
                    const index = strokes.indexOf(stroke);
                    if (index > -1) {
                        strokes.splice(index, 1);
                    }
                });
                domRemovalTime = performance.now() - dr0;

                // Rebuild quadtree only when many strokes removed (threshold: 10% of total or >5 strokes)
                const removalThreshold = Math.max(5, Math.floor(strokes.length * 0.1));
                if (strokesToRemove.size >= removalThreshold || strokes.length < 50) {
                    const rb0 = performance.now();
                    quadtree.clear();
                    strokes.forEach(stroke => {
                        if (stroke.bounds) {
                            quadtree.insert(stroke);
                        }
                    });
                    rebuildTime = performance.now() - rb0;
                }
            }
        }

        // Detect if using pen eraser
        function isUsingEraser(e) {
            if (e.buttons === 32) return true;
            if (e.pointerType === 'pen' && e.button === 5) return true;
            return false;
        }

        // Update eraser cursor position
        function updateEraserCursorPosition(point, show) {
            if (show) {
                eraserCursor.setAttribute('cx', point.x);
                eraserCursor.setAttribute('cy', point.y);
                eraserCursor.style.display = 'block';
            } else {
                eraserCursor.style.display = 'none';
            }
        }

        // Throttle erase operations using requestAnimationFrame
        let pendingErasePoints = [];
        let eraseScheduled = false;
        let eraseRadius = currentSize * 3;

        function processEraseQueue() {
            if (pendingErasePoints.length > 0) {
                eraseIntersectingStrokes(pendingErasePoints, eraseRadius);
                pendingErasePoints = [];
            }
            eraseScheduled = false;
        }

        // Pointer events
        svg.addEventListener('pointerdown', (e) => {
            // Ignore touch input (finger), only allow pen and mouse
            if (e.pointerType === 'touch') return;

            const point = getPoint(e);
            const usingHardwareEraser = isUsingEraser(e);
            const effectiveTool = usingHardwareEraser ? 'eraser' : currentTool;

            if (effectiveTool === 'lasso') {
                // Check if clicking on a scale handle first
                const scaleHandle = getScaleHandleAtPoint(point);

                if (scaleHandle && selectedStrokes.size > 0) {
                    // Start scaling
                    isScalingSelection = true;
                    activeScaleHandle = scaleHandle;
                    dragStartPoint = point;

                    // Calculate scale origin (opposite corner) using CURRENT transformed bounds
                    const corner = scaleHandle.dataset.corner;
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                    selectedStrokes.forEach(stroke => {
                        const transform = getStrokeTransform(stroke);
                        const bounds = stroke.originalBounds || stroke.bounds;
                        const padding = 5;

                        // Apply scale to bounds to get current position
                        const scaledWidth = bounds.width * transform.scale;
                        const scaledHeight = bounds.height * transform.scale;
                        const scaledX = bounds.x * transform.scale;
                        const scaledY = bounds.y * transform.scale;

                        const x1 = scaledX - padding + transform.x;
                        const y1 = scaledY - padding + transform.y;
                        const x2 = x1 + scaledWidth + padding * 2;
                        const y2 = y1 + scaledHeight + padding * 2;

                        minX = Math.min(minX, x1);
                        minY = Math.min(minY, y1);
                        maxX = Math.max(maxX, x2);
                        maxY = Math.max(maxY, y2);
                    });

                    // Set scale origin to opposite corner
                    if (corner === 'nw') scaleOrigin = { x: maxX, y: maxY };
                    else if (corner === 'ne') scaleOrigin = { x: minX, y: maxY };
                    else if (corner === 'sw') scaleOrigin = { x: maxX, y: minY };
                    else if (corner === 'se') scaleOrigin = { x: minX, y: minY };

                    // Store initial distance for scale calculation
                    const dx = dragStartPoint.x - scaleOrigin.x;
                    const dy = dragStartPoint.y - scaleOrigin.y;
                    initialScale = Math.sqrt(dx * dx + dy * dy);

                    // ALWAYS update baseScale AND originalTransform to current values when starting a new scale operation
                    selectedStrokes.forEach(stroke => {
                        const transform = getStrokeTransform(stroke);
                        stroke.baseScale = transform.scale; // Set to current scale

                        // Update originalTransform to current transform
                        stroke.originalTransform = {
                            x: transform.x,
                            y: transform.y
                        };

                        // Make sure originalBounds is set
                        if (!stroke.originalBounds) {
                            stroke.originalBounds = {
                                x: stroke.bounds.x,
                                y: stroke.bounds.y,
                                width: stroke.bounds.width,
                                height: stroke.bounds.height
                            };
                        }
                    });
                } else {
                    // Check if clicking inside any selection box to drag them
                    const clickedInSelectionBox = isPointInSelectionBox(point);

                    if (clickedInSelectionBox && selectedStrokes.size > 0) {
                        isDraggingSelection = true;
                        dragStartPoint = point;
                        selectionOffset = { x: 0, y: 0 };
                    } else {
                        // Start drawing new lasso
                        clearSelection();
                        isDrawing = true;
                        lassoPoints = [point];
                        lassoPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        lassoPath.setAttribute('fill', 'none');
                        lassoPath.setAttribute('stroke', '#5D5CDE');
                        lassoPath.setAttribute('stroke-width', '2');
                        lassoPath.setAttribute('stroke-dasharray', '5,5');
                        lassoPath.setAttribute('opacity', '0.7');
                        svg.appendChild(lassoPath);
                    }
                }
            } else {
                isDrawing = true;
                points = [point];

                if (effectiveTool === 'eraser') {
                    currentPath = null;
                    updateEraserCursorSize();
                    updateEraserCursorPosition(points[0], true);
                    eraseRadius = currentSize * 3;
                    pendingErasePoints = [];
                } else {
                    currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    currentPath.setAttribute('fill', 'none');
                    currentPath.setAttribute('stroke-linecap', 'round');
                    currentPath.setAttribute('stroke-linejoin', 'round');
                    currentPath.setAttribute('stroke', currentColor);
                    currentPath.setAttribute('stroke-width', currentSize);
                    drawingLayer.appendChild(currentPath);
                    updateEraserCursorPosition(points[0], false);
                }
            }
        });

        svg.addEventListener('pointermove', (e) => {
            // Ignore touch input for drawing, but allow for UI feedback
            const point = getPoint(e);

            const usingHardwareEraser = isUsingEraser(e);
            const effectiveTool = usingHardwareEraser ? 'eraser' : currentTool;

            if (e.pointerType !== 'touch') {
                if (effectiveTool === 'eraser') {
                    updateEraserCursorPosition(point, true);
                } else {
                    updateEraserCursorPosition(point, false);
                }
            }

            // Handle lasso selection scaling
            if (effectiveTool === 'lasso' && isScalingSelection && dragStartPoint) {
                if (e.pointerType === 'touch') return;

                // Calculate scale factor based on distance from origin
                const dx = point.x - scaleOrigin.x;
                const dy = point.y - scaleOrigin.y;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const scaleFactor = currentDistance / initialScale;

                // Apply minimum scale to prevent inverting
                const clampedScale = Math.max(0.1, scaleFactor);

                scaleSelectedStrokes(clampedScale, scaleOrigin);
                return;
            }

            // Handle lasso selection dragging
            if (effectiveTool === 'lasso' && isDraggingSelection && dragStartPoint) {
                if (e.pointerType === 'touch') return;

                const offsetX = point.x - dragStartPoint.x;
                const offsetY = point.y - dragStartPoint.y;

                moveSelectedStrokes(offsetX - selectionOffset.x, offsetY - selectionOffset.y);
                selectionOffset = { x: offsetX, y: offsetY };
                return;
            }

            if (!isDrawing) return;
            if (e.pointerType === 'touch') return;

            if (effectiveTool === 'lasso') {
                lassoPoints.push(point);
                const pathData = createSmoothPath(lassoPoints);
                lassoPath.setAttribute('d', pathData);
            } else {
                points.push(point);

                if (effectiveTool === 'eraser') {
                    // Batch erase points instead of processing immediately
                    pendingErasePoints.push(point);

                    // Schedule processing if not already scheduled
                    if (!eraseScheduled) {
                        eraseScheduled = true;
                        requestAnimationFrame(processEraseQueue);
                    }
                } else {
                    updateCurrentPath();
                }
            }
        });

        svg.addEventListener('pointerup', (e) => {
            // Ignore touch input
            if (e.pointerType === 'touch') return;

            const effectiveTool = isUsingEraser(e) ? 'eraser' : currentTool;

            // Handle lasso selection scaling end
            if (effectiveTool === 'lasso' && isScalingSelection) {
                isScalingSelection = false;
                activeScaleHandle = null;
                dragStartPoint = null;

                // Update baseScale for next scaling operation
                selectedStrokes.forEach(stroke => {
                    const transform = getStrokeTransform(stroke);
                    stroke.baseScale = transform.scale;
                });

                return;
            }

            // Handle lasso selection dragging end
            if (effectiveTool === 'lasso' && isDraggingSelection) {
                isDraggingSelection = false;
                dragStartPoint = null;
                selectionOffset = { x: 0, y: 0 };
                return;
            }

            if (isDrawing) {
                if (effectiveTool === 'lasso') {
                    // Complete lasso selection
                    if (lassoPoints.length > 2) {
                        // Select strokes inside the lasso
                        strokes.forEach(stroke => {
                            if (isStrokeInLasso(stroke, lassoPoints)) {
                                selectedStrokes.add(stroke);
                                stroke.element.setAttribute('opacity', '0.6');
                                // Create selection box for this stroke
                                const selectionBox = createSelectionBox(stroke);
                                selectionBoxes.push(selectionBox);
                            }
                        });

                        // Create scale handles after all selection boxes are created
                        createScaleHandles();
                    }

                    // Remove lasso path
                    if (lassoPath) {
                        lassoPath.remove();
                        lassoPath = null;
                    }
                    lassoPoints = [];
                } else {
                    // Process any remaining erase points immediately
                    if (pendingErasePoints.length > 0) {
                        eraseIntersectingStrokes(pendingErasePoints, eraseRadius);
                        pendingErasePoints = [];
                        eraseScheduled = false;
                    }

                    if (currentPath) {
                        updateCurrentPath();

                        // Calculate bounding box and add to quadtree
                        const bounds = calculatePathBounds(currentPath);
                        const strokeData = {
                            element: currentPath,
                            color: currentColor,
                            size: currentSize,
                            bounds: bounds,
                            points: [...points] // Store points for fast collision detection
                        };

                        strokes.push(strokeData);
                        quadtree.insert(strokeData);
                        undoStack.push({ type: 'add', stroke: currentPath });
                        redoStack.length = 0;
                    }
                }

                isDrawing = false;
                points = [];
                currentPath = null;
            }
        });

        svg.addEventListener('pointerleave', () => {
            eraserCursor.style.display = 'none';

            if (isDrawing) {
                // Process any remaining erase points immediately
                if (pendingErasePoints.length > 0) {
                    eraseIntersectingStrokes(pendingErasePoints, eraseRadius);
                    pendingErasePoints = [];
                    eraseScheduled = false;
                }

                if (currentPath) {
                    updateCurrentPath();

                    // Calculate bounding box and add to quadtree
                    const bounds = calculatePathBounds(currentPath);
                    const strokeData = {
                        element: currentPath,
                        color: currentColor,
                        size: currentSize,
                        bounds: bounds,
                        points: [...points] // Store points for fast collision detection
                    };

                    strokes.push(strokeData);
                    quadtree.insert(strokeData);
                }
                isDrawing = false;
                points = [];
                currentPath = null;
            }
        });

        // Lasso selection state
        let selectedStrokes = new Set();
        let lassoPath = null;
        let lassoPoints = [];
        let isDraggingSelection = false;
        let isScalingSelection = false;
        let dragStartPoint = null;
        let selectionOffset = { x: 0, y: 0 };
        let selectionBoxes = []; // SVG rectangles showing selection bounds
        let scaleHandles = []; // Scale handles for corners
        let activeScaleHandle = null;
        let initialScale = 1;
        let scaleOrigin = { x: 0, y: 0 };

        // Create selection box for a stroke
        function createSelectionBox(stroke) {
            const transform = getStrokeTransform(stroke);
            const bounds = stroke.originalBounds || stroke.bounds;

            const padding = 5;

            // Apply scale to the bounds dimensions
            const scaledWidth = bounds.width * transform.scale;
            const scaledHeight = bounds.height * transform.scale;
            const scaledX = bounds.x * transform.scale;
            const scaledY = bounds.y * transform.scale;

            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', scaledX - padding + transform.x);
            box.setAttribute('y', scaledY - padding + transform.y);
            box.setAttribute('width', scaledWidth + padding * 2);
            box.setAttribute('height', scaledHeight + padding * 2);
            box.setAttribute('fill', 'rgba(93, 92, 222, 0.05)'); // Very light transparent fill makes it clickable
            box.setAttribute('stroke', '#5D5CDE');
            box.setAttribute('stroke-width', '2');
            box.setAttribute('stroke-dasharray', '5,5');
            box.setAttribute('opacity', '0.7');
            box.setAttribute('pointer-events', 'all'); // Enable pointer events for dragging
            box.setAttribute('cursor', 'move');

            svg.appendChild(box);
            return box;
        }

        // Create scale handle (corner circle)
        function createScaleHandle(x, y, corner) {
            const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            handle.setAttribute('cx', x);
            handle.setAttribute('cy', y);
            handle.setAttribute('r', '8');
            handle.setAttribute('fill', '#5D5CDE');
            handle.setAttribute('stroke', '#FFFFFF');
            handle.setAttribute('stroke-width', '2');
            handle.setAttribute('cursor', 'nwse-resize');
            handle.setAttribute('pointer-events', 'all');
            handle.dataset.corner = corner; // Store which corner this is

            svg.appendChild(handle);
            return handle;
        }

        // Create scale handles for all four corners of the selection
        function createScaleHandles() {
            if (selectedStrokes.size === 0) return;

            // Calculate overall bounding box of all selected strokes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            selectedStrokes.forEach(stroke => {
                const transform = getStrokeTransform(stroke);
                const bounds = stroke.originalBounds || stroke.bounds;
                const padding = 5;

                // Apply scale to bounds
                const scaledWidth = bounds.width * transform.scale;
                const scaledHeight = bounds.height * transform.scale;
                const scaledX = bounds.x * transform.scale;
                const scaledY = bounds.y * transform.scale;

                const x1 = scaledX - padding + transform.x;
                const y1 = scaledY - padding + transform.y;
                const x2 = x1 + scaledWidth + padding * 2;
                const y2 = y1 + scaledHeight + padding * 2;

                minX = Math.min(minX, x1);
                minY = Math.min(minY, y1);
                maxX = Math.max(maxX, x2);
                maxY = Math.max(maxY, y2);
            });

            // Create handles at four corners
            scaleHandles.push(createScaleHandle(minX, minY, 'nw')); // top-left
            scaleHandles.push(createScaleHandle(maxX, minY, 'ne')); // top-right
            scaleHandles.push(createScaleHandle(minX, maxY, 'sw')); // bottom-left
            scaleHandles.push(createScaleHandle(maxX, maxY, 'se')); // bottom-right
        }

        // Update scale handle positions
        function updateScaleHandles() {
            if (selectedStrokes.size === 0 || scaleHandles.length === 0) return;

            // Calculate overall bounding box of all selected strokes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            selectedStrokes.forEach(stroke => {
                const transform = getStrokeTransform(stroke);
                const bounds = stroke.originalBounds || stroke.bounds;
                const padding = 5;

                // Apply scale to bounds
                const scaledWidth = bounds.width * transform.scale;
                const scaledHeight = bounds.height * transform.scale;
                const scaledX = bounds.x * transform.scale;
                const scaledY = bounds.y * transform.scale;

                const x1 = scaledX - padding + transform.x;
                const y1 = scaledY - padding + transform.y;
                const x2 = x1 + scaledWidth + padding * 2;
                const y2 = y1 + scaledHeight + padding * 2;

                minX = Math.min(minX, x1);
                minY = Math.min(minY, y1);
                maxX = Math.max(maxX, x2);
                maxY = Math.max(maxY, y2);
            });

            // Update handle positions
            scaleHandles[0].setAttribute('cx', minX);
            scaleHandles[0].setAttribute('cy', minY);
            scaleHandles[1].setAttribute('cx', maxX);
            scaleHandles[1].setAttribute('cy', minY);
            scaleHandles[2].setAttribute('cx', minX);
            scaleHandles[2].setAttribute('cy', maxY);
            scaleHandles[3].setAttribute('cx', maxX);
            scaleHandles[3].setAttribute('cy', maxY);
        }

        // Clear scale handles
        function clearScaleHandles() {
            scaleHandles.forEach(handle => handle.remove());
            scaleHandles = [];
        }

        // Update selection box position for a stroke
        function updateSelectionBox(box, stroke) {
            const transform = getStrokeTransform(stroke);
            const bounds = stroke.originalBounds || stroke.bounds;

            const padding = 5;

            // Apply scale to the bounds dimensions
            const scaledWidth = bounds.width * transform.scale;
            const scaledHeight = bounds.height * transform.scale;
            const scaledX = bounds.x * transform.scale;
            const scaledY = bounds.y * transform.scale;

            box.setAttribute('x', scaledX - padding + transform.x);
            box.setAttribute('y', scaledY - padding + transform.y);
            box.setAttribute('width', scaledWidth + padding * 2);
            box.setAttribute('height', scaledHeight + padding * 2);
        }

        // Clear all selection boxes
        function clearSelectionBoxes() {
            selectionBoxes.forEach(box => box.remove());
            selectionBoxes = [];
        }

        // Check if point is near a scale handle
        function getScaleHandleAtPoint(point) {
            const threshold = 15; // 15px click radius
            for (const handle of scaleHandles) {
                const cx = parseFloat(handle.getAttribute('cx'));
                const cy = parseFloat(handle.getAttribute('cy'));
                const dx = point.x - cx;
                const dy = point.y - cy;
                const distSquared = dx * dx + dy * dy;

                if (distSquared < threshold * threshold) {
                    return handle;
                }
            }
            return null;
        }

        // Check if point is inside any selection box
        function isPointInSelectionBox(point) {
            for (const box of selectionBoxes) {
                const x = parseFloat(box.getAttribute('x'));
                const y = parseFloat(box.getAttribute('y'));
                const width = parseFloat(box.getAttribute('width'));
                const height = parseFloat(box.getAttribute('height'));

                if (point.x >= x && point.x <= x + width &&
                    point.y >= y && point.y <= y + height) {
                    return true;
                }
            }
            return false;
        }

        // Point-in-polygon test (ray casting algorithm)
        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Check if stroke is inside lasso polygon
        function isStrokeInLasso(stroke, lassoPolygon) {
            if (!stroke.points || stroke.points.length === 0) return false;

            // Get stroke's transform offset to check transformed position
            const transform = getStrokeTransform(stroke);

            // Check if majority of stroke points are inside the lasso
            let insideCount = 0;
            const step = Math.max(1, Math.floor(stroke.points.length / 20));

            for (let i = 0; i < stroke.points.length; i += step) {
                // Transform the point to its current position (scale then translate)
                const transformedPoint = {
                    x: stroke.points[i].x * transform.scale + transform.x,
                    y: stroke.points[i].y * transform.scale + transform.y
                };

                if (isPointInPolygon(transformedPoint, lassoPolygon)) {
                    insideCount++;
                }
            }

            // If more than 50% of sampled points are inside, select the stroke
            return insideCount > (stroke.points.length / step) / 2;
        }

        // Scale selected strokes from origin point
        function scaleSelectedStrokes(scaleFactor, origin) {
            let strokeIndex = 0;
            selectedStrokes.forEach(stroke => {
                // Get current transform
                const currentTransform = stroke.element.getAttribute('transform') || '';
                const translateMatch = currentTransform.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);

                let currentTranslateX = translateMatch ? parseFloat(translateMatch[1]) : 0;
                let currentTranslateY = translateMatch ? parseFloat(translateMatch[2]) : 0;

                // Store original bounds and transform on first scale
                if (!stroke.originalBounds) {
                    stroke.originalBounds = {
                        x: stroke.bounds.x,
                        y: stroke.bounds.y,
                        width: stroke.bounds.width,
                        height: stroke.bounds.height
                    };
                }
                if (!stroke.originalTransform) {
                    stroke.originalTransform = {
                        x: currentTranslateX,
                        y: currentTranslateY
                    };
                }
                if (!stroke.baseScale) {
                    stroke.baseScale = 1;
                }

                // Calculate the new absolute scale
                const newScale = stroke.baseScale * scaleFactor;

                // Calculate center of stroke in CURRENT transformed coordinates
                const currentCenterX = stroke.originalBounds.x * stroke.baseScale + stroke.originalBounds.width * stroke.baseScale / 2 + stroke.originalTransform.x;
                const currentCenterY = stroke.originalBounds.y * stroke.baseScale + stroke.originalBounds.height * stroke.baseScale / 2 + stroke.originalTransform.y;

                // Calculate vector from origin to current center
                const dx = currentCenterX - origin.x;
                const dy = currentCenterY - origin.y;

                // Scale this vector by the scale factor
                const newCenterX = origin.x + dx * scaleFactor;
                const newCenterY = origin.y + dy * scaleFactor;

                // Calculate new translation to position the scaled stroke
                const newX = newCenterX - (stroke.originalBounds.x * newScale + stroke.originalBounds.width * newScale / 2);
                const newY = newCenterY - (stroke.originalBounds.y * newScale + stroke.originalBounds.height * newScale / 2);

                // Apply both translate and scale transforms
                stroke.element.setAttribute('transform', `translate(${newX}, ${newY}) scale(${newScale})`);

                // Update bounds for collision detection
                stroke.bounds = {
                    x: stroke.originalBounds.x * newScale + newX,
                    y: stroke.originalBounds.y * newScale + newY,
                    width: stroke.originalBounds.width * newScale,
                    height: stroke.originalBounds.height * newScale
                };

                // Update selection box
                if (selectionBoxes[strokeIndex]) {
                    updateSelectionBox(selectionBoxes[strokeIndex], stroke);
                }
                strokeIndex++;
            });

            // Update scale handles
            updateScaleHandles();

            // Rebuild quadtree
            quadtree.clear();
            strokes.forEach(stroke => {
                if (stroke.bounds) {
                    quadtree.insert(stroke);
                }
            });
        }

        // Move selected strokes by offset
        function moveSelectedStrokes(offsetX, offsetY) {
            let strokeIndex = 0;
            selectedStrokes.forEach(stroke => {
                const currentTransform = stroke.element.getAttribute('transform') || '';
                const translateMatch = currentTransform.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
                const scaleMatch = currentTransform.match(/scale\(([-\d.]+)\)/);

                let newX = offsetX;
                let newY = offsetY;
                const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

                if (translateMatch) {
                    newX += parseFloat(translateMatch[1]);
                    newY += parseFloat(translateMatch[2]);
                }

                // Preserve scale in transform
                if (currentScale !== 1) {
                    stroke.element.setAttribute('transform', `translate(${newX}, ${newY}) scale(${currentScale})`);
                } else {
                    stroke.element.setAttribute('transform', `translate(${newX}, ${newY})`);
                }

                // Store original bounds on first move (preserves untransformed bounds forever)
                if (!stroke.originalBounds) {
                    stroke.originalBounds = {
                        x: stroke.bounds.x,
                        y: stroke.bounds.y,
                        width: stroke.bounds.width,
                        height: stroke.bounds.height
                    };
                }

                // Always calculate bounds from original + current transform
                // This ensures multiple drags work correctly
                stroke.bounds = {
                    x: stroke.originalBounds.x * currentScale + newX,
                    y: stroke.originalBounds.y * currentScale + newY,
                    width: stroke.originalBounds.width * currentScale,
                    height: stroke.originalBounds.height * currentScale
                };

                // Update the corresponding selection box
                if (selectionBoxes[strokeIndex]) {
                    updateSelectionBox(selectionBoxes[strokeIndex], stroke);
                }
                strokeIndex++;
            });

            // Update scale handles when dragging
            updateScaleHandles();

            // Rebuild quadtree with updated bounds so eraser can find moved strokes
            quadtree.clear();
            strokes.forEach(stroke => {
                if (stroke.bounds) {
                    quadtree.insert(stroke);
                }
            });
        }

        // Tool selection
        const penIcon = document.querySelector('.pen-icon');
        const wandIcon = document.querySelector('.wand-icon');
        const eraserIcon = document.querySelector('.eraser-icon');
        const lassoIcon = document.querySelector('.lasso-icon');
        const drawingTools = [penIcon, wandIcon, eraserIcon, lassoIcon];

        function setActiveTool(activeTool, toolName) {
            drawingTools.forEach(tool => tool.classList.remove('active'));
            activeTool.classList.add('active');
            currentTool = toolName;

            // Clear selection when switching away from lasso
            if (toolName !== 'lasso') {
                clearSelection();
            }
        }

        function clearSelection() {
            selectedStrokes.forEach(stroke => {
                stroke.element.setAttribute('opacity', '1');
            });
            selectedStrokes.clear();
            clearSelectionBoxes();
            clearScaleHandles();
            if (lassoPath) {
                lassoPath.remove();
                lassoPath = null;
            }
        }

        setActiveTool(penIcon, 'pen');

        penIcon.addEventListener('click', () => setActiveTool(penIcon, 'pen'));
        wandIcon.addEventListener('click', () => setActiveTool(wandIcon, 'highlighter'));
        eraserIcon.addEventListener('click', () => {
            setActiveTool(eraserIcon, 'eraser');
            updateEraserCursorSize();
        });
        lassoIcon.addEventListener('click', () => setActiveTool(lassoIcon, 'lasso'));

        // Color selection
        const blackCircle = document.querySelector('.black-circle');
        const blueCircle = document.querySelector('.blue-circle');
        const redCircle = document.querySelector('.red-circle');
        const blackIndicator = document.getElementById('blackIndicator');
        const blueIndicator = document.getElementById('blueIndicator');
        const redIndicator = document.getElementById('redIndicator');
        const colorPalette = document.getElementById('colorPalette');
        const colorPaletteGrid = document.getElementById('colorPaletteGrid');
        const colorPicker = document.getElementById('colorPicker');
        const colorHexInput = document.getElementById('colorHexInput');

        let currentColorCircle = null;
        let selectedColorCircle = blackCircle;

        const colorSwatches = [
            '#000000', '#333333', '#666666', '#999999', '#CCCCCC', '#FFFFFF',
            '#FF0000', '#FF6B00', '#FFD700', '#00FF00', '#00FFFF', '#0000FF',
            '#8B00FF', '#FF00FF', '#FF1493', '#8B4513', '#006400', '#191970',
            '#db090c', '#003fff', '#9cc6d9', '#5D5CDE', '#f3f3f3', '#ebebeb'
        ];

        colorSwatches.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = color;
            swatch.addEventListener('click', () => {
                setCircleColor(color);
            });
            colorPaletteGrid.appendChild(swatch);
        });

        function setCircleColor(color) {
            if (currentColorCircle) {
                const circle = currentColorCircle.querySelector('circle');
                if (circle) {
                    circle.setAttribute('fill', color);
                    if (currentColorCircle === selectedColorCircle) {
                        currentColor = color;
                    }
                }
                colorPalette.classList.remove('show');
                currentColorCircle = null;
            }
        }

        function updateColorIndicator(circleElement) {
            blackIndicator.classList.remove('show');
            blueIndicator.classList.remove('show');
            redIndicator.classList.remove('show');

            if (circleElement === blackCircle) {
                blackIndicator.classList.add('show');
            } else if (circleElement === blueCircle) {
                blueIndicator.classList.add('show');
            } else if (circleElement === redCircle) {
                redIndicator.classList.add('show');
            }
        }

        function selectColor(circleElement) {
            selectedColorCircle = circleElement;
            updateColorIndicator(circleElement);
            const circle = circleElement.querySelector('circle');
            currentColor = circle.getAttribute('fill');
        }

        function openColorPalette(circleElement, color) {
            currentColorCircle = circleElement;
            colorPicker.value = color;
            colorHexInput.value = color;
            colorPalette.classList.add('show');
        }

        let clickTimeout = null;
        let clickCount = 0;

        function handleCircleClick(circleElement, e) {
            e.stopPropagation();

            if (colorPalette.classList.contains('show') && currentColorCircle === circleElement) {
                colorPalette.classList.remove('show');
                currentColorCircle = null;
                return;
            }

            clickCount++;

            if (clickCount === 1) {
                clickTimeout = setTimeout(() => {
                    selectColor(circleElement);
                    clickCount = 0;
                }, 250);
            } else if (clickCount === 2) {
                clearTimeout(clickTimeout);
                const currentColor = circleElement.querySelector('circle').getAttribute('fill');
                selectColor(circleElement);
                openColorPalette(circleElement, currentColor);
                clickCount = 0;
            }
        }

        blackCircle.addEventListener('click', (e) => handleCircleClick(blackCircle, e));
        blueCircle.addEventListener('click', (e) => handleCircleClick(blueCircle, e));
        redCircle.addEventListener('click', (e) => handleCircleClick(redCircle, e));

        colorPicker.addEventListener('input', (e) => {
            const color = e.target.value;
            colorHexInput.value = color;
            setCircleColor(color);
        });

        colorHexInput.addEventListener('input', (e) => {
            let value = e.target.value;
            if (!value.startsWith('#')) {
                value = '#' + value;
            }
            if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                colorPicker.value = value;
                setCircleColor(value);
            }
        });

        document.addEventListener('click', (e) => {
            if (!colorPalette.contains(e.target) &&
                !blackCircle.contains(e.target) &&
                !blueCircle.contains(e.target) &&
                !redCircle.contains(e.target)) {
                colorPalette.classList.remove('show');
            }
        });

        // Menu functionality
        const menuIcon = document.getElementById('menuIcon');
        const menuModal = document.getElementById('menuModal');
        const menuOverlay = document.getElementById('menuOverlay');
        const settingsMenuItem = document.getElementById('settingsMenuItem');
        const settingsModal = document.getElementById('settingsModal');
        const settingsOverlay = document.getElementById('settingsOverlay');
        const exportMenuItem = document.getElementById('exportMenuItem');
        const clearMenuItem = document.getElementById('clearMenuItem');

        menuIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            menuModal.classList.toggle('show');
            menuOverlay.classList.toggle('show');
        });

        menuOverlay.addEventListener('click', () => {
            menuModal.classList.remove('show');
            menuOverlay.classList.remove('show');
        });

        settingsMenuItem.addEventListener('click', () => {
            menuModal.classList.remove('show');
            menuOverlay.classList.remove('show');
            settingsModal.classList.add('show');
            settingsOverlay.classList.add('show');
        });

        settingsOverlay.addEventListener('click', () => {
            settingsModal.classList.remove('show');
            settingsOverlay.classList.remove('show');
        });

        // Grid, snap cursor, and grid controls visibility toggle
        const showGridCheckbox = document.getElementById('showGridCheckbox');
        let snapCursorEnabled = false; // Disabled by default

        // Initialize grid as hidden by default
        gridOverlay.style.display = 'none';
        snapCursor.style.display = 'none';
        gridControls.style.display = 'none';

        showGridCheckbox.addEventListener('change', (e) => {
            const isEnabled = e.target.checked;
            snapCursorEnabled = isEnabled;

            // Toggle grid overlay
            if (isEnabled) {
                gridOverlay.style.display = 'block';
            } else {
                gridOverlay.style.display = 'none';
            }

            // Toggle snap cursor
            if (!isEnabled) {
                snapCursor.style.display = 'none';
            }

            // Toggle grid controls
            if (isEnabled) {
                gridControls.style.display = 'flex';
            } else {
                gridControls.style.display = 'none';
            }
        });

        exportMenuItem.addEventListener('click', () => {
            menuModal.classList.remove('show');
            menuOverlay.classList.remove('show');
            const svgData = new XMLSerializer().serializeToString(svg);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            const link = document.createElement('a');
            link.download = 'drawing.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        });

        clearMenuItem.addEventListener('click', () => {
            menuModal.classList.remove('show');
            menuOverlay.classList.remove('show');
            drawingLayer.innerHTML = '';
            strokes.length = 0;
            undoStack.length = 0;
            redoStack.length = 0;
            quadtree.clear();
        });

        // Undo/Redo
        const undoIcon = document.querySelector('.undo-icon');
        const redoIcon = document.querySelector('.redo-icon');

        undoIcon.addEventListener('click', () => {
            if (undoStack.length > 0) {
                const action = undoStack.pop();
                if (action.type === 'add') {
                    action.stroke.remove();
                    const index = strokes.findIndex(s => s.element === action.stroke);
                    if (index > -1) {
                        strokes.splice(index, 1);
                        // Rebuild quadtree
                        quadtree.clear();
                        strokes.forEach(stroke => {
                            if (stroke.bounds) {
                                quadtree.insert(stroke);
                            }
                        });
                    }
                    redoStack.push(action);
                }
            }
        });

        redoIcon.addEventListener('click', () => {
            if (redoStack.length > 0) {
                const action = redoStack.pop();
                if (action.type === 'add') {
                    drawingLayer.appendChild(action.stroke);
                    const bounds = calculatePathBounds(action.stroke);
                    const strokeData = {
                        element: action.stroke,
                        color: action.stroke.getAttribute('stroke'),
                        size: parseInt(action.stroke.getAttribute('stroke-width')),
                        bounds: bounds
                    };
                    strokes.push(strokeData);
                    quadtree.insert(strokeData);
                    undoStack.push(action);
                }
            }
        });

        // Grid controls draggable
        let isDragging = false;
        let currentX, currentY, initialX, initialY;
        let xOffset = 0, yOffset = 0;

        gridControls.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (e.target.type === 'range') return;
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
            if (e.target === gridControls || gridControls.contains(e.target)) {
                isDragging = true;
            }
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                xOffset = currentX;
                yOffset = currentY;
                gridControls.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        }

        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const currentGridSize = parseInt(gridSize.value);

            if (e.key === 'f' || e.key === 'F') {
                const newSize = Math.max(10, currentGridSize - 5);
                gridSize.value = newSize;
                gridSizeValue.textContent = newSize;
                document.documentElement.style.setProperty('--grid-size', `${newSize}px`);
            } else if (e.key === 'g' || e.key === 'G') {
                const newSize = Math.min(100, currentGridSize + 5);
                gridSize.value = newSize;
                gridSizeValue.textContent = newSize;
                document.documentElement.style.setProperty('--grid-size', `${newSize}px`);
            }
        });

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
            const currentGridSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size'));
            const snapX = Math.round(e.clientX / currentGridSize) * currentGridSize;
            const snapY = Math.round(e.clientY / currentGridSize) * currentGridSize;
            const gridX = Math.round(e.clientX / currentGridSize);
            const gridY = Math.round(e.clientY / currentGridSize);

            if (snapCursorEnabled) {
                snapCursor.style.left = snapX + 'px';
                snapCursor.style.top = snapY + 'px';
            }

            gridInfo.textContent = `Mouse: (${e.clientX}, ${e.clientY}) | Grid: (${gridX}, ${gridY}) | Snap: (${snapX}, ${snapY})`;
        });

        document.addEventListener('mouseleave', () => {
            snapCursor.style.display = 'none';
        });

        document.addEventListener('mouseenter', () => {
            if (snapCursorEnabled) {
                snapCursor.style.display = 'block';
            }
        });

        // Prevent scrolling on touch
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Fullscreen functionality
        const fullscreenIcon = document.getElementById('fullscreenIcon');
        const exitFullscreenIcon = document.getElementById('exitFullscreenIcon');

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                // Exit fullscreen
                document.exitFullscreen();
            }
        }

        // Update icons based on fullscreen state
        function updateFullscreenIcons() {
            if (document.fullscreenElement) {
                fullscreenIcon.style.display = 'none';
                exitFullscreenIcon.style.display = 'block';
            } else {
                fullscreenIcon.style.display = 'block';
                exitFullscreenIcon.style.display = 'none';
            }
        }

        fullscreenIcon.addEventListener('click', toggleFullscreen);
        exitFullscreenIcon.addEventListener('click', toggleFullscreen);

        // Listen for fullscreen changes (including F11 or browser controls)
        document.addEventListener('fullscreenchange', updateFullscreenIcons);
    </script>
</body>
</html>

